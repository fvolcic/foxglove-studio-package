(()=>{var te={79108:(a,y,u)=>{"use strict";var P=u(80144),t=u.n(P);function S(e,n){const r=[];let o=0;for(const s of e){const d=n(s,o++);d&&r.push(d)}return r}var _;class F{constructor(){_.set(this,new Map)}get(n){return __classPrivateFieldGet(this,_,"f").get(n)}set(n,r){const o=__classPrivateFieldGet(this,_,"f").get(n);o==null?__classPrivateFieldGet(this,_,"f").set(n,[r]):o.includes(r)||o.push(r)}delete(n,r){const o=__classPrivateFieldGet(this,_,"f").get(n);if(o!=null){const s=o.indexOf(r);s>=0&&(o.splice(s,1),o.length===0&&__classPrivateFieldGet(this,_,"f").delete(n))}}deleteAll(n){__classPrivateFieldGet(this,_,"f").delete(n)}clear(){__classPrivateFieldGet(this,_,"f").clear()}}_=new WeakMap;const I=[t().factory.createModifier(t().SyntaxKind.ExportKeyword),t().factory.createModifier(t().SyntaxKind.DeclareKeyword)],R=(e,n)=>t().factory.createPropertySignature(void 0,e,void 0,n),ne=e=>t().factory.createInterfaceDeclaration(void 0,I,e,void 0,void 0,[R("sec",t().factory.createKeywordTypeNode(t().SyntaxKind.NumberKeyword)),R("nsec",t().factory.createKeywordTypeNode(t().SyntaxKind.NumberKeyword))]),Se=t().factory.createInterfaceDeclaration(void 0,I,"json",void 0,void 0,[]),j=e=>e.replace(/\//g,"__"),xe=new Map([["uint8",t().SyntaxKind.NumberKeyword],["int8",t().SyntaxKind.NumberKeyword],["uint16",t().SyntaxKind.NumberKeyword],["int16",t().SyntaxKind.NumberKeyword],["uint32",t().SyntaxKind.NumberKeyword],["int32",t().SyntaxKind.NumberKeyword],["float32",t().SyntaxKind.NumberKeyword],["float64",t().SyntaxKind.NumberKeyword],["int64",t().SyntaxKind.NumberKeyword],["uint64",t().SyntaxKind.NumberKeyword],["string",t().SyntaxKind.StringKeyword],["bool",t().SyntaxKind.BooleanKeyword]]),V=new Map([["uint8","Uint8Array"],["int8","Int8Array"]]),oe=ne("Time"),se=ne("Duration"),_e=new Map([["time",oe],["duration",se]]),ie=e=>{const n={};for(const[r,o]of e){if(r.includes(".")||n[r])continue;const s=S(o.definitions,({name:d,type:c,isArray:p,isConstant:i})=>{let E;const x=V.get(c),C=xe.get(c),k=_e.get(c);if(i!==!0)return p===!0&&x!=null?E=t().factory.createTypeReferenceNode(x):C!=null?E=t().factory.createKeywordTypeNode(C):k?E=t().factory.createTypeReferenceNode(k.name):E=t().factory.createTypeReferenceNode(j(c)),p===!0&&x==null&&(E=t().factory.createArrayTypeNode(E)),R(d,E)});n[r]=t().factory.createInterfaceDeclaration(void 0,[t().factory.createModifier(t().SyntaxKind.ExportKeyword)],j(r),void 0,void 0,s)}return n},Ne=({topics:e,datatypes:n})=>{let r=t().factory.createInterfaceDeclaration(void 0,I,"TopicsToMessageDefinition",void 0,void 0,[]);const o=t().factory.createInterfaceDeclaration(void 0,I,"Input",[t().factory.createTypeParameterDeclaration([],"T",t().factory.createTypeOperatorNode(t().SyntaxKind.KeyOfKeyword,t().factory.createTypeReferenceNode(r.name)))],void 0,[R("topic",t().factory.createTypeReferenceNode("T")),R("receiveTime",t().factory.createTypeReferenceNode("Time")),R("message",t().factory.createTypeReferenceNode("TopicsToMessageDefinition[T]"))]),s="Messages";let d=ie(n);e.forEach(({name:x,schemaName:C})=>{C!=null&&(d[C]||(d={...d,...ie(new Map(Object.entries({[C]:{definitions:[]}})))}),r=t().factory.updateInterfaceDeclaration(r,I,r.name,void 0,void 0,[...r.members,R(t().factory.createStringLiteral(x),t().factory.createTypeReferenceNode(`${s}.${j(C)}`))]))});const c=t().factory.createModuleDeclaration(I,t().factory.createIdentifier(s),t().factory.createModuleBlock(Object.values(d).map(x=>x)),t().NodeFlags.Namespace),p=t().createSourceFile("","",t().ScriptTarget.Latest,!1,t().ScriptKind.TS),i=t().createPrinter();return`
    ${i.printNode(t().EmitHint.Unspecified,Se,p)}
    ${i.printNode(t().EmitHint.Unspecified,r,p)}
    ${i.printNode(t().EmitHint.Unspecified,se,p)}
    ${i.printNode(t().EmitHint.Unspecified,oe,p)}

    /**
     * This type contains every message declaration in your bag, so that you can
     * refer to the type "std_msgs/RGBA" as "std_msgs__RGBA" wherever you like.
     */
    ${i.printNode(t().EmitHint.Unspecified,c,p)}

    /**
     * To correctly type your inputs, you use this type to refer to specific
     * input topics, e.g. 'Input<"/your_input_topic">'. If you have
     * multiple input topics, use a union type, e.g.
     * 'Input<"/your_input_topic_1"> |
     * Input<"/your_input_topic_2">'.
     *
     * These types are dynamically generated from the bag(s) currently in your
     * Foxglove Studio session, so if a datatype changes, your User Script
     * may not compile on the newly formatted bag.
     */
    ${i.printNode(t().EmitHint.Unspecified,o,p)}
  `},f={Hint:1,Info:2,Warning:4,Error:8},m={Typescript:"Typescript",DatatypeExtraction:"DatatypeExtraction",InputTopicsChecker:"InputTopicsChecker",OutputTopicChecker:"OutputTopicChecker",Runtime:"Runtime"},T={RUNTIME:1,DatatypeExtraction:{NO_DEFAULT_EXPORT:1,NON_FUNC_DEFAULT_EXPORT:2,NO_TYPE_RETURN:3,BAD_TYPE_RETURN:4,UNKNOWN_ERROR:5,NO_UNIONS:6,NO_FUNCTIONS:7,NO_CLASSES:8,NO_TYPE_LITERALS:9,NO_TUPLES:10,NO_INTERSECTION_TYPES:11,NO_TYPEOF:12,PREFER_ARRAY_LITERALS:13,STRICT_MARKERS_RETURN_TYPE:14,LIMITED_UNIONS:15,NO_NESTED_ANY:16,NO_MAPPED_TYPES:17,INVALID_PROPERTY:18,INVALID_INDEXED_ACCESS:19},InputTopicsChecker:{NO_TOPIC_AVAIL:1,NO_INPUTS_EXPORT:2,EMPTY_INPUTS_EXPORT:3,BAD_INPUTS_TYPE:4},OutputTopicChecker:{NO_OUTPUTS:1,NOT_UNIQUE:2,EXISTING_TOPIC:3}},ae={severity:f.Error,message:"No 'default export' function found.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_DEFAULT_EXPORT},ce={severity:f.Error,message:"The 'default export' must be assigned to a function.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NON_FUNC_DEFAULT_EXPORT},U={severity:f.Error,message:"The 'default export' function must return an object type with at least one property.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.BAD_TYPE_RETURN},be={severity:f.Error,message:"The 'default export' function can only return union types of the form: 'YourType | undefined'.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.LIMITED_UNIONS},Ie={severity:f.Error,message:"Unions are not allowed in return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_UNIONS},ue={severity:f.Error,message:"Functions are not allowed as or in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_FUNCTIONS},ve={severity:f.Error,message:"Type literals are not allowed as or in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_TYPE_LITERALS},de={severity:f.Error,message:"Type intersections are not allowed as or in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_INTERSECTION_TYPES},Pe={severity:f.Error,message:"Please use array literal syntax (e.g. 'number[]') instead of the 'Array<number>'.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.PREFER_ARRAY_LITERALS},X={severity:f.Error,message:"Classes are not allowed as or in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_CLASSES},Oe={severity:f.Error,message:"'typeof' cannot be used as or in the return type",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_TYPEOF},Ce={severity:f.Error,message:"Tuples are not allowed as types.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_TUPLES},De={severity:f.Error,message:"Cannot nest 'any' in the return type.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_NESTED_ANY},Re={severity:f.Error,message:"MappedTypes such as Record<Keys,Type> are not supported.",source:m.DatatypeExtraction,code:T.DatatypeExtraction.NO_MAPPED_TYPES},pe=100;class h extends Error{constructor(n){super(),this.diagnostic=n}}const ke=(e,n)=>t().forEachChild(e,r=>{if(n.includes(r.kind))return r}),Y=(e,n)=>{for(const r of e.declarations??[])if(n.includes(r.kind))return r},Ke=(e,n,r)=>{const o=z(n);if(!o)return;const s=e.getDeclaredTypeOfSymbol(o);return Y(s.symbol??s.aliasSymbol,r)},le=(e=[],n)=>{const r={};for(let o=0;o<e.length;o++){const s=e[o];s&&(r[s.name.escapedText.toString()]={current:s,parent:n[o]??{parent:void 0,current:s.default}})}return r},Me=(e=[],n)=>{const r={};return e.forEach((o,s)=>{const d=o.getText(),c=n[d]??n[s],p=o;r[s]={current:p,parent:c}}),r},fe=e=>e.getSourceFile().fileName.endsWith("ros/index.d.ts");function z(e){return e?.symbol}const Fe=(e,n)=>{const r=z(e);if(!r)return;const o=n.getExportsOfModule(r).find(p=>p.escapedName==="default");if(!o)throw new h(ae);const s=Y(o,[t().SyntaxKind.FunctionDeclaration]);if(s)return s;const d=Y(o,[t().SyntaxKind.ExportAssignment]);if(!d)throw new h(ae);const c=ke(d,[t().SyntaxKind.FunctionDeclaration,t().SyntaxKind.FunctionExpression,t().SyntaxKind.ArrowFunction,t().SyntaxKind.Identifier]);if(!c)throw new h(ce);return c},Ae=(e,n)=>{const o=e.getTypeAtLocation(n).getCallSignatures(),s=o[0];if(o.length!==1||!s)throw new h(ce);const c=e.getReturnTypeOfSignature(s).getNonNullableType();if(c.isIntersection())throw new h(de);if(c.isClass())throw new h(X);if(c.isUnion())throw new h(be);const p=c.getSymbol();if(!p)throw new h(U);if(!p.declarations||p.declarations.length===0)throw new h(U);let i;if(p.declarations.length===1?i=p.declarations[0]:i=p.declarations.filter(E=>E.kind===t().SyntaxKind.InterfaceDeclaration)[0],!i)throw new h(U);if(t().isTypeLiteralNode(i))return i;if(t().isInterfaceDeclaration(i))return i;throw t().isMappedTypeNode(i)?new h(Re):t().isClassDeclaration(i)?new h(X):t().isFunctionLike(i)?new h(ue):new h(U)},ye=(e,n,r,o,s,d=1,c={})=>{if(d>pe)throw new Error("Max AST traversal depth exceeded.");const p=t().isInterfaceDeclaration(n)?n.name.text:void 0,i=p!=null?o[p]:void 0;if(fe(n)&&i!=null)return{outputDatatype:i,datatypes:s};if(n.getSourceFile().fileName==="/studio_script/generatedTypes.ts"&&t().isPropertySignature(n.parent)&&t().isStringLiteral(n.parent.name))return{outputDatatype:n.parent.name.text,datatypes:s};let E=new Map;const x=(w,O,D=!1,K=!1,g={},N=1)=>{if(N>pe)throw new Error("Max AST traversal depth exceeded.");switch(O.kind){case t().SyntaxKind.InterfaceDeclaration:case t().SyntaxKind.TypeLiteral:{const b=O,v=z(O)?.name,M=v!=null?o[v]:void 0,A=fe(b)&&M!=null?M:`${r}/${w}`,L=t().isInterfaceDeclaration(O)?le(O.typeParameters,g):g,{datatypes:we}=ye(e,b,A,o,s,d+1,L),Q=we.get(A)?.definitions??[];if(Q.length===2){const Z=Q.find(ee=>ee.name==="sec"),q=Q.find(ee=>ee.name==="nsec");if(Z&&q&&Z.isComplex!==!0&&q.isComplex!==!0&&Z.isArray!==!0&&q.isArray!==!0)return{name:w,type:"time",isArray:!1,isComplex:!1,arrayLength:void 0}}return E=new Map([...E,...we]),{name:w,type:A,isArray:D,isComplex:!0,arrayLength:void 0}}case t().SyntaxKind.ArrayType:return x(w,O.elementType,!0,!0,g,N+1);case t().SyntaxKind.BigIntKeyword:return{name:w,type:"int64",isArray:D,isComplex:K,arrayLength:void 0};case t().SyntaxKind.NumberKeyword:return{name:w,type:"float64",isArray:D,isComplex:K,arrayLength:void 0};case t().SyntaxKind.StringKeyword:return{name:w,type:"string",isArray:D,isComplex:K,arrayLength:void 0};case t().SyntaxKind.BooleanKeyword:return{name:w,type:"bool",isArray:D,isComplex:K,arrayLength:void 0};case t().SyntaxKind.TypeAliasDeclaration:{const b=O,v=le(b.typeParameters,g);return x(w,b.type,D,K,v,N+1)}case t().SyntaxKind.TypeReference:{const b=O,v=e.getSymbolAtLocation(b.typeName);if(v?.escapedName==="Array")throw new h(Pe);if(!v)throw new Error("Could not find symbol");const M=Y(v,[t().SyntaxKind.TypeParameter]);if(M){if(g[M.name.escapedText.toString()]){let L=g[M.name.escapedText.toString()];for(;L?.parent;)L=L.parent;return x(w,L.current,D,K,g,N+1)}throw new Error(`Could not find type ${M.getText()} in type map.`)}const A=Y(v,[t().SyntaxKind.TypeAliasDeclaration,t().SyntaxKind.InterfaceDeclaration,t().SyntaxKind.ImportSpecifier,t().SyntaxKind.ClassDeclaration]);if(!A)throw new Error("Could not find next node");return x(w,A,D,K,Me(b.typeArguments,g),N+1)}case t().SyntaxKind.TypeQuery:throw new h(Oe);case t().SyntaxKind.ImportSpecifier:{const b=Ke(e,O,[t().SyntaxKind.TypeLiteral,t().SyntaxKind.InterfaceDeclaration,t().SyntaxKind.TypeAliasDeclaration]);if(!b)throw new Error("Failed to find import declaration");return x(w,b,D,K,g,N+1)}case t().SyntaxKind.IntersectionType:throw new h(de);case t().SyntaxKind.TupleType:throw new h(Ce);case t().SyntaxKind.StringLiteral:case t().SyntaxKind.NumericLiteral:case t().SyntaxKind.LiteralType:throw new h(ve);case t().SyntaxKind.ClassDeclaration:throw new h(X);case t().SyntaxKind.UnionType:throw new h(Ie);case t().SyntaxKind.FunctionType:throw new h(ue);case t().SyntaxKind.AnyKeyword:throw new h(De);default:{const v=e.getTypeAtLocation(O).symbol,M=v.declarations?.[0];if(v.declarations?.length!==1||!M)throw new h(U);return x(w,M,!1,void 0,g,N+1)}}},{members:C=[]}=n,k=C.map(w=>{if(!w.name)throw new h({severity:f.Error,message:`Encountered type member with no name in ${p??r}`,source:m.DatatypeExtraction,code:T.DatatypeExtraction.INVALID_PROPERTY});if(!t().isPropertySignature(w))throw new h({severity:f.Error,message:`Unexpected type member (kind ${w.kind}) in ${p??r}`,source:m.DatatypeExtraction,code:T.DatatypeExtraction.INVALID_PROPERTY});if(!w.type)throw new h({severity:f.Error,message:`Member ${w.name.getText()} has no type in ${p??r}`,source:m.DatatypeExtraction,code:T.DatatypeExtraction.INVALID_PROPERTY});return x(w.name.getText(),w.type,!1,!1,c,d+1)});return{outputDatatype:r,datatypes:new Map([...E,...new Map([[r,{definitions:k}]])])}};var Le=u(64942);const Ue=e=>{switch(e){case t().DiagnosticCategory.Error:return f.Error;case t().DiagnosticCategory.Warning:return f.Warning;case t().DiagnosticCategory.Message:return f.Info;case t().DiagnosticCategory.Suggestion:return f.Hint;default:throw new Error("Diagnostic category not recognized")}},Ye=e=>{if(!e.file||e.start==null||e.length==null)throw new Error("Invariant: diagnostic is not initialized");const{line:n,character:r}=e.file.getLineAndCharacterOfPosition(e.start),{line:o,character:s}=e.file.getLineAndCharacterOfPosition(e.start+e.length);return{message:ge(e.messageText,`
`),severity:Ue(e.category),source:"Typescript",startLineNumber:n,startColumn:r,endLineNumber:o,endColumn:s,code:e.code}};function ge(e,n,r=0){if(typeof e=="string")return e;if(e==null)return"";let o="";if(r>0){o+=n;for(let s=0;s<r;s++)o+="  "}if(o+=e.messageText,e.next)for(const s of e.next)o+=ge(s,n,r+1);return o}const me={strict:!0,target:t().ScriptTarget.ES2020,module:t().ModuleKind.CommonJS};var $e=u(11701);const We=`type MessageTypeByTopic = {
  // placeholder
};
type MessageTypeBySchemaName = {
  // placeholder
};

export type { MessageTypeByTopic, MessageTypeBySchemaName };
`,Te=e=>e.diagnostics.some(({severity:n})=>n===f.Error),Be=e=>{const{sourceFile:n,typeChecker:r}=e;if(!n||!r){const i={severity:f.Error,message:"Either the 'sourceFile' or 'typeChecker' is absent. There is a problem with the `compile` step.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...e,diagnostics:[...e.diagnostics,i]}}const o=r.getSymbolAtLocation(n);if(!o){const i={severity:f.Error,message:"Must export an input topics array. E.g. 'export const inputs = ['/some_topics']'",source:m.InputTopicsChecker,code:T.InputTopicsChecker.NO_INPUTS_EXPORT};return{...e,diagnostics:[...e.diagnostics,i]}}const s=r.getExportsOfModule(o).find(i=>i.escapedName==="inputs");if(!s){const i={severity:f.Error,message:"Must export a non-empty inputs array.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.EMPTY_INPUTS_EXPORT};return{...e,diagnostics:[...e.diagnostics,i]}}const d=s.declarations?.[0];if(!d||!t().isVariableDeclaration(d)){const i={severity:f.Error,message:"inputs export must be an array variable.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...e,diagnostics:[...e.diagnostics,i]}}if(!d.initializer||!t().isArrayLiteralExpression(d.initializer)){const i={severity:f.Error,message:"inputs export must be an array variable.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...e,diagnostics:[...e.diagnostics,i]}}const c=d.initializer.elements;if(c.some(({kind:i})=>i!==t().SyntaxKind.StringLiteral)){const i={severity:f.Error,message:"The exported 'inputs' variable must be an array of string literals. E.g. 'export const inputs = ['/some_topics']'",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...e,diagnostics:[...e.diagnostics,i]}}const p=S(c,i=>{if(t().isStringLiteral(i))return i.text});if(p.length===0){const i={severity:f.Error,message:'Must include non-empty inputs array, e.g. export const inputs = ["/some_input_topic"];',source:m.InputTopicsChecker,code:T.InputTopicsChecker.EMPTY_INPUTS_EXPORT};return{...e,diagnostics:[...e.diagnostics,i]}}return{...e,inputTopics:p}},je=e=>{const n=/^\s*export\s+const\s+output\s*=\s*("([^"]+)"|'([^']+)')/gm.exec(e.sourceCode),r=n?.[2]??n?.[3];if(r==null){const o={severity:f.Error,message:`Must include an output, e.g. export const output = "${$e.wd}your_output_topic";`,source:m.OutputTopicChecker,code:T.OutputTopicChecker.NO_OUTPUTS};return{...e,diagnostics:[...e.diagnostics,o]}}return{...e,outputTopic:r}},Ge=(e,n)=>{const{inputTopics:r}=e,o=n.map(({name:d})=>d),s=[];for(const d of r)o.includes(d)||s.push({severity:f.Error,message:`Input "${d}" is not yet available`,source:m.InputTopicsChecker,code:T.InputTopicsChecker.NO_TOPIC_AVAIL});return{...e,diagnostics:[...e.diagnostics,...s]}},He=e=>{const{sourceCode:n,rosLib:r,typesLib:o}=e,s=me,d="/studio_script/index.ts",c=(0,Le.v)(),p=new Map,i=new Map;i.set(d,n),i.set(c.rosLib.filePath,r),i.set("/studio_script/generatedTypes.ts",o||We),c.utilityFiles.forEach(g=>i.set(g.filePath,g.sourceCode)),c.declarations.forEach(g=>i.set(g.filePath,g.sourceCode));let E="",x=!1;const C={getDefaultLibFileName:()=>c.defaultLibFileName,getCurrentDirectory:()=>"",getCanonicalFileName:g=>g,useCaseSensitiveFileNames:()=>!1,readFile:()=>{},fileExists:g=>{for(const[N]of i.entries())if(g===N||g.endsWith(N))return!0;return!1},writeFile:(g,N)=>{x=!0,g==="/studio_script/index.js"?E=N:p.set(g,N)},getNewLine:()=>`
`,getSourceFile:g=>{let N="";for(const[b,v]of i.entries())if(g===b||g.endsWith(b)){N=v;break}return t().createSourceFile(g,N,me.target,!0)}},k=t().createProgram([d],s,C);if(k.emit(),!x){const g={severity:f.Error,message:"Program code was not emitted.",source:m.InputTopicsChecker,code:T.InputTopicsChecker.BAD_INPUTS_TYPE};return{...e,diagnostics:[...e.diagnostics,g]}}const O=[...k.getSemanticDiagnostics(),...k.getSyntacticDiagnostics()].map(Ye),D=k.getSourceFile(d),K=k.getTypeChecker();return{...e,sourceFile:D,typeChecker:K,transpiledCode:E,projectCode:p,diagnostics:[...e.diagnostics,...O]}},Ve=e=>{if(Te(e))return e;const{sourceFile:n}=e;if(!n)throw new Error("'sourceFile' is absent'. There is a problem with the `compile` step.");const r=n.forEachChild(s=>{if(t().isTypeAliasDeclaration(s)&&t().isTypeLiteralNode(s.type)&&s.name.text==="GlobalVariables")return s.type.members;if(t().isInterfaceDeclaration(s)&&s.name.text==="GlobalVariables")return s.members}),o=S(r??[],s=>{if(s.name&&(t().isIdentifier(s.name)||t().isStringLiteral(s.name)))return s.name.text});return{...e,globalVariables:o}},Xe=e=>{if(Te(e))return e;const{sourceFile:n,typeChecker:r,name:o,datatypes:s}=e;if(!n||!r)throw new Error("Either the 'sourceFile' or 'typeChecker' is absent'. There is a problem with the `compile` step.");const d={};for(const c of s.keys())d[j(c)]=c;try{const c=Fe(n,r);if(!c)throw new Error("Your node must default export a function");const p=Ae(r,c),{outputDatatype:i,datatypes:E}=ye(r,p,o,d,s);return{...e,datatypes:E,outputDatatype:i}}catch(c){return c instanceof h?{...e,diagnostics:[...e.diagnostics,c.diagnostic]}:{...e,diagnostics:[...e.diagnostics,{message:c.message,severity:f.Error,source:m.DatatypeExtraction,code:T.DatatypeExtraction.UNKNOWN_ERROR}]}}},ze=(...e)=>(n,r)=>{let o=n;for(const s of e)o=s(o,r);return o},Je=e=>{const{name:n,sourceCode:r,topics:o,rosLib:s,typesLib:d,datatypes:c}=e;return{...ze(je,He,Be,Ge,Xe,Ve)({name:n,sourceCode:r,rosLib:s,typesLib:d,transpiledCode:"",projectCode:void 0,inputTopics:[],outputTopic:"",outputDatatype:"",diagnostics:[],globalVariables:[],datatypes:c,sourceFile:void 0,typeChecker:void 0},o),sourceFile:void 0,typeChecker:void 0}},$="$$RESPONSE",J="$$ERROR";function at(){const e={onmessage:void 0,postMessage(r,o){const s=new MessageEvent("message",{data:r});n.onmessage&&n.onmessage(s)},terminate:()=>{}},n={onmessage:void 0,postMessage(r,o){const s=new MessageEvent("message",{data:r});e.onmessage&&e.onmessage(s)},terminate:()=>{}};return{local:e,remote:n}}class W{constructor(n){if(this._messageId=0,this._pendingCallbacks={},this._receivers=new Map,this._onChannelMessage=r=>{const{id:o,topic:s,data:d}=r.data;if(s===$){this._pendingCallbacks[o]?.(r.data),delete this._pendingCallbacks[o];return}new Promise(c=>{const p=this._receivers.get(s);if(!p)throw new Error(`no receiver registered for ${s}`);c(p(d))}).then(c=>{if(!c)return this._channel.postMessage({topic:$,id:o});const p=c[W.transferables];delete c[W.transferables];const i={topic:$,id:o,data:c};this._channel.postMessage(i,p)}).catch(c=>{const p={topic:$,id:o,data:{[J]:!0,name:c.name,message:c.message,stack:c.stack}};this._channel.postMessage(p)})},this._channel=n,this._channel.onmessage)throw new Error("channel.onmessage is already set. Can only use one Rpc instance per channel.");this._channel.onmessage=this._onChannelMessage}terminate(){for(const[n,r]of Object.entries(this._pendingCallbacks))r({topic:$,id:n,data:{[J]:!0,name:"Error",message:"Rpc terminated",stack:new Error().stack}})}async send(n,r,o){const s=this._messageId++,d={topic:n,id:s,data:r},c=new Promise((p,i)=>{this._pendingCallbacks[s]=E=>{if(E.data?.[J]!=null){const x=new Error(E.data.message);x.name=E.data.name,x.stack=E.data.stack,i(x)}else p(E.data)}});return this._channel.postMessage(d,o),await c}receive(n,r){if(this._receivers.has(n))throw new Error(`Receiver already registered for topic: ${n}`);this._receivers.set(n,r)}}W.transferables="$$TRANSFERABLES";const he=u.g;function Qe(e){he.foxgloveStudioReportErrorFn?.(e)}function ct(e){he.foxgloveStudioReportErrorFn=e}class Ze extends Error{constructor(n,r){if(super(),this.details=n,this.extraInfo=r,this.name="AppError",this.message="",n instanceof Error?this.message=n.stack??n.message:typeof n=="string"&&(this.message=n),r!=null)if(r.componentStack!=null)this.message+=`

${r.componentStack}`;else try{const o=JSON.stringify(r);this.message+=`

${o}`}catch{this.message+=`

[ Either cyclic object or object with BigInt(s) ]`}this.message===""&&(this.message="Unknown Error")}}const qe=()=>typeof u.g.postMessage<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,et=()=>typeof SharedWorkerGlobalScope<"u"&&self instanceof SharedWorkerGlobalScope,tt=e=>{const n=typeof fetch<"u"&&fetch("data:test").then(()=>!0).catch(()=>!1);return async(...r)=>{if(await n)throw new Error("Content security policy too loose.");return e(...r)}},G=(e,n,r,o)=>{if(qe()){(o==="error"?console.error:o==="warn"?console.warn:console.info)("Web Worker has uninitialized sendNotification function; this means this error message cannot show up in the UI (so we show it here in the console instead).",e,n,r);return}console.error("Notification before error display is mounted",e,n,r)};let B=G;function rt(e){if(B!==G)throw new Error("Tried to overwrite existing NotificationHandler");B=e}function ut(){if(B===G)throw new Error("Tried to unset NotificationHandler but it was already the default");B=G}function nt(e,n,r,o){r==="app"&&(o==="warn"||o==="error")&&Qe(new Ze(n,e)),B(e,n,r,o)}nt.expectCalledDuringTest=()=>{throw new Error("Should be overriden in setupTestFramework.ts")};function Ee(e){rt((n,r,o,s)=>{r instanceof Error||typeof r=="string"||console.warn("Invalid Error type",r),e.send("sendNotification",{message:n,details:r instanceof Error?r.toString():r,type:o,severity:s})})}function dt(e){Ee(e),overwriteFetch()}let H=[];if(u.g.onerror=e=>{H.push(e.error.toString())},u.g.onunhandledrejection=e=>{H.push(String(e.reason instanceof Error?e.reason.message:e.reason))},!et())throw new Error("Not in a SharedWorker.");u.g.onconnect=e=>{const n=e.ports[0];if(!n)throw new Error("NodeTransformWorker connect requires at least 1 message port.");const r=new W(n);H.forEach(async o=>await r.send("error",o)),H=[],u.g.onerror=o=>{r.send("error",o.error.toString())},u.g.onunhandledrejection=o=>{r.send("error",String(o.reason instanceof Error?o.reason.message:o.reason))},Ee(r),r.receive("close",()=>{u.g.close()}),r.receive("transform",tt(Je)),r.receive("generateRosLib",Ne),n.start()}},23621:(a,y,u)=>{"use strict";u.d(y,{Y:()=>P,k:()=>t});const P="ros/index.d.ts",t=`
  export declare interface Duration {
    sec: number;
    nsec: number;
  }

  export declare interface Time {
    sec: number;
    nsec: number;
  }

  // Once a data source Messages will be populated with interfaces matching the data source messages.
  export declare namespace Messages {}

  // Once a data source TopicsToMessageDefinition will be populated with topic names to message interfaces.
  export declare interface TopicsToMessageDefinition {}

  /**
   * To correctly type your inputs, you use this type to refer to specific
   * input topics, e.g. 'Input<"/your_input_topic">'. If you have
   * multiple input topics, use a union type, e.g.
   * 'Input<"/your_input_topic_1"> |
   * Input<"/your_input_topic_2">'.
   *
   * These types are dynamically generated from the bag(s) currently in your
   * Foxglove Studio session, so if a datatype changes, your User Script
   * may not compile on the newly formatted bag.
   */
  export declare interface Input<T extends keyof TopicsToMessageDefinition> {
    topic: T;
    receiveTime: Time;
    message: TopicsToMessageDefinition[T];
  }

`},11701:(a,y,u)=>{"use strict";u.d(y,{wd:()=>P});const P="/studio_script/";function t(){const{palette:{mode:_,text:F}}=useTheme();return{dark:{base00:"transparent",base0B:"#ffa657",base09:"#7ee787",base07:"#79c0ff",base08:"#ff7b72",base0D:"#79c0ff",base03:F.secondary},light:{base00:"transparent",base0B:"#953800",base09:"#116329",base07:"#0550ae",base08:"#cf222e",base0D:"#0550ae",base03:F.secondary}}[_]}const S="Tab"},63136:(a,y,u)=>{"use strict";u.d(y,{Z:()=>t});const t={nextTick:(S,..._)=>{queueMicrotask(()=>{S(..._)})},title:"browser",browser:!0,env:{},argv:[]}},89424:()=>{},9445:()=>{},70546:()=>{},15490:()=>{},80136:()=>{},91389:()=>{},9865:()=>{},73860:()=>{},74650:()=>{},98752:()=>{}},re={};function l(a){var y=re[a];if(y!==void 0)return y.exports;var u=re[a]={exports:{}};return te[a].call(u.exports,u,u.exports,l),u.exports}l.m=te,l.x=()=>{var a=l.O(void 0,[7185,144,4942],()=>l(79108));return a=l.O(a),a},(()=>{var a=[];l.O=(y,u,P,t)=>{if(u){t=t||0;for(var S=a.length;S>0&&a[S-1][2]>t;S--)a[S]=a[S-1];a[S]=[u,P,t];return}for(var _=1/0,S=0;S<a.length;S++){for(var[u,P,t]=a[S],F=!0,I=0;I<u.length;I++)(t&!1||_>=t)&&Object.keys(l.O).every(V=>l.O[V](u[I]))?u.splice(I--,1):(F=!1,t<_&&(_=t));if(F){a.splice(S--,1);var R=P();R!==void 0&&(y=R)}}return y}})(),l.n=a=>{var y=a&&a.__esModule?()=>a.default:()=>a;return l.d(y,{a:y}),y},l.d=(a,y)=>{for(var u in y)l.o(y,u)&&!l.o(a,u)&&Object.defineProperty(a,u,{enumerable:!0,get:y[u]})},l.f={},l.e=a=>Promise.all(Object.keys(l.f).reduce((y,u)=>(l.f[u](a,y),y),[])),l.u=a=>""+a+"."+{144:"a97e352fda49870b8608",4942:"6ac33d44da8b414a4887",7185:"5dc7f9f5a542dd48dce4"}[a]+".js",l.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),l.o=(a,y)=>Object.prototype.hasOwnProperty.call(a,y),(()=>{var a;l.g.importScripts&&(a=l.g.location+"");var y=l.g.document;if(!a&&y&&(y.currentScript&&(a=y.currentScript.src),!a)){var u=y.getElementsByTagName("script");u.length&&(a=u[u.length-1].src)}if(!a)throw new Error("Automatic publicPath is not supported in this browser");a=a.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),l.p=a})(),(()=>{var a={8758:1},y=t=>{var[S,_,F]=t;for(var I in _)l.o(_,I)&&(l.m[I]=_[I]);for(F&&F(l);S.length;)a[S.pop()]=1;P(t)};l.f.i=(t,S)=>{a[t]||importScripts(l.p+l.u(t))};var u=self.webpackChunk=self.webpackChunk||[],P=u.push.bind(u);u.push=y})(),(()=>{var a=l.x;l.x=()=>Promise.all([7185,144,4942].map(l.e,l)).then(a)})();var ot=l.x()})();

//# sourceMappingURL=8758.2e14f7fce31f486b4eb0.js.map