{"version":3,"file":"9833.ee746c04f402e58e8db3.js","mappings":"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","sources":["webpack:///../../packages/mcap-support/src/parseFlatbufferSchema.ts","webpack:///../../packages/mcap-support/src/parseChannel.ts","webpack:///../../packages/mcap-support/src/parseJsonSchema.ts","webpack:///../../packages/mcap-support/src/protobufDefinitionsToDatatypes.ts"],"sourcesContent":["// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { ByteBuffer } from \"flatbuffers\";\nimport { BaseType, Schema, SchemaT, FieldT, Parser, Table } from \"flatbuffers_reflection\";\n\nimport { MessageDefinitionField } from \"@foxglove/message-definition\";\n\nimport { MessageDefinitionMap } from \"./types\";\n\nfunction typeForSimpleField(type: BaseType): string {\n  switch (type) {\n    case BaseType.Bool:\n      return \"bool\";\n    case BaseType.Byte:\n      return \"int8\";\n    case BaseType.UType:\n    case BaseType.UByte:\n      return \"uint8\";\n    case BaseType.Short:\n      return \"int16\";\n    case BaseType.UShort:\n      return \"uint16\";\n    case BaseType.Int:\n      return \"int32\";\n    case BaseType.UInt:\n      return \"uint32\";\n    case BaseType.Long:\n      return \"int64\";\n    case BaseType.ULong:\n      return \"uint64\";\n    case BaseType.Float:\n      return \"float32\";\n    case BaseType.Double:\n      return \"float64\";\n    case BaseType.String:\n      return \"string\";\n    case BaseType.Vector:\n    case BaseType.Obj:\n    case BaseType.Union:\n    case BaseType.Array:\n      throw new Error(`${type} is not a simple type.`);\n    case BaseType.None:\n    case BaseType.MaxBaseType:\n      throw new Error(\"None is not a valid type.\");\n  }\n}\n\n// eslint-disable-next-line no-restricted-syntax\nfunction flatbufferString(unchecked: string | Uint8Array | null | undefined): string {\n  if (typeof unchecked === \"string\") {\n    return unchecked;\n  }\n  throw new Error(`Expected string, found ${typeof unchecked}`);\n}\n\nfunction typeForField(schema: SchemaT, field: FieldT): MessageDefinitionField[] {\n  const fields: MessageDefinitionField[] = [];\n  switch (field.type?.baseType) {\n    case BaseType.UType:\n    case BaseType.Bool:\n    case BaseType.Byte:\n    case BaseType.UByte:\n    case BaseType.Short:\n    case BaseType.UShort:\n    case BaseType.Int:\n    case BaseType.UInt:\n    case BaseType.Long:\n    case BaseType.ULong:\n    case BaseType.Float:\n    case BaseType.Double:\n    case BaseType.String:\n    case BaseType.None: {\n      const simpleType = typeForSimpleField(field.type.baseType);\n      // Enums have magic logic--the constants definitions for the enum values\n      // have to go right before the enum itself.\n      if (field.type.index !== -1) {\n        const enums = schema.enums[field.type.index]?.values;\n        if (enums == undefined) {\n          throw new Error(\n            `Invalid schema, missing enum values for field type ${\n              schema.enums[field.type.index]?.name\n            }`,\n          );\n        }\n        for (const enumVal of enums) {\n          fields.push({\n            name: flatbufferString(enumVal.name),\n            type: simpleType,\n            isConstant: true,\n            value: enumVal.value,\n          });\n        }\n      }\n      fields.push({ name: flatbufferString(field.name), type: simpleType });\n      break;\n    }\n    case BaseType.Vector:\n      switch (field.type.element) {\n        case BaseType.Vector:\n        case BaseType.Union:\n        case BaseType.Array:\n        case BaseType.None:\n          throw new Error(\"Vectors of vectors, unions, arrays, and None's are unsupported.\");\n        case BaseType.Obj:\n          fields.push({\n            name: flatbufferString(field.name),\n            type: flatbufferString(schema.objects[field.type.index]?.name),\n            isComplex: true,\n            isArray: true,\n          });\n          break;\n        default: {\n          const type = typeForSimpleField(field.type.element);\n          // Enums have magic logic--the constants definitions for the enum\n          // values have to go right before the enum itself.\n          if (field.type.index !== -1) {\n            const enums = schema.enums[field.type.index]?.values;\n            if (enums == undefined) {\n              throw new Error(\"Invalid schema\");\n            }\n            for (const enumVal of enums) {\n              fields.push({\n                name: flatbufferString(enumVal.name),\n                type,\n                isConstant: true,\n                value: enumVal.value,\n              });\n            }\n          }\n          fields.push({ name: flatbufferString(field.name), type, isArray: true });\n          break;\n        }\n      }\n      break;\n    case BaseType.Obj:\n      fields.push({\n        name: flatbufferString(field.name),\n        type: flatbufferString(schema.objects[field.type.index]?.name),\n        isComplex: true,\n      });\n      break;\n    case BaseType.Union:\n    case BaseType.Array:\n    case BaseType.MaxBaseType:\n    case undefined:\n      throw new Error(\"Unions and Arrays are not supported in mcap-support currently.\");\n  }\n  return fields;\n}\n\n// Note: Currently this does not support \"lazy\" message reading in the style of the ros1 message\n// reader, and so will relatively inefficiently deserialize the entire flatbuffer message.\nexport function parseFlatbufferSchema(\n  schemaName: string,\n  schemaArray: Uint8Array,\n): {\n  datatypes: MessageDefinitionMap;\n  deserialize: (buffer: ArrayBufferView) => unknown;\n} {\n  const datatypes: MessageDefinitionMap = new Map();\n  const schemaBuffer = new ByteBuffer(schemaArray);\n  const rawSchema = Schema.getRootAsSchema(schemaBuffer);\n  const schema = rawSchema.unpack();\n\n  let typeIndex = -1;\n  for (let schemaIndex = 0; schemaIndex < schema.objects.length; ++schemaIndex) {\n    const object = schema.objects[schemaIndex];\n    if (object?.name === schemaName) {\n      typeIndex = schemaIndex;\n    }\n    let fields: MessageDefinitionField[] = [];\n    if (object?.fields == undefined) {\n      continue;\n    }\n    for (const field of object.fields) {\n      fields = fields.concat(typeForField(schema, field));\n    }\n    datatypes.set(flatbufferString(object.name), { definitions: fields });\n  }\n  if (typeIndex === -1) {\n    if (schema.rootTable?.name !== schemaName) {\n      throw new Error(\n        `Type \"${schemaName}\" is not available in the schema for \"${schema.rootTable?.name}\".`,\n      );\n    }\n  }\n  const parser = new Parser(rawSchema);\n  const deserialize = (buffer: ArrayBufferView) => {\n    const byteBuffer = new ByteBuffer(\n      new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength),\n    );\n    const table = new Table(\n      byteBuffer,\n      typeIndex,\n      byteBuffer.readInt32(byteBuffer.position()) + byteBuffer.position(),\n    );\n    const obj = parser.toObject(table);\n    return obj;\n  };\n  return { datatypes, deserialize };\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport protobufjs from \"protobufjs\";\nimport { FileDescriptorSet, IFileDescriptorSet } from \"protobufjs/ext/descriptor\";\n\nimport { MessageDefinition } from \"@foxglove/message-definition\";\nimport { parse as parseMessageDefinition, parseRos2idl } from \"@foxglove/rosmsg\";\nimport { MessageReader } from \"@foxglove/rosmsg-serialization\";\nimport { MessageReader as ROS2MessageReader } from \"@foxglove/rosmsg2-serialization\";\n\nimport { parseFlatbufferSchema } from \"./parseFlatbufferSchema\";\nimport { parseJsonSchema } from \"./parseJsonSchema\";\nimport { protobufDefinitionsToDatatypes, stripLeadingDot } from \"./protobufDefinitionsToDatatypes\";\nimport { MessageDefinitionMap } from \"./types\";\n\ntype Channel = {\n  messageEncoding: string;\n  schema: { name: string; encoding: string; data: Uint8Array } | undefined;\n};\n\nexport type ParsedChannel = {\n  deserialize: (data: ArrayBufferView) => unknown;\n  datatypes: MessageDefinitionMap;\n};\n\nfunction parsedDefinitionsToDatatypes(\n  parsedDefinitions: MessageDefinition[],\n  rootName: string,\n): MessageDefinitionMap {\n  const datatypes: MessageDefinitionMap = new Map();\n  parsedDefinitions.forEach(({ name, definitions }, index) => {\n    if (index === 0) {\n      datatypes.set(rootName, { name: rootName, definitions });\n    } else if (name != undefined) {\n      datatypes.set(name, { name, definitions });\n    }\n  });\n  return datatypes;\n}\n\n/**\n * Process a channel/schema and extract information that can be used to deserialize messages on the\n * channel, and schemas in the format expected by Studio's RosDatatypes.\n *\n * See:\n * - https://github.com/foxglove/mcap/blob/main/docs/specification/well-known-message-encodings.md\n * - https://github.com/foxglove/mcap/blob/main/docs/specification/well-known-schema-encodings.md\n */\nexport function parseChannel(channel: Channel): ParsedChannel {\n  if (channel.messageEncoding === \"json\") {\n    if (channel.schema != undefined && channel.schema.encoding !== \"jsonschema\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with schema encoding '${channel.schema.encoding}' is not supported (expected jsonschema or no schema)`,\n      );\n    }\n    const textDecoder = new TextDecoder();\n    let datatypes: MessageDefinitionMap = new Map();\n    let deserialize = (data: ArrayBufferView) => JSON.parse(textDecoder.decode(data));\n    if (channel.schema != undefined) {\n      const schema =\n        channel.schema.data.length > 0\n          ? JSON.parse(textDecoder.decode(channel.schema.data))\n          : undefined;\n      if (schema != undefined) {\n        if (typeof schema !== \"object\") {\n          throw new Error(`Invalid schema, expected JSON object, got ${typeof schema}`);\n        }\n        const { datatypes: parsedDatatypes, postprocessValue } = parseJsonSchema(\n          schema as Record<string, unknown>,\n          channel.schema.name,\n        );\n        datatypes = parsedDatatypes;\n        deserialize = (data) =>\n          postprocessValue(JSON.parse(textDecoder.decode(data)) as Record<string, unknown>);\n      }\n    }\n    return { deserialize, datatypes };\n  }\n\n  if (channel.messageEncoding === \"flatbuffer\") {\n    if (channel.schema?.encoding !== \"flatbuffer\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with ${\n          channel.schema == undefined\n            ? \"no encoding\"\n            : `schema encoding '${channel.schema.encoding}'`\n        } is not supported (expected flatbuffer)`,\n      );\n    }\n    return parseFlatbufferSchema(channel.schema.name, channel.schema.data);\n  }\n\n  if (channel.messageEncoding === \"protobuf\") {\n    if (channel.schema?.encoding !== \"protobuf\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with ${\n          channel.schema == undefined\n            ? \"no encoding\"\n            : `schema encoding '${channel.schema.encoding}'`\n        } is not supported (expected protobuf)`,\n      );\n    }\n    const descriptorSet = FileDescriptorSet.decode(channel.schema.data);\n\n    // Modify the definition of google.protobuf.Timestamp so it gets parsed as {sec, nsec},\n    // compatible with the rest of Studio.\n    for (const file of (descriptorSet as unknown as IFileDescriptorSet).file) {\n      if (file.package === \"google.protobuf\") {\n        for (const message of file.messageType ?? []) {\n          if (message.name === \"Timestamp\" || message.name === \"Duration\") {\n            for (const field of message.field ?? []) {\n              if (field.name === \"seconds\") {\n                field.name = \"sec\";\n              } else if (field.name === \"nanos\") {\n                field.name = \"nsec\";\n              }\n            }\n          }\n        }\n      }\n    }\n\n    const root = protobufjs.Root.fromDescriptor(descriptorSet);\n    root.resolveAll();\n    const type = root.lookupType(channel.schema.name);\n\n    const deserialize = (data: ArrayBufferView) => {\n      return type.toObject(\n        type.decode(new Uint8Array(data.buffer, data.byteOffset, data.byteLength)),\n        { defaults: true },\n      );\n    };\n\n    const datatypes: MessageDefinitionMap = new Map();\n    protobufDefinitionsToDatatypes(datatypes, type);\n\n    if (!datatypes.has(channel.schema.name)) {\n      throw new Error(\n        `Protobuf schema does not contain an entry for '${\n          channel.schema.name\n        }'. The schema name should be fully-qualified, e.g. '${stripLeadingDot(type.fullName)}'.`,\n      );\n    }\n\n    return { deserialize, datatypes };\n  }\n\n  if (channel.messageEncoding === \"ros1\") {\n    if (channel.schema?.encoding !== \"ros1msg\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with ${\n          channel.schema == undefined\n            ? \"no encoding\"\n            : `schema encoding '${channel.schema.encoding}'`\n        } is not supported (expected ros1msg)`,\n      );\n    }\n    const schema = new TextDecoder().decode(channel.schema.data);\n    const parsedDefinitions = parseMessageDefinition(schema);\n    const reader = new MessageReader(parsedDefinitions);\n    return {\n      datatypes: parsedDefinitionsToDatatypes(parsedDefinitions, channel.schema.name),\n      deserialize: (data) => reader.readMessage(data),\n    };\n  }\n\n  if (channel.messageEncoding === \"cdr\") {\n    if (channel.schema?.encoding !== \"ros2msg\" && channel.schema?.encoding !== \"ros2idl\") {\n      throw new Error(\n        `Message encoding ${channel.messageEncoding} with ${\n          channel.schema == undefined\n            ? \"no encoding\"\n            : `schema encoding '${channel.schema.encoding}'`\n        } is not supported (expected \"ros2msg\" or \"ros2idl\")`,\n      );\n    }\n    const schema = new TextDecoder().decode(channel.schema.data);\n    const isIdl = channel.schema.encoding === \"ros2idl\";\n\n    const parsedDefinitions = isIdl\n      ? parseRos2idl(schema)\n      : parseMessageDefinition(schema, { ros2: true });\n\n    const reader = new ROS2MessageReader(parsedDefinitions);\n    return {\n      datatypes: parsedDefinitionsToDatatypes(parsedDefinitions, channel.schema.name),\n      deserialize: (data) => reader.readMessage(data),\n    };\n  }\n\n  throw new Error(`Unsupported encoding ${channel.messageEncoding}`);\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport * as base64 from \"@protobufjs/base64\";\n\nimport { MessageDefinitionField } from \"@foxglove/message-definition\";\n\nimport { MessageDefinitionMap } from \"./types\";\n\nexport function parseJsonSchema(\n  rootJsonSchema: Record<string, unknown>,\n  rootTypeName: string,\n): {\n  datatypes: MessageDefinitionMap;\n\n  /**\n   * A function that should be called after parsing a value from a JSON string to do any necessary\n   * post-processing (e.g. base64 decoding)\n   */\n  postprocessValue: (value: Record<string, unknown>) => unknown;\n} {\n  const datatypes: MessageDefinitionMap = new Map();\n\n  function addFieldsRecursive(\n    schema: Record<string, unknown>,\n    typeName: string,\n    keyPath: string[],\n  ): (value: Record<string, unknown>) => unknown {\n    let postprocessObject: (value: Record<string, unknown>) => unknown = (value) => value;\n    const fields: MessageDefinitionField[] = [];\n    if (schema.type !== \"object\") {\n      throw new Error(\n        `Expected \"type\": \"object\" for schema ${typeName}, got ${JSON.stringify(schema.type)}`,\n      );\n    }\n    for (const [fieldName, fieldSchema] of Object.entries(\n      schema.properties as Record<string, Record<string, unknown>>,\n    )) {\n      if (Array.isArray(fieldSchema.oneOf)) {\n        if (fieldSchema.oneOf.every((alternative) => typeof alternative.const === \"number\")) {\n          for (const alternative of fieldSchema.oneOf) {\n            fields.push({\n              name: alternative.title,\n              type: \"uint32\",\n              isConstant: true,\n              value: alternative.const,\n            });\n          }\n          fields.push({ name: fieldName, type: \"uint32\" });\n          continue;\n        } else {\n          throw new Error(\n            `Unsupported type for ${keyPath\n              .concat(fieldName)\n              .join(\".\")}: oneOf alternatives must have number values`,\n          );\n        }\n      }\n      switch (fieldSchema.type) {\n        case \"boolean\":\n          fields.push({ name: fieldName, type: \"bool\" });\n          break;\n        case \"string\":\n          switch (fieldSchema.contentEncoding) {\n            case undefined:\n              fields.push({ name: fieldName, type: \"string\" });\n              break;\n            case \"base64\": {\n              fields.push({ name: fieldName, type: \"uint8\", isArray: true });\n              const prevPostprocess = postprocessObject;\n              postprocessObject = (value) => {\n                const str = value[fieldName];\n                if (typeof str === \"string\") {\n                  const decoded = new Uint8Array(base64.length(str));\n                  if (base64.decode(str, decoded, 0) !== decoded.byteLength) {\n                    throw new Error(\n                      `Failed to decode base64 data for ${keyPath.concat(fieldName).join(\".\")}`,\n                    );\n                  }\n                  value[fieldName] = decoded;\n                }\n                return prevPostprocess(value);\n              };\n              break;\n            }\n            default:\n              throw new Error(\n                `Unsupported contentEncoding ${JSON.stringify(\n                  fieldSchema.contentEncoding,\n                )} in ${keyPath.concat(fieldName).join(\".\")}`,\n              );\n          }\n          break;\n        case \"number\":\n        case \"integer\":\n          fields.push({ name: fieldName, type: \"float64\" });\n          break;\n        case \"object\": {\n          const nestedTypeName = `${typeName}.${fieldName}`;\n          const postprocessNestedObject = addFieldsRecursive(\n            fieldSchema,\n            nestedTypeName,\n            keyPath.concat(fieldName),\n          );\n          const prevPostprocess = postprocessObject;\n          postprocessObject = (value) => {\n            const fieldValue = value[fieldName];\n            if (fieldValue != undefined && typeof fieldValue === \"object\") {\n              value[fieldName] = postprocessNestedObject(fieldValue as Record<string, unknown>);\n            }\n            return prevPostprocess(value);\n          };\n          fields.push({ name: fieldName, type: nestedTypeName, isComplex: true });\n          break;\n        }\n        case \"array\": {\n          const itemSchema = fieldSchema.items as Record<string, unknown>;\n          switch (itemSchema.type) {\n            case \"boolean\":\n              fields.push({ name: fieldName, type: \"bool\", isArray: true });\n              break;\n            case \"string\":\n              if (itemSchema.contentEncoding != undefined) {\n                throw new Error(\n                  `Unsupported contentEncoding ${JSON.stringify(\n                    itemSchema.contentEncoding,\n                  )} for array item ${keyPath.concat(fieldName).join(\".\")}`,\n                );\n              }\n              fields.push({ name: fieldName, type: \"string\", isArray: true });\n              break;\n            case \"number\":\n            case \"integer\":\n              fields.push({ name: fieldName, type: \"float64\", isArray: true });\n              break;\n            case \"object\": {\n              const nestedTypeName = `${typeName}.${fieldName}`;\n              const postprocessArrayItem = addFieldsRecursive(\n                fieldSchema.items as Record<string, unknown>,\n                nestedTypeName,\n                keyPath.concat(fieldName),\n              );\n              const prevPostprocess = postprocessObject;\n              postprocessObject = (value) => {\n                const arr = value[fieldName];\n                if (Array.isArray(arr)) {\n                  value[fieldName] = arr.map(postprocessArrayItem);\n                }\n                return prevPostprocess(value);\n              };\n              fields.push({\n                name: fieldName,\n                type: nestedTypeName,\n                isComplex: true,\n                isArray: true,\n              });\n              break;\n            }\n            default:\n              throw new Error(\n                `Unsupported type ${JSON.stringify(itemSchema.type)} for array item ${keyPath\n                  .concat(fieldName)\n                  .join(\".\")}`,\n              );\n          }\n          break;\n        }\n        case \"null\":\n        default:\n          throw new Error(\n            `Unsupported type ${JSON.stringify(fieldSchema.type)} for ${keyPath\n              .concat(fieldName)\n              .join(\".\")}`,\n          );\n      }\n    }\n    datatypes.set(typeName, { definitions: fields });\n    return postprocessObject;\n  }\n\n  const postprocessValue = addFieldsRecursive(rootJsonSchema, rootTypeName, []);\n  return { datatypes, postprocessValue };\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\nimport protobufjs from \"protobufjs\";\n\nimport { MessageDefinitionField } from \"@foxglove/message-definition\";\n\nimport { MessageDefinitionMap } from \"./types\";\n\nfunction protobufScalarToRosPrimitive(type: string): string {\n  switch (type) {\n    case \"double\":\n      return \"float64\";\n    case \"float\":\n      return \"float32\";\n    case \"int32\":\n    case \"sint32\":\n    case \"sfixed32\":\n      return \"int32\";\n    case \"uint32\":\n    case \"fixed32\":\n      return \"uint32\";\n    case \"int64\":\n    case \"sint64\":\n    case \"sfixed64\":\n      return \"int64\";\n    case \"uint64\":\n    case \"fixed64\":\n      return \"uint64\";\n    case \"bool\":\n      return \"bool\";\n    case \"string\":\n      return \"string\";\n  }\n  throw new Error(`Expected protobuf scalar type, got ${type}`);\n}\n\nexport function stripLeadingDot(typeName: string): string {\n  return typeName.replace(/^\\./, \"\");\n}\n\nexport function protobufDefinitionsToDatatypes(\n  datatypes: MessageDefinitionMap,\n  type: protobufjs.Type,\n): void {\n  const definitions: MessageDefinitionField[] = [];\n  // The empty list reference is added to the map so a `.has` lookup below can prevent infinite recursion on cyclical types\n  datatypes.set(stripLeadingDot(type.fullName), { definitions });\n  for (const field of type.fieldsArray) {\n    if (field.resolvedType instanceof protobufjs.Enum) {\n      for (const [name, value] of Object.entries(field.resolvedType.values)) {\n        // Note: names from different enums might conflict. The player API will need to be updated\n        // to associate fields with enums (similar to the __foxglove_enum annotation hack).\n        // https://github.com/foxglove/studio/issues/2214\n        definitions.push({ name, type: \"int32\", isConstant: true, value });\n      }\n      definitions.push({ type: \"int32\", name: field.name });\n    } else if (field.resolvedType) {\n      const fullName = stripLeadingDot(field.resolvedType.fullName);\n      definitions.push({\n        type: fullName,\n        name: field.name,\n        isComplex: true,\n        isArray: field.repeated,\n      });\n\n      // If we've already processed this datatype we should skip it.\n      // This avoid infinite recursion with datatypes that reference themselves.\n      if (!datatypes.has(fullName)) {\n        protobufDefinitionsToDatatypes(datatypes, field.resolvedType);\n      }\n    } else if (field.type === \"bytes\") {\n      if (field.repeated) {\n        throw new Error(\"Repeated bytes are not currently supported\");\n      }\n      definitions.push({ type: \"uint8\", name: field.name, isArray: true });\n    } else {\n      definitions.push({\n        type: protobufScalarToRosPrimitive(field.type),\n        name: field.name,\n        isArray: field.repeated,\n      });\n    }\n  }\n}\n"],"names":["typeForSimpleField","type","flatbufferString","unchecked","typeForField","schema","field","fields","simpleType","enums","enumVal","parseFlatbufferSchema","schemaName","schemaArray","datatypes","schemaBuffer","rawSchema","typeIndex","schemaIndex","object","parser","buffer","byteBuffer","table","parsedDefinitionsToDatatypes","parsedDefinitions","rootName","name","definitions","index","parseChannel","channel","textDecoder","deserialize","data","parsedDatatypes","postprocessValue","parseJsonSchema","descriptorSet","file","message","root","protobufDefinitionsToDatatypes","reader","rootJsonSchema","rootTypeName","addFieldsRecursive","typeName","keyPath","postprocessObject","value","fieldName","fieldSchema","alternative","prevPostprocess","str","decoded","nestedTypeName","postprocessNestedObject","fieldValue","itemSchema","postprocessArrayItem","arr","protobufScalarToRosPrimitive","stripLeadingDot","fullName"],"sourceRoot":""}