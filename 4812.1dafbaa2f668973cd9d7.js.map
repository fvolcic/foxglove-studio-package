{"version":3,"file":"4812.1dafbaa2f668973cd9d7.js","mappings":"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","sources":["webpack:///../../packages/comlink-transfer-handlers/src/abortSignalTransferHandler.ts","webpack:///../../packages/log/src/index.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/IteratorCursor.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/WorkerIterableSourceWorker.ts","webpack:///../../packages/studio-base/src/util/FetchReader.ts","webpack:///../../packages/studio-base/src/util/isDesktopApp.ts","webpack:///../../packages/studio-base/src/util/BrowserHttpReader.ts","webpack:///../../packages/studio-base/src/util/ranges.ts","webpack:///../../packages/studio-base/src/util/VirtualLRUBuffer.ts","webpack:///../../packages/studio-base/src/util/getNewConnection.ts","webpack:///../../packages/studio-base/src/util/CachedFilelike.ts"],"sourcesContent":["// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { TransferHandler } from \"comlink\";\n\nconst isAbortSignal = (val: unknown): val is AbortSignal => val instanceof AbortSignal;\n\n/**\n * abortSignalTransferHandler implements a Comlink TransferHandler for AbortSignal instances\n *\n * Serialize creates an array with a boolean for whether the signal is already aborted and a message\n * port to send an abort signal.\n *\n * Deserialize creates a new abort controller and aborts it when the abort message is sent over the\n * message port.\n *\n * Reference: https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\n */\nconst abortSignalTransferHandler: TransferHandler<AbortSignal, [boolean, MessagePort]> = {\n  canHandle: isAbortSignal,\n  deserialize: ([aborted, msgPort]) => {\n    const controller = new AbortController();\n\n    if (aborted) {\n      controller.abort();\n    } else {\n      msgPort.onmessage = () => {\n        controller.abort();\n      };\n    }\n\n    return controller.signal;\n  },\n  serialize: (abortSignal) => {\n    const { port1, port2 } = new MessageChannel();\n    abortSignal.addEventListener(\"abort\", () => {\n      port1.postMessage(\"aborted\");\n    });\n\n    return [[abortSignal.aborted, port2], [port2]];\n  },\n};\n\nexport { abortSignalTransferHandler };\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\n// logger channel -> logger\nconst channels = new Map<string, Logger>();\n\nconst noop = () => {};\n\ntype LogLevel = \"error\" | \"warn\" | \"info\" | \"debug\";\n\nclass Logger {\n  // default logger has an empty name\n  public static default = new Logger(\"\");\n\n  private _name: string;\n\n  // all new loggers are created from the default logger\n  private constructor(name: string) {\n    this._name = name;\n    this.setLevel(\"debug\");\n    channels.set(name, this);\n  }\n\n  // fully qualified name for the logger\n  public name(): string {\n    return this._name;\n  }\n\n  /**\n   * Return true if the level would display when logged by the logger\n   */\n  public isLevelOn(level: LogLevel): boolean {\n    switch (level) {\n      case \"debug\":\n        return this.debug !== noop;\n      case \"info\":\n        return this.info !== noop;\n      case \"warn\":\n        return this.warn !== noop;\n      case \"error\":\n        return this.error !== noop;\n    }\n    return false;\n  }\n\n  /**\n   *\n   * @returns the current log level\n   */\n  public getLevel(): LogLevel {\n    if (this.debug !== noop) {\n      return \"debug\";\n    } else if (this.info !== noop) {\n      return \"info\";\n    } else if (this.warn !== noop) {\n      return \"warn\";\n    } else {\n      return \"error\";\n    }\n  }\n\n  /**\n   * Set the allowed log level. Any log calls with severity \"below\" this one will be ignored.\n   *\n   * i.e. setting a level of \"warn\" will ignore any \"info\" or \"debug\" logs\n   */\n  public setLevel(level: LogLevel): void {\n    this.debug = noop;\n    this.info = noop;\n    this.warn = noop;\n    this.error = noop;\n\n    switch (level) {\n      case \"debug\":\n        this.debug = console.debug.bind(global.console);\n        this.info = console.info.bind(global.console);\n        this.warn = console.warn.bind(global.console);\n        this.error = console.error.bind(global.console);\n        break;\n      case \"info\":\n        this.info = console.info.bind(global.console);\n        this.warn = console.warn.bind(global.console);\n        this.error = console.error.bind(global.console);\n        break;\n      case \"warn\":\n        this.warn = console.warn.bind(global.console);\n        this.error = console.error.bind(global.console);\n        break;\n      case \"error\":\n        this.error = console.error.bind(global.console);\n        break;\n    }\n  }\n\n  public debug(..._args: unknown[]): void {}\n  public info(..._args: unknown[]): void {}\n  public warn(..._args: unknown[]): void {}\n  public error(..._args: unknown[]): void {}\n\n  // create a new logger under this logger's namespace\n  public getLogger(name: string): Logger {\n    const shortName = name.replace(/^.+\\.(asar|webpack)[\\\\/\\\\]/, \"\").replace(/^(\\.\\.\\/)+/, \"\");\n    const channelName = this._name.length > 0 ? `${this._name}.${shortName}` : shortName;\n    const existing = channels.get(channelName);\n    if (existing) {\n      return existing;\n    }\n\n    const logger = new Logger(channelName);\n    channels.set(channelName, logger);\n    return logger;\n  }\n\n  // get all logging channels\n  public channels(): Logger[] {\n    return Array.from(channels.values());\n  }\n}\n\nfunction toLogLevel(maybeLevel: string): LogLevel {\n  switch (maybeLevel) {\n    case \"debug\":\n      return \"debug\";\n    case \"info\":\n      return \"info\";\n    case \"warn\":\n      return \"warn\";\n    case \"error\":\n      return \"error\";\n    default:\n      return \"warn\";\n  }\n}\n\nexport default Logger.default;\nexport { Logger, toLogLevel };\nexport type { LogLevel };\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { compare, add as addTime } from \"@foxglove/rostime\";\nimport { Time } from \"@foxglove/studio\";\n\nimport type { IMessageCursor, IteratorResult } from \"./IIterableSource\";\n\nconst TIME_ZERO = Object.freeze({ sec: 0, nsec: 0 });\n\n/// IteratorCursor implements a IMessageCursor interface on top of an AsyncIterable\nclass IteratorCursor implements IMessageCursor {\n  private _iter: AsyncIterableIterator<Readonly<IteratorResult>>;\n  // readUntil reads from the iterator inclusive of end time. To do this, it reads from the iterator\n  // until it receives a receiveTime after end time to signal it has received all the messages\n  // inclusive of end time. Since iterators are read once, this last result must be stored for the\n  // next readUntil call otherwise it would be lost.\n  private _lastIteratorResult?: IteratorResult;\n  private _abort?: AbortSignal;\n\n  public constructor(\n    iterator: AsyncIterableIterator<Readonly<IteratorResult>>,\n    abort?: AbortSignal,\n  ) {\n    this._iter = iterator;\n    this._abort = abort;\n  }\n\n  public async next(): ReturnType<IMessageCursor[\"next\"]> {\n    if (this._abort?.aborted === true) {\n      return undefined;\n    }\n\n    const result = await this._iter.next();\n    return result.value;\n  }\n\n  public async nextBatch(durationMs: number): Promise<IteratorResult[] | undefined> {\n    const firstResult = await this.next();\n    if (!firstResult) {\n      return undefined;\n    }\n\n    if (firstResult.type === \"problem\") {\n      return [firstResult];\n    }\n\n    const results: IteratorResult[] = [firstResult];\n\n    let cutoffTime: Time = TIME_ZERO;\n    switch (firstResult.type) {\n      case \"stamp\":\n        cutoffTime = addTime(firstResult.stamp, { sec: 0, nsec: durationMs * 1e6 });\n        break;\n      case \"message-event\":\n        cutoffTime = addTime(firstResult.msgEvent.receiveTime, { sec: 0, nsec: durationMs * 1e6 });\n        break;\n    }\n\n    for (;;) {\n      const result = await this.next();\n      if (!result) {\n        return results;\n      }\n\n      results.push(result);\n\n      if (result.type === \"problem\") {\n        break;\n      }\n      if (result.type === \"stamp\" && compare(result.stamp, cutoffTime) > 0) {\n        break;\n      }\n      if (result.type === \"message-event\" && compare(result.msgEvent.receiveTime, cutoffTime) > 0) {\n        break;\n      }\n    }\n    return results;\n  }\n\n  public async readUntil(end: Time): ReturnType<IMessageCursor[\"readUntil\"]> {\n    // Assign to a variable to fool typescript control flow analysis which does not understand\n    // that this value could change after the _await_\n    const isAborted = this._abort?.aborted;\n    if (isAborted === true) {\n      return undefined;\n    }\n\n    const results: IteratorResult[] = [];\n\n    // if the last result is still past end time, return empty results\n    if (\n      this._lastIteratorResult?.type === \"stamp\" &&\n      compare(this._lastIteratorResult.stamp, end) >= 0\n    ) {\n      return results;\n    }\n\n    if (\n      this._lastIteratorResult?.type === \"message-event\" &&\n      compare(this._lastIteratorResult.msgEvent.receiveTime, end) > 0\n    ) {\n      return results;\n    }\n\n    if (this._lastIteratorResult) {\n      results.push(this._lastIteratorResult);\n      this._lastIteratorResult = undefined;\n    }\n\n    for (;;) {\n      const result = await this._iter.next();\n      if (this._abort?.aborted === true) {\n        return undefined;\n      }\n\n      if (result.done === true) {\n        break;\n      }\n\n      const value = result.value;\n      if (value.type === \"stamp\" && compare(value.stamp, end) >= 0) {\n        this._lastIteratorResult = value;\n        break;\n      }\n      if (value.type === \"message-event\" && compare(value.msgEvent.receiveTime, end) > 0) {\n        this._lastIteratorResult = value;\n        break;\n      }\n      results.push(value);\n    }\n\n    return results;\n  }\n\n  public async end(): ReturnType<IMessageCursor[\"end\"]> {\n    await this._iter.return?.();\n  }\n}\n\nexport { IteratorCursor };\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport * as Comlink from \"comlink\";\n\nimport { abortSignalTransferHandler } from \"@foxglove/comlink-transfer-handlers\";\nimport { MessageEvent } from \"@foxglove/studio\";\n\nimport type {\n  GetBackfillMessagesArgs,\n  IIterableSource,\n  IMessageCursor,\n  Initalization,\n  IteratorResult,\n  MessageIteratorArgs,\n} from \"./IIterableSource\";\nimport { IteratorCursor } from \"./IteratorCursor\";\n\nexport class WorkerIterableSourceWorker implements IIterableSource {\n  protected _source: IIterableSource;\n\n  public constructor(source: IIterableSource) {\n    this._source = source;\n  }\n\n  public async initialize(): Promise<Initalization> {\n    return await this._source.initialize();\n  }\n\n  public messageIterator(\n    args: MessageIteratorArgs,\n  ): AsyncIterableIterator<Readonly<IteratorResult>> & Comlink.ProxyMarked {\n    return Comlink.proxy(this._source.messageIterator(args));\n  }\n\n  public async getBackfillMessages(\n    args: Omit<GetBackfillMessagesArgs, \"abortSignal\">,\n    // abortSignal is a separate argument so it can be proxied by comlink since AbortSignal is not\n    // clonable (and needs to signal across the worker boundary)\n    abortSignal?: AbortSignal,\n  ): Promise<MessageEvent<unknown>[]> {\n    return await this._source.getBackfillMessages({\n      ...args,\n      abortSignal,\n    });\n  }\n\n  public getMessageCursor(\n    args: Omit<MessageIteratorArgs, \"abort\">,\n    abort?: AbortSignal,\n  ): IMessageCursor & Comlink.ProxyMarked {\n    const iter = this._source.messageIterator(args);\n    const cursor = new IteratorCursor(iter, abort);\n    return Comlink.proxy(cursor);\n  }\n}\n\nComlink.transferHandlers.set(\"abortsignal\", abortSignalTransferHandler);\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\nimport { EventEmitter } from \"eventemitter3\";\n\ntype EventTypes = {\n  data: (chunk: Uint8Array) => void;\n  end: () => void;\n  error: (err: Error) => void;\n};\n\n// An event-emitting wrapper for the Streams API:\n// https://developer.mozilla.org/en-US/docs/Web/API/Streams_API\nexport default class FetchReader extends EventEmitter<EventTypes> {\n  private _response: Promise<Response>;\n  private _reader?: ReadableStreamDefaultReader<Uint8Array>;\n  private _controller: AbortController;\n  private _aborted: boolean = false;\n  private _url: string;\n\n  public constructor(url: string, options?: RequestInit) {\n    super();\n    this._url = url;\n    this._controller = new AbortController();\n    this._response = fetch(url, { ...options, signal: this._controller.signal });\n  }\n\n  // you can only call getReader once on a response body\n  // so keep a local copy of the reader and return it after the first call to get a reader\n  private async _getReader(): Promise<ReadableStreamDefaultReader<Uint8Array> | undefined> {\n    if (this._reader) {\n      return this._reader;\n    }\n    let data: Response;\n    try {\n      data = await this._response;\n    } catch (err) {\n      this.emit(\"error\", new Error(`GET <${this._url}> failed: ${err}`));\n      return undefined;\n    }\n    if (!data.ok) {\n      const errMsg = data.statusText;\n      this.emit(\n        \"error\",\n        new Error(\n          `GET <$${this._url}> failed with status ${data.status}${errMsg ? ` (${errMsg})` : ``}`,\n        ),\n      );\n      return undefined;\n    }\n\n    if (!data.body) {\n      this.emit(\"error\", new Error(`GET <${this._url}> succeeded, but returned no data`));\n      return undefined;\n    }\n\n    // The fetch succeeded, but there might still be an error streaming.\n    try {\n      // When a stream is closed or errors, any reader it is locked to is released.\n      // If the getReader method is called on an already locked stream, an exception will be thrown.\n      // This is caused by server-side errors, but we should catch it anyway.\n      this._reader = data.body.getReader();\n    } catch (err) {\n      this.emit(\"error\", new Error(`GET <${this._url}> succeeded, but failed to stream`));\n      return undefined;\n    }\n\n    return this._reader;\n  }\n\n  public read(): void {\n    this._getReader()\n      .then((reader) => {\n        // if no reader is returned then we've encountered an error\n        if (!reader) {\n          return;\n        }\n        reader\n          .read()\n          .then(({ done, value }) => {\n            // no more to read, signal stream is finished\n            if (done) {\n              this.emit(\"end\");\n              return;\n            }\n            this.emit(\"data\", value);\n            this.read();\n          })\n          .catch((unk) => {\n            // canceling the xhr request causes the promise to reject\n            if (this._aborted) {\n              this.emit(\"end\");\n              return;\n            }\n            const err = unk instanceof Error ? unk : new Error(unk as string);\n            this.emit(\"error\", err);\n          });\n      })\n      .catch((unk) => {\n        const err = unk instanceof Error ? unk : new Error(unk as string);\n        this.emit(\"error\", err);\n      });\n  }\n\n  public destroy(): void {\n    this._aborted = true;\n    this._controller.abort();\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nexport default function isDesktopApp(): boolean {\n  return Boolean((global as unknown as { desktopBridge: unknown }).desktopBridge);\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\n\nimport { FileReader, FileStream } from \"@foxglove/studio-base/util/CachedFilelike\";\nimport FetchReader from \"@foxglove/studio-base/util/FetchReader\";\nimport isDesktopApp from \"@foxglove/studio-base/util/isDesktopApp\";\n\n// A file reader that reads from a remote HTTP URL, for usage in the browser (not for node.js).\nexport default class BrowserHttpReader implements FileReader {\n  private _url: string;\n\n  public constructor(url: string) {\n    this._url = url;\n  }\n\n  public async open(): Promise<{ size: number; identifier?: string }> {\n    let response: Response;\n    try {\n      // Make a GET request and then immediately cancel it. This is more robust than a HEAD request,\n      // since the server might not accept HEAD requests (e.g. when using S3 presigned URLs that\n      // only work for one particular method like GET).\n      // Note that we cannot use `range: \"bytes=0-1\"` or so, because then we can't get the actual\n      // file size without making Content-Range a CORS header, therefore making all this a bit less\n      // robust.\n      // \"no-store\" forces an unconditional remote request. When the browser's cache is populated,\n      // it may add a `range` header to the request, which causes some servers to omit the\n      // `accept-ranges` header in the response.\n      const controller = new AbortController();\n      response = await fetch(this._url, { signal: controller.signal, cache: \"no-store\" });\n      controller.abort();\n    } catch (error) {\n      let errMsg = `Fetching remote file failed. ${error}`;\n\n      if (!isDesktopApp()) {\n        errMsg +=\n          \"\\n\\nSometimes this is due to a CORS configuration error on the server. Make sure CORS is enabled.\";\n      }\n\n      throw new Error(errMsg);\n    }\n    if (!response.ok) {\n      throw new Error(\n        `Fetching remote file failed. <${this._url}> Status code: ${response.status}.`,\n      );\n    }\n    if (response.headers.get(\"accept-ranges\") !== \"bytes\") {\n      let errMsg =\n        \"Support for HTTP Range requests was not detected on the remote file.\\n\\nConfirm the resource has an 'Accept-Ranges: bytes' header.\";\n\n      if (!isDesktopApp()) {\n        errMsg +=\n          \"\\n\\nSometimes this is due to a CORS configuration error on the server. Make sure CORS is enabled with Access-Control-Allow-Origin, and that Access-Control-Expose-Headers includes Accept-Ranges.\";\n      }\n\n      throw new Error(errMsg);\n    }\n    const size = response.headers.get(\"content-length\");\n    if (size == undefined) {\n      throw new Error(`Remote file is missing file size. <${this._url}>`);\n    }\n    return {\n      size: parseInt(size),\n      identifier:\n        response.headers.get(\"etag\") ?? response.headers.get(\"last-modified\") ?? undefined,\n    };\n  }\n\n  public fetch(offset: number, length: number): FileStream {\n    const headers = new Headers({ range: `bytes=${offset}-${offset + (length - 1)}` });\n    const reader = new FetchReader(this._url, { headers });\n    reader.read();\n    return reader;\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\nimport { complement, intersect, isBefore, isDuring } from \"intervals-fn\";\n\nexport type Range = {\n  /** inclusive */\n  start: number;\n  /** exclusive */\n  end: number;\n};\n\nexport function isRangeCoveredByRanges(\n  queryRange: Range,\n  nonOverlappingMergedAndSortedRanges: Range[],\n): boolean {\n  for (const range of nonOverlappingMergedAndSortedRanges) {\n    if (isBefore(queryRange, range)) {\n      return false;\n    }\n    if (isDuring(queryRange, range)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Get the ranges in `bounds` that are NOT covered by `ranges`.\nexport function missingRanges(bounds: Range, ranges: readonly Range[]): Range[] {\n  // `complement` works in unexpected ways when `ranges` has a range that exceeds `bounds`,\n  // so we first clip `ranges` to `bounds`.\n  return complement(bounds, intersect([bounds], ranges));\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\n\nimport { simplify, substract, unify } from \"intervals-fn\";\n\nimport { isRangeCoveredByRanges, Range } from \"./ranges\";\n\n// VirtualLRUBuffer works similarly to a regular Node.js `Buffer`, but it has some additional features:\n// 1. It can span buffers larger than `buffer.kMaxLength` (typically 2GiB).\n// 2. It can take up much less memory when needed by evicting its least recently used ranges from\n//    memory.\n//\n// This works by allocating multiple smaller buffers underneath, which we call \"blocks\". There are\n// two main operations:\n// - `VirtualLRUBuffer#slice`: works just like `Buffer#slice`, but stitches data together from the\n//    underlying blocks. It throws an error when the underlying data is not currently set, so be\n//    sure to check that first using `VirtualLRUBuffer#hasData`, because the underlying block might\n//    have been evicted.\n// - `VirtualLRUBuffer#copyFrom`: similar to `Buffer#copy`. Will set `VirtualLRUBuffer#hasData` to true\n//    for the range that you copied in, until the data gets evicted through subsequent\n//    `VirtualLRUBuffer#copyFrom` calls.\n//\n// As said above, you can use `VirtualLRUBuffer#hasData` to see if a range can be sliced out. You can\n// also use `VirtualLRUBuffer#getRangesWithData` to get the full list of ranges for which data is set,\n// as an array of `Range` objects with `start` (inclusive) and `end` (exclusive) numbers.\n//\n// Create a new instance by calling `new VirtualLRUBuffer({ size })`. By default this will not do any\n// eviction, and so it will take up `size` bytes of memory.\n//\n// To limit the memory usage, you can pass in a additional options to the constructor: `blockSize`\n// (in bytes) and `numberOfBlocks`. The least recently used block will get evicted when writing to\n// an unallocated block using `VirtualLRUBuffer.copyFrom`.\n\nconst kMaxLength = Math.pow(2, 32);\n\nexport default class VirtualLRUBuffer {\n  public readonly byteLength: number; // How many bytes does this buffer represent.\n  private _blocks: Uint8Array[] = []; // Actual `Buffer` for each block.\n  // How many bytes is each block. This used to work up to 2GiB minus a byte, and now seems to crash\n  // past 2GiB minus 4KiB. Default to 1GiB so we don't get caught out next time the limit drops.\n  private _blockSize: number = Math.trunc(kMaxLength / 2);\n  private _numberOfBlocks: number = Infinity; // How many blocks are we allowed to have at any time.\n  private _lastAccessedBlockIndices: number[] = []; // Indexes of blocks, from least to most recently accessed.\n  private _rangesWithData: Range[] = []; // Ranges for which we have data copied in (and have not been evicted).\n\n  public constructor(options: { size: number; blockSize?: number; numberOfBlocks?: number }) {\n    this.byteLength = options.size;\n    this._blockSize = options.blockSize ?? this._blockSize;\n    this._numberOfBlocks = options.numberOfBlocks ?? this._numberOfBlocks;\n  }\n\n  // Check if the range between `start` (inclusive) and `end` (exclusive) fully contains data\n  // copied in through `VirtualLRUBuffer#copyFrom`.\n  public hasData(start: number, end: number): boolean {\n    return isRangeCoveredByRanges({ start, end }, this._rangesWithData);\n  }\n\n  // Get the minimal number of start-end pairs for which `VirtualLRUBuffer#hasData` will return true.\n  // The array is sorted by `start`.\n  public getRangesWithData(): Range[] {\n    return this._rangesWithData;\n  }\n\n  // Copy data from the `source` buffer to the byte at `targetStart` in the VirtualLRUBuffer.\n  public copyFrom(source: Uint8Array, targetStart: number): void {\n    if (targetStart < 0 || targetStart >= this.byteLength) {\n      throw new Error(\"VirtualLRUBuffer#copyFrom invalid input\");\n    }\n\n    const range = { start: targetStart, end: targetStart + source.byteLength };\n\n    // Walk through the blocks and copy the data over. If the input buffer is too large we will\n    // currently just evict the earliest copied in data.\n    let position = range.start;\n    while (position < range.end) {\n      const { blockIndex, positionInBlock, remainingBytesInBlock } =\n        this._calculatePosition(position);\n      copy(source, this._getBlock(blockIndex), positionInBlock, position - targetStart);\n      position += remainingBytesInBlock;\n    }\n\n    this._rangesWithData = simplify(unify([range], this._rangesWithData));\n  }\n\n  // Get a slice of data. Throws if `VirtualLRUBuffer#hasData(start, end)` is false, so be sure to check\n  // that first. Will use an efficient `slice` instead of a copy if all the data happens to\n  // be contained in one block.\n  public slice(start: number, end: number): Uint8Array {\n    const size = end - start;\n    if (start < 0 || end > this.byteLength || size <= 0 || size > kMaxLength) {\n      throw new Error(\"VirtualLRUBuffer#slice invalid input\");\n    }\n    if (!this.hasData(start, end)) {\n      throw new Error(\"VirtualLRUBuffer#slice range has no data set\");\n    }\n\n    const startPositionData = this._calculatePosition(start);\n    if (size <= startPositionData.remainingBytesInBlock) {\n      // If the entire range that we care about are contained in one block, do an efficient\n      // `Buffer#slice` instead of copying data to a new Buffer.\n      const { blockIndex, positionInBlock } = startPositionData;\n      return this._getBlock(blockIndex).slice(positionInBlock, positionInBlock + size);\n    }\n\n    const result = new Uint8Array(size);\n    let position = start;\n    while (position < end) {\n      const { blockIndex, positionInBlock, remainingBytesInBlock } =\n        this._calculatePosition(position);\n      // Note that these calls to `_getBlock` will never cause any eviction, since we verified using\n      // the `VirtualLRUBuffer#hasData` precondition that all these buffers exist already.\n      copy(this._getBlock(blockIndex), result, position - start, positionInBlock);\n      position += remainingBytesInBlock;\n    }\n    return result;\n  }\n\n  // Get a reference to a block, and mark it as most recently used. Might evict older blocks.\n  private _getBlock(index: number): Uint8Array {\n    if (!this._blocks[index]) {\n      // If a block is not allocated yet, do so.\n      let size = this._blockSize;\n      if ((index + 1) * this._blockSize > this.byteLength) {\n        size = this.byteLength % this._blockSize; // Trim the last block to match the total size.\n      }\n      // It's okay to use `allocUnsafe` because we don't allow reading data from ranges that have\n      // not explicitly be filled using `VirtualLRUBuffer#copyFrom`.\n      this._blocks[index] = new Uint8Array(size);\n    }\n    // Put the current index to the end of the list, while avoiding duplicates.\n    this._lastAccessedBlockIndices = [\n      ...this._lastAccessedBlockIndices.filter((idx) => idx !== index),\n      index,\n    ];\n    if (this._lastAccessedBlockIndices.length > this._numberOfBlocks) {\n      // If we have too many blocks, remove the least recently used one.\n      // Note that we don't reuse blocks, since other code might still hold a reference to it\n      // via the `VirtualLRUBuffer#slice` method.\n      const deleteIndex = this._lastAccessedBlockIndices.shift();\n      if (deleteIndex != undefined) {\n        delete this._blocks[deleteIndex];\n        // Remove the range that we evicted from `_rangesWithData`, since the range doesn't have data now.\n        this._rangesWithData = simplify(\n          substract(this._rangesWithData, [\n            { start: deleteIndex * this._blockSize, end: (deleteIndex + 1) * this._blockSize },\n          ]),\n        );\n      }\n    }\n    const block = this._blocks[index];\n    if (!block) {\n      throw new Error(\"invariant violation - no block at index\");\n    }\n    return block;\n  }\n\n  // For a given position, calculate `blockIndex` (which block is this position in);\n  // `positionInBlock` (byte index of `position` within that block); and `remainingBytesInBlock`\n  // (how many bytes are there in that block after that position).\n  private _calculatePosition(position: number) {\n    if (position < 0 || position >= this.byteLength) {\n      throw new Error(\"VirtualLRUBuffer#_calculatePosition invalid input\");\n    }\n    const blockIndex = Math.floor(position / this._blockSize);\n    const positionInBlock = position - blockIndex * this._blockSize;\n    const remainingBytesInBlock = this._getBlock(blockIndex).byteLength - positionInBlock;\n    return { blockIndex, positionInBlock, remainingBytesInBlock };\n  }\n}\n\n/**\n * Copy part of a Uint8Array into another Uint8Array\n * @param source Source to copy from\n * @param target Destination to copy to\n * @param targetStart Index to start copying bytes to in `target`\n * @param sourceStart Index to start copying bytes from in `source`\n * @param sourceEnd Index to stop copying bytes from in `source`\n */\nfunction copy(\n  source: Uint8Array,\n  target: Uint8Array,\n  targetStart: number,\n  sourceStart: number,\n  sourceEnd?: number,\n): void {\n  const count = (sourceEnd ?? source.byteLength) - sourceStart;\n  for (let i = 0; i < count; i++) {\n    target[targetStart + i] = source[sourceStart + i]!;\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\nimport { isOverlapping } from \"intervals-fn\";\n\nimport { Range, isRangeCoveredByRanges, missingRanges } from \"./ranges\";\n\n// Based on a number of properties this function determines if a new connection should be opened or\n// not. It can be used for any type of ranges, be it bytes, timestamps, or something else.\nexport function getNewConnection(options: {\n  currentRemainingRange?: Range; // The remaining range that the current connection (if any) is going to download.\n  readRequestRange?: Range; // The range of the read request that we're trying to satisfy.\n  downloadedRanges: Range[]; // Array of ranges that have been downloaded already.\n  lastResolvedCallbackEnd?: number; // The range.end of the last read request that we resolved. Useful for reading ahead a bit.\n  maxRequestSize: number; // The cache size. If equal to or larger than `fileSize` we will attempt to download the whole file.\n  fileSize: number; // Size of the file.\n  continueDownloadingThreshold: number; // Amount we're willing to wait downloading before opening a new connection.\n}): Range | undefined {\n  const { readRequestRange, currentRemainingRange, ...otherOptions } = options;\n  if (readRequestRange) {\n    return getNewConnectionWithExistingReadRequest({\n      readRequestRange,\n      currentRemainingRange,\n      ...otherOptions,\n    });\n  } else if (!currentRemainingRange) {\n    return getNewConnectionWithoutExistingConnection(otherOptions);\n  }\n  return undefined;\n}\n\nfunction getNewConnectionWithExistingReadRequest({\n  currentRemainingRange,\n  readRequestRange,\n  downloadedRanges,\n  maxRequestSize,\n  fileSize,\n  continueDownloadingThreshold,\n}: {\n  currentRemainingRange?: Range;\n  readRequestRange: Range;\n  downloadedRanges: Range[];\n  lastResolvedCallbackEnd?: number;\n  maxRequestSize: number;\n  fileSize: number;\n  continueDownloadingThreshold: number;\n}): Range | undefined {\n  // We have a requested range that we're trying to download.\n  if (readRequestRange.end - readRequestRange.start > maxRequestSize) {\n    // This should have been caught way earlier, but just as a sanity check.\n    throw new Error(\n      `Range ${readRequestRange.start}-${readRequestRange.end} exceeds max request size ${maxRequestSize} (file size ${fileSize})`,\n    );\n  }\n\n  // Get the parts of the requested range that have not been downloaded yet.\n  const notDownloadedRanges = missingRanges(readRequestRange, downloadedRanges);\n\n  if (!notDownloadedRanges[0]) {\n    // If there aren't any, then we should have never passed in `readRequestRange`.\n    throw new Error(\n      \"Range for the first read request is fully downloaded, so it should have been deleted\",\n    );\n  }\n\n  // We want to start a new connection if:\n  const startNewConnection = // 1. There is no current connection.\n    !currentRemainingRange || // 2. Or if there is no overlap between the current connection and the requested range.\n    !isOverlapping(notDownloadedRanges, [currentRemainingRange]) || // 3. Or if we'll reach the requested range at some point, but that would take too long.\n    currentRemainingRange.start + continueDownloadingThreshold < notDownloadedRanges[0].start;\n\n  if (!startNewConnection) {\n    return;\n  }\n  if (maxRequestSize >= fileSize) {\n    // If we're trying to download the whole file, read all the way up to the next range that we have already downloaded.\n    const range = { start: notDownloadedRanges[0].start, end: fileSize };\n    return missingRanges(range, downloadedRanges)[0];\n  }\n\n  if (notDownloadedRanges[0].end === readRequestRange.end) {\n    // If we're downloading to the end of our range, do some reading ahead while we're at it.\n    // Note that we might have already downloaded parts of this range, but we don't know when\n    // they get evicted, so for now we just the entire range again.\n    return {\n      ...notDownloadedRanges[0],\n      end: Math.min(readRequestRange.start + maxRequestSize, fileSize),\n    };\n  }\n\n  // Otherwise, start reading from the first non-downloaded range.\n  return notDownloadedRanges[0];\n}\n\nfunction getNewConnectionWithoutExistingConnection({\n  downloadedRanges,\n  lastResolvedCallbackEnd,\n  maxRequestSize,\n  fileSize,\n}: {\n  downloadedRanges: Range[];\n  lastResolvedCallbackEnd?: number;\n  maxRequestSize: number;\n  fileSize: number;\n}): Range | undefined {\n  // If we don't have any read requests, and we also don't have an active connection, then start\n  // reading ahead as much data as we can!\n  let readAheadRange: Range | undefined;\n  if (maxRequestSize >= fileSize) {\n    // If we have an unlimited cache, we want to read the entire file, but still prefer downloading\n    // first near where the last request happened.\n    const potentialRange = { start: lastResolvedCallbackEnd ?? 0, end: fileSize };\n    if (!isRangeCoveredByRanges(potentialRange, downloadedRanges)) {\n      readAheadRange = potentialRange;\n    } else {\n      readAheadRange = { start: 0, end: fileSize };\n    }\n  } else if (lastResolvedCallbackEnd != undefined) {\n    // Otherwise, if we have a limited cache, we want to read the data right after the last\n    // read request, because usually read requests are sequential without gaps.\n    readAheadRange = {\n      start: lastResolvedCallbackEnd,\n      end: Math.min(lastResolvedCallbackEnd + maxRequestSize, fileSize),\n    };\n  }\n  if (readAheadRange) {\n    // If we have a range that we want to read ahead, then create a new connection for the range\n    // within it that has not already been downloaded.\n    return missingRanges(readAheadRange, downloadedRanges)[0];\n  }\n  return undefined;\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2019-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\nimport { round } from \"lodash\";\n\nimport Logger from \"@foxglove/log\";\nimport { Filelike } from \"@foxglove/rosbag\";\n\nimport VirtualLRUBuffer from \"./VirtualLRUBuffer\";\nimport { getNewConnection } from \"./getNewConnection\";\nimport { Range } from \"./ranges\";\n\n// CachedFilelike is a `Filelike` that attempts to do as much caching of the file in memory as\n// possible. It takes in 3 named arguments to its constructor:\n// - fileReader: a `FileReader` instance (defined below). This essentially does the streamed\n//     fetching of ranges from our file.\n// - cacheSizeInBytes (optional): how many bytes we're allowed to cache. Defaults to infinite\n//     caching (meaning that the cache will be as big as the file size). `cacheSizeInBytes` also\n//     becomes the largest range of data that can be requested.\n// - logFn (optional): a log function. Useful for logging in a particular format. Defaults to\n//     `console.log`.\n// - keepReconnectingCallback (optional): if set, we assume that we want to keep retrying on connection\n//     error, in which case the callback gets called with an update on whether we are currently\n//     reconnecting. This is useful when the connection is expected to be spotty, e.g. when\n//     running this code in a browser instead of on a server. If omitted, we will retry for a short\n//     amount of time and then reject read requests.\n//\n// Under the hood this uses a `VirtualLRUBuffer`, which represents the entire file in memory, even\n// though only parts of it may actually be stored in memory. It also manages evicting least recently\n// used blocks from memory.\n//\n// We keep a list of byte ranges that have been requested, and their associated callbacks. Typically\n// there will be only one such requested range at the time, as usually we need to parse some data\n// first before we can read more. We keep one stream from the `fileReader` open at a time, and we\n// serve the requested byte ranges in order.\n//\n// If there are currently no requested byte ranges, we try to intelligently load as much data as\n// possible into memory, with a preference given to ranges immediately following the last requested\n// byte range. If the cache spans the entire file size, we try to download the entire file.\n\nexport type FileStream = {\n  on<T>(event: \"data\", listener: (chunk: T) => void): void;\n  on(event: \"error\", listener: (err: Error) => void): void;\n  destroy: () => void;\n};\nexport interface FileReader {\n  open(): Promise<{ size: number }>;\n  fetch(offset: number, length: number): FileStream;\n}\n\nconst LOGGING_INTERVAL_IN_BYTES = 1024 * 1024 * 100; // Log every 100MiB to avoid cluttering the logs too much.\nconst CACHE_BLOCK_SIZE = 1024 * 1024 * 10; // 10MiB blocks.\n// Don't start a new connection if we're 5MiB away from downloading the requested byte.\nconst CLOSE_ENOUGH_BYTES_TO_NOT_START_NEW_CONNECTION = 1024 * 1024 * 5;\n\nconst log = Logger.getLogger(__filename);\n\ninterface ILogger {\n  debug(..._args: unknown[]): void;\n  info(..._args: unknown[]): void;\n  warn(..._args: unknown[]): void;\n  error(..._args: unknown[]): void;\n}\n\nexport default class CachedFilelike implements Filelike {\n  private _fileReader: FileReader;\n  private _cacheSizeInBytes: number = Infinity;\n  private _fileSize?: number;\n  private _virtualBuffer: VirtualLRUBuffer;\n  private _log: ILogger;\n  private _closed: boolean = false;\n  // eslint-disable-next-line @foxglove/no-boolean-parameters\n  private _keepReconnectingCallback?: (reconnecting: boolean) => void;\n\n  // The current active connection, if there is one. `remainingRange.start` gets updated whenever\n  // we receive new data, so it truly is the remaining range that it is going to download.\n  private _currentConnection: { stream: FileStream; remainingRange: Range } | undefined;\n\n  // A list of read requests and associated ranges for all read requests, in order.\n  private _readRequests: {\n    range: Range;\n    resolve: (_: Uint8Array) => void;\n    reject: (_: Error) => void;\n    requestTime: number;\n  }[] = [];\n\n  // The range.end of the last read request that we resolved. Useful for reading ahead a bit.\n  private _lastResolvedCallbackEnd?: number;\n\n  // The last time we've encountered an error;\n  private _lastErrorTime?: number;\n\n  public constructor(options: {\n    fileReader: FileReader;\n    cacheSizeInBytes?: number;\n    log?: ILogger;\n    // eslint-disable-next-line @foxglove/no-boolean-parameters\n    keepReconnectingCallback?: (reconnecting: boolean) => void;\n  }) {\n    this._fileReader = options.fileReader;\n    this._cacheSizeInBytes = options.cacheSizeInBytes ?? this._cacheSizeInBytes;\n    this._keepReconnectingCallback = options.keepReconnectingCallback;\n    this._log = options.log ?? log;\n    this._virtualBuffer = new VirtualLRUBuffer({ size: 0 });\n  }\n\n  public async open(): Promise<void> {\n    if (this._fileSize != undefined) {\n      return;\n    }\n    const { size } = await this._fileReader.open();\n    this._fileSize = size;\n    if (this._cacheSizeInBytes >= size) {\n      // If we have a cache limit that exceeds the file size, then we don't need to limit ourselves\n      // to small blocks. This way `VirtualLRUBuffer#slice` will be faster since we'll almost always\n      // not need to copy from multiple blocks into a new `Buffer` instance.\n      this._virtualBuffer = new VirtualLRUBuffer({ size });\n    } else {\n      this._virtualBuffer = new VirtualLRUBuffer({\n        size,\n        blockSize: CACHE_BLOCK_SIZE,\n        // Rather create too many blocks than too few (Math.ceil), and always add one block,\n        // to allow for a read range not starting or ending perfectly at a block boundary.\n        numberOfBlocks: Math.ceil(this._cacheSizeInBytes / CACHE_BLOCK_SIZE) + 2,\n      });\n    }\n    this._log.info(`Opening file with size ${bytesToMiB(this._fileSize)}MiB`);\n  }\n\n  // Get the file size. Requires a call to `open()` or `read()` first.\n  public size(): number {\n    if (this._fileSize == undefined) {\n      throw new Error(\"CachedFilelike has not been opened\");\n    }\n    return this._fileSize;\n  }\n\n  // Potentially performance-sensitive; await can be expensive\n  // eslint-disable-next-line @typescript-eslint/promise-function-async\n  public read(offset: number, length: number): Promise<Uint8Array> {\n    if (length === 0) {\n      return Promise.resolve(new Uint8Array());\n    }\n\n    const range = { start: offset, end: offset + length };\n\n    if (offset < 0 || length < 0) {\n      throw new Error(\"CachedFilelike#read invalid input\");\n    }\n    if (length > this._cacheSizeInBytes) {\n      throw new Error(`Requested more data than cache size: ${length} > ${this._cacheSizeInBytes}`);\n    }\n\n    // Potentially performance-sensitive; await can be expensive\n    return new Promise((resolve, reject) => {\n      this.open()\n        .then(() => {\n          const size = this.size();\n          if (range.end > size) {\n            reject(new Error(`CachedFilelike#read past size`));\n            return;\n          }\n\n          this._readRequests.push({ range, resolve, reject, requestTime: Date.now() });\n          this._updateState();\n        })\n        .catch((err) => {\n          reject(err);\n        });\n    });\n  }\n\n  // Gets called any time our connection or read requests change.\n  private _updateState(): void {\n    if (this._closed) {\n      return;\n    }\n\n    // First, see if there are any read requests that we can resolve now.\n    this._readRequests = this._readRequests.filter(({ range, resolve }) => {\n      if (!this._virtualBuffer.hasData(range.start, range.end)) {\n        return true;\n      }\n\n      this._lastResolvedCallbackEnd = range.end;\n      const buffer = this._virtualBuffer.slice(range.start, range.end);\n\n      resolve(buffer);\n      return false;\n    });\n\n    const size = this.size();\n\n    // Then see if we need to set a new connection based on the new connection and read requests state.\n    const newConnection = getNewConnection({\n      currentRemainingRange: this._currentConnection\n        ? this._currentConnection.remainingRange\n        : undefined,\n      readRequestRange: this._readRequests[0] ? this._readRequests[0].range : undefined,\n      downloadedRanges: this._virtualBuffer.getRangesWithData(),\n      lastResolvedCallbackEnd: this._lastResolvedCallbackEnd,\n      maxRequestSize: this._cacheSizeInBytes,\n      fileSize: size,\n      continueDownloadingThreshold: CLOSE_ENOUGH_BYTES_TO_NOT_START_NEW_CONNECTION,\n    });\n    if (newConnection) {\n      this._setConnection(newConnection);\n    }\n  }\n\n  // Replace the current connection with a new one, spanning a certain range.\n  private _setConnection(range: Range): void {\n    this._log.debug(`Setting new connection @ ${rangeToString(range)}`);\n\n    if (this._currentConnection) {\n      // Destroy the current connection if there is one.\n      const currentConnection = this._currentConnection;\n      currentConnection.stream.destroy();\n      this._log.debug(\n        `Destroyed current connection @ ${rangeToString(currentConnection.remainingRange)}`,\n      );\n    }\n\n    // Start the stream, and update the current connection state.\n    const stream = this._fileReader.fetch(range.start, range.end - range.start);\n    this._currentConnection = { stream, remainingRange: range };\n\n    stream.on(\"error\", (error: Error) => {\n      const currentConnection = this._currentConnection;\n      if (!currentConnection || stream !== currentConnection.stream) {\n        return; // Ignore errors from old streams.\n      }\n\n      if (this._keepReconnectingCallback) {\n        // If this callback is set, just keep retrying.\n        if (this._lastErrorTime == undefined) {\n          // And if this is the first error, let the callback know.\n          this._keepReconnectingCallback(true);\n        }\n      } else {\n        // Otherwise, if we get two errors in a short timespan (100ms) then there is probably a\n        // serious error, we resolve all remaining callbacks with errors and close out.\n        const lastErrorTime = this._lastErrorTime;\n        if (lastErrorTime != undefined && Date.now() - lastErrorTime < 100) {\n          this._log.error(\n            `Connection @ ${rangeToString(\n              range,\n            )} threw another error; closing: ${error.toString()}`,\n          );\n\n          this._closed = true;\n          for (const request of this._readRequests) {\n            request.reject(error);\n          }\n          return;\n        }\n      }\n\n      // When we encounter an error there is usually a bad connection or timeout or so, so just\n      // mark the current connection as destroyed, and try again.\n      this._log.info(\n        `Connection @ ${rangeToString(range)} threw error; trying to continue: ${error.toString()}`,\n      );\n      this._lastErrorTime = Date.now();\n      currentConnection.stream.destroy();\n      delete this._currentConnection;\n      this._updateState();\n    });\n\n    // Handle the data stream.\n    const startTime = Date.now();\n    let bytesRead = 0;\n    let lastReportedBytesRead = 0;\n    stream.on(\"data\", (chunk: Uint8Array) => {\n      const currentConnection = this._currentConnection;\n      if (!currentConnection || stream !== currentConnection.stream) {\n        return; // Ignore data from old streams.\n      }\n\n      if (this._lastErrorTime != undefined) {\n        // If we had an error before, then that has clearly been resolved since we received some data.\n        this._lastErrorTime = undefined;\n        if (this._keepReconnectingCallback) {\n          // And if we had a callback, let it know that the issue has been resolved.\n          this._keepReconnectingCallback(false);\n        }\n      }\n\n      // Copy the data into the VirtualLRUBuffer.\n      this._virtualBuffer.copyFrom(chunk, currentConnection.remainingRange.start);\n      bytesRead += chunk.byteLength;\n\n      // Every now and then, do some logging of the current download speed.\n      if (bytesRead - lastReportedBytesRead > LOGGING_INTERVAL_IN_BYTES) {\n        lastReportedBytesRead = bytesRead;\n        const sec = (Date.now() - startTime) / 1000;\n\n        const mibibytes = bytesToMiB(bytesRead);\n        const speed = round(mibibytes / sec, 2);\n        this._log.debug(\n          `Connection @ ${rangeToString(\n            currentConnection.remainingRange,\n          )} downloading at ${speed} MiB/s`,\n        );\n      }\n\n      if (this._virtualBuffer.hasData(range.start, range.end)) {\n        // If the requested range has been downloaded, we're done!\n        this._log.info(`Connection @ ${rangeToString(currentConnection.remainingRange)} finished!`);\n        stream.destroy();\n        delete this._currentConnection;\n      } else {\n        // Otherwise, update `remainingRange`.\n        this._currentConnection = {\n          stream,\n          remainingRange: { start: range.start + bytesRead, end: range.end },\n        };\n      }\n\n      // Always call `_updateState` so it can decide to create new connections, resolve callbacks, etc.\n      this._updateState();\n    });\n  }\n}\n\n// Some formatting functions.\nfunction bytesToMiB(bytes: number) {\n  return round(bytes / 1024 / 1024, 3);\n}\nfunction rangeToString(range: Range) {\n  return `${bytesToMiB(range.start)}-${bytesToMiB(range.end)}MiB`;\n}\n"],"names":["abortSignalTransferHandler","val","aborted","msgPort","controller","abortSignal","port1","port2","channels","noop","Logger","name","level","_args","shortName","channelName","existing","logger","toLogLevel","maybeLevel","TIME_ZERO","IteratorCursor","iterator","abort","durationMs","firstResult","results","cutoffTime","result","end","value","WorkerIterableSourceWorker","source","args","iter","cursor","FetchReader","url","options","data","err","errMsg","reader","done","unk","isDesktopApp","BrowserHttpReader","response","error","size","offset","length","headers","isRangeCoveredByRanges","queryRange","nonOverlappingMergedAndSortedRanges","range","missingRanges","bounds","ranges","kMaxLength","VirtualLRUBuffer","start","targetStart","position","blockIndex","positionInBlock","remainingBytesInBlock","copy","startPositionData","index","idx","deleteIndex","block","target","sourceStart","sourceEnd","count","i","getNewConnection","readRequestRange","currentRemainingRange","otherOptions","getNewConnectionWithExistingReadRequest","getNewConnectionWithoutExistingConnection","downloadedRanges","maxRequestSize","fileSize","continueDownloadingThreshold","notDownloadedRanges","lastResolvedCallbackEnd","readAheadRange","potentialRange","LOGGING_INTERVAL_IN_BYTES","CACHE_BLOCK_SIZE","CLOSE_ENOUGH_BYTES_TO_NOT_START_NEW_CONNECTION","log","CachedFilelike","bytesToMiB","resolve","reject","buffer","newConnection","rangeToString","currentConnection","stream","lastErrorTime","request","startTime","bytesRead","lastReportedBytesRead","chunk","sec","mibibytes","speed","bytes"],"sourceRoot":""}