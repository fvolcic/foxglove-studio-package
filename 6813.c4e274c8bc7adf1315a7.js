"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6813],{46813:(Q,V,c)=>{var T=c(90758),N=c(41253),B=c(25811),z=c(23503),q=c(21509),_=c(25673),R=c(39833);let $;async function C(){return await($??($=F()))}async function F(){const[m,e,s]=await Promise.all([Promise.all([c.e(3005),c.e(8834),c.e(3349)]).then(c.t.bind(c,3349,23)).then(async n=>(await n.isLoaded,n.decompress)),Promise.all([c.e(3005),c.e(8834),c.e(3400)]).then(c.t.bind(c,3400,23)).then(async n=>(await n.default.isLoaded,n.default)),Promise.all([c.e(363),c.e(3463)]).then(c.bind(c,94789)).then(async n=>await n.default.init())]);return{lz4:(n,r)=>e(n,Number(r)),bz2:(n,r)=>s.decompress(n,Number(r),{small:!1}),zstd:(n,r)=>m(n,Number(r))}}class H{constructor(e){this.file=e}async size(){return BigInt(this.file.size)}async read(e,s){if(e+s>this.file.size)throw new Error(`Read of ${s} bytes at offset ${e} exceeds file size ${this.file.size}`);return new Uint8Array(await this.file.slice(Number(e),Number(e+s)).arrayBuffer())}}var l=c(44668),Z="../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIndexedIterableSource.ts";const x=z.ZP.getLogger(Z);class L{constructor(e){this.channelInfoById=new Map,this.reader=e}async initialize(){let e,s;for(const a of this.reader.chunkIndexes)(e==null||a.messageStartTime<e)&&(e=a.messageStartTime),(s==null||a.messageEndTime>s)&&(s=a.messageEndTime);const n=new Map,r=new Map,o=new Map,i=[],h=new Map;for(const a of this.reader.channelsById.values()){const g=this.reader.schemasById.get(a.schemaId);if(a.schemaId!==0&&g==null){i.push({severity:"error",message:`Missing schema info for schema id ${a.schemaId} (channel ${a.id}, topic ${a.topic})`});continue}let w;try{w=(0,R.W)({messageEncoding:a.messageEncoding,schema:g})}catch(p){i.push({severity:"error",message:`Error in topic ${a.topic} (channel ${a.id}): ${p.message}`,error:p});continue}this.channelInfoById.set(a.id,{channel:a,parsedChannel:w,schemaName:g?.name});let b=r.get(a.topic);if(!b){b={name:a.topic,schemaName:g?.name},r.set(a.topic,b);const p=this.reader.statistics?.channelMessageCounts.get(a.id);p!=null&&n.set(a.topic,{numMessages:Number(p)})}const v=a.metadata.get("callerid")??String(a.id);let y=h.get(a.topic);y||(y=new Set,h.set(a.topic,y)),y.add(v);for(const[p,E]of w.datatypes)o.set(p,E)}return this.start=(0,l.fromNanoSec)(e??0n),this.end=(0,l.fromNanoSec)(s??e??0n),{start:this.start,end:this.end,topics:[...r.values()],datatypes:o,profile:this.reader.header.profile,problems:i,publishersByTopic:h,topicStats:n}}async*messageIterator(e){const s=e.topics,n=e.start??this.start,r=e.end??this.end;if(!(s.length===0||!n||!r))for await(const o of this.reader.readMessages({startTime:(0,l.toNanoSec)(n),endTime:(0,l.toNanoSec)(r),topics:s})){const i=this.channelInfoById.get(o.channelId);if(!i){yield{type:"problem",problem:{message:`Received message on channel ${o.channelId} without prior channel info`,severity:"error"}};continue}try{yield{type:"message-event",msgEvent:{topic:i.channel.topic,receiveTime:(0,l.fromNanoSec)(o.logTime),publishTime:(0,l.fromNanoSec)(o.publishTime),message:i.parsedChannel.deserialize(o.data),sizeInBytes:o.data.byteLength,schemaName:i.schemaName??""}}}catch(h){yield{type:"problem",problem:{message:`Error decoding message on ${i.channel.topic}`,error:h,severity:"error"}}}}}async getBackfillMessages(e){const{topics:s,time:n}=e,r=[];for(const o of s)for await(const i of this.reader.readMessages({endTime:(0,l.toNanoSec)(n),topics:[o],reverse:!0})){const h=this.channelInfoById.get(i.channelId);if(!h){x.error(`Missing channel info for channel: ${i.channelId} on topic: ${o}`);continue}try{r.push({topic:h.channel.topic,receiveTime:(0,l.fromNanoSec)(i.logTime),publishTime:(0,l.fromNanoSec)(i.publishTime),message:h.parsedChannel.deserialize(i.data),sizeInBytes:i.data.byteLength,schemaName:h.schemaName??""})}catch(a){x.error(a)}break}return r.sort((o,i)=>(0,l.compare)(o.receiveTime,i.receiveTime)),r}}var P=c(76635);const U=365*24*60*60;class k{constructor(e){this.options=e}async initialize(){if(this.options.size>1024*1024*1024)throw new Error("Unable to stream MCAP file; too large");const e=await C(),s=this.options.stream.getReader(),n=[],r=new Set,o=new Map,i=new Map,h=new Map;let a,g,w;function b(t){switch(t.type){default:break;case"Header":{w=t.profile;break}case"Schema":{const d=i.get(t.id);if(d&&!(0,P.isEqual)(d,t))throw new Error(`differing schemas for id ${t.id}`);i.set(t.id,t);break}case"Channel":{const d=h.get(t.id);if(d){if(!(0,P.isEqual)(d.channel,t))throw new Error(`differing channel infos for id ${t.id}`);break}if(r.has(t.id))break;const f=i.get(t.schemaId);if(t.schemaId!==0&&!f)throw new Error(`Encountered channel with schema id ${t.schemaId} but no prior schema`);try{const u=(0,R.W)({messageEncoding:t.messageEncoding,schema:f});h.set(t.id,{channel:t,parsedChannel:u,schemaName:f?.name}),o.set(t.id,[])}catch(u){r.add(t.id),n.push({severity:"error",message:`Error in topic ${t.topic} (channel ${t.id}): ${u.message}`,error:u})}break}case"Message":{const d=t.channelId,f=h.get(d),u=o.get(d);if(!f||!u){if(r.has(d))break;throw new Error(`message for channel ${d} with no prior channel info`)}const I=(0,l.fromNanoSec)(t.logTime);(!a||(0,l.isLessThan)(I,a))&&(a=I),(!g||(0,l.isGreaterThan)(I,g))&&(g=I),u.push({topic:f.channel.topic,receiveTime:I,publishTime:(0,l.fromNanoSec)(t.publishTime),message:f.parsedChannel.deserialize(t.data),sizeInBytes:t.data.byteLength,schemaName:f.schemaName??""});break}}}const v=new B.c1({decompressHandlers:e});for(let t;t=await s.read(),!t.done;){v.append(t.value);for(let d;d=v.nextRecord();)b(d)}this.msgEventsByChannel=o;const y=[],p=new Map,E=new Map,M=new Map;for(const{channel:t,parsedChannel:d,schemaName:f}of h.values()){y.push({name:t.topic,schemaName:f});const u=o.get(t.id)?.length;u!=null&&p.set(t.topic,{numMessages:u});const I=t.metadata.get("callerid")??String(t.id);let S=M.get(t.topic);S||(S=new Set,M.set(t.topic,S)),S.add(I);for(const[Y,K]of d.datatypes)E.set(Y,K)}if(this.start=a??{sec:0,nsec:0},this.end=g??{sec:0,nsec:0},(0,l.toSec)((0,l.subtract)(this.end,this.start))>U){const t=(0,l.toRFC3339String)(this.start),d=(0,l.toRFC3339String)(this.end);n.push({message:"This file has an abnormally long duration.",tip:`The start ${t} and end ${d} are greater than a year.`,severity:"warn"})}return n.push({message:"This file is unindexed. Unindexed files may have degraded performance.",tip:"See the mcap spec: https://mcap.dev/specification/index.html#summary-section",severity:"warn"}),{start:this.start,end:this.end,topics:y,datatypes:E,profile:w,problems:n,publishersByTopic:M,topicStats:p}}async*messageIterator(e){if(!this.msgEventsByChannel)throw new Error("initialization not completed");const s=e.topics,n=e.start??this.start,r=e.end??this.end;if(s.length===0||!n||!r)return;const o=new Set(s);for(const[i,h]of this.msgEventsByChannel)for(const a of h)(0,l.isTimeInRangeInclusive)(a.receiveTime,n,r)&&o.has(a.topic)&&(yield{type:"message-event",connectionId:i,msgEvent:a})}async getBackfillMessages(e){if(!this.msgEventsByChannel)throw new Error("initialization not completed");const s=e.topics,n=new Map;for(const[r,o]of this.msgEventsByChannel)for(const i of o)(0,l.compare)(i.receiveTime,e.time)<=0&&s.includes(i.topic)&&n.set(i.topic,i);return[...n.values()]}}var W=c(20865),j=c(88499);class G{constructor(e){const s=new W.Z(e);this.remoteReader=new j.Z({fileReader:s,cacheSizeInBytes:1024*1024*200})}async open(){await this.remoteReader.open()}async size(){return BigInt(this.remoteReader.size())}async read(e,s){if(e+s>Number.MAX_SAFE_INTEGER)throw new Error(`Read too large: offset ${e}, size ${s}`);return await this.remoteReader.read(Number(e),Number(s))}}var J="../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIterableSource.ts";const O=z.ZP.getLogger(J);async function D(m){const e=await C();try{const s=await B.RS.Initialize({readable:m,decompressHandlers:e});return s.chunkIndexes.length===0||s.channelsById.size===0?void 0:s}catch(s){O.error(s);return}}class A{constructor(e){this._source=e}async initialize(){const e=this._source;switch(e.type){case"file":{await e.file.slice(0,1).arrayBuffer();const s=new H(e.file),n=await D(s);n?this._sourceImpl=new L(n):this._sourceImpl=new k({size:e.file.size,stream:e.file.stream()});break}case"url":{const s=new G(e.url);await s.open();const n=await D(s);if(n)this._sourceImpl=new L(n);else{const r=await fetch(e.url);if(!r.body)throw new Error(`Unable to stream remote file. <${e.url}>`);const o=r.headers.get("content-length");if(o==null)throw new Error(`Remote file is missing Content-Length header. <${e.url}>`);this._sourceImpl=new k({size:parseInt(o),stream:r.body})}break}}return await this._sourceImpl.initialize()}messageIterator(e){if(!this._sourceImpl)throw new Error("Invariant: uninitialized");return this._sourceImpl.messageIterator(e)}async getBackfillMessages(e){if(!this._sourceImpl)throw new Error("Invariant: uninitialized");return await this._sourceImpl.getBackfillMessages(e)}}function X(m){if(m.file){const e=new A({type:"file",file:m.file}),s=new N.a(e);return T.sj(s)}else if(m.url){const e=new A({type:"url",url:m.url}),s=new N.a(e);return T.sj(s)}throw new Error("file or url required")}T.Jj(X)}}]);

//# sourceMappingURL=6813.c4e274c8bc7adf1315a7.js.map