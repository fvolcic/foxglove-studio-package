{"version":3,"file":"4077.85e9c07cfc37d60ae027.js","mappings":"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","sources":["webpack:///../../packages/den/image/decodings.ts","webpack:///../../packages/den/image/PinholeCameraModel.ts","webpack:///../../packages/studio-base/src/panels/Image/lib/HitmapRenderContext.ts","webpack:///../../packages/studio-base/src/panels/Image/lib/renderImage.ts"],"sourcesContent":["// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2018-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\n\nfunction yuvToRGBA8(\n  y1: number,\n  u: number,\n  y2: number,\n  v: number,\n  c: number,\n  output: Uint8ClampedArray,\n): void {\n  // rgba\n  output[c] = y1 + 1.402 * v;\n  output[c + 1] = y1 - 0.34414 * u - 0.71414 * v;\n  output[c + 2] = y1 + 1.772 * u;\n  output[c + 3] = 255;\n\n  // rgba\n  output[c + 4] = y2 + 1.402 * v;\n  output[c + 5] = y2 - 0.34414 * u - 0.71414 * v;\n  output[c + 6] = y2 + 1.772 * u;\n  output[c + 7] = 255;\n}\n\nexport function decodeYUV(\n  yuv: Int8Array,\n  width: number,\n  height: number,\n  output: Uint8ClampedArray,\n): void {\n  let c = 0;\n  let off = 0;\n\n  // populate 2 pixels at a time\n  const max = height * width;\n  for (let r = 0; r <= max; r += 2) {\n    const u = yuv[off]! - 128;\n    const y1 = yuv[off + 1]!;\n    const v = yuv[off + 2]! - 128;\n    const y2 = yuv[off + 3]!;\n    yuvToRGBA8(y1, u, y2, v, c, output);\n    c += 8;\n    off += 4;\n  }\n}\n\n// change name in the future do something more distinct\nexport function decodeYUYV(\n  yuyv: Int8Array,\n  width: number,\n  height: number,\n  output: Uint8ClampedArray,\n): void {\n  let c = 0;\n  let off = 0;\n\n  // populate 2 pixels at a time\n  const max = height * width;\n  for (let r = 0; r <= max; r += 2) {\n    const y1 = yuyv[off]!;\n    const u = yuyv[off + 1]! - 128;\n    const y2 = yuyv[off + 2]!;\n    const v = yuyv[off + 3]! - 128;\n    yuvToRGBA8(y1, u, y2, v, c, output);\n    c += 8;\n    off += 4;\n  }\n}\n\nexport function decodeRGB8(\n  rgb: Uint8Array,\n  width: number,\n  height: number,\n  output: Uint8ClampedArray,\n): void {\n  let inIdx = 0;\n  let outIdx = 0;\n\n  for (let i = 0; i < width * height; i++) {\n    const r = rgb[inIdx++]!;\n    const g = rgb[inIdx++]!;\n    const b = rgb[inIdx++]!;\n\n    output[outIdx++] = r;\n    output[outIdx++] = g;\n    output[outIdx++] = b;\n    output[outIdx++] = 255;\n  }\n}\n\nexport function decodeRGBA8(\n  rgba: Uint8Array,\n  width: number,\n  height: number,\n  output: Uint8ClampedArray,\n): void {\n  let inIdx = 0;\n  let outIdx = 0;\n\n  for (let i = 0; i < width * height; i++) {\n    const r = rgba[inIdx++]!;\n    const g = rgba[inIdx++]!;\n    const b = rgba[inIdx++]!;\n    const a = rgba[inIdx++]!;\n\n    output[outIdx++] = r;\n    output[outIdx++] = g;\n    output[outIdx++] = b;\n    output[outIdx++] = a;\n  }\n}\n\nexport function decodeBGRA8(\n  rgba: Uint8Array,\n  width: number,\n  height: number,\n  output: Uint8ClampedArray,\n): void {\n  let inIdx = 0;\n  let outIdx = 0;\n\n  for (let i = 0; i < width * height; i++) {\n    const b = rgba[inIdx++]!;\n    const g = rgba[inIdx++]!;\n    const r = rgba[inIdx++]!;\n    const a = rgba[inIdx++]!;\n\n    output[outIdx++] = r;\n    output[outIdx++] = g;\n    output[outIdx++] = b;\n    output[outIdx++] = a;\n  }\n}\n\nexport function decodeBGR8(\n  bgr: Uint8Array,\n  width: number,\n  height: number,\n  output: Uint8ClampedArray,\n): void {\n  let inIdx = 0;\n  let outIdx = 0;\n\n  for (let i = 0; i < width * height; i++) {\n    const b = bgr[inIdx++]!;\n    const g = bgr[inIdx++]!;\n    const r = bgr[inIdx++]!;\n\n    output[outIdx++] = r;\n    output[outIdx++] = g;\n    output[outIdx++] = b;\n    output[outIdx++] = 255;\n  }\n}\n\nexport function decodeFloat1c(\n  gray: Uint8Array,\n  width: number,\n  height: number,\n  // eslint-disable-next-line @foxglove/no-boolean-parameters\n  is_bigendian: boolean,\n  output: Uint8ClampedArray,\n): void {\n  const view = new DataView(gray.buffer, gray.byteOffset);\n\n  let outIdx = 0;\n  for (let i = 0; i < width * height * 4; i += 4) {\n    const val = view.getFloat32(i, !is_bigendian) * 255;\n    output[outIdx++] = val;\n    output[outIdx++] = val;\n    output[outIdx++] = val;\n    output[outIdx++] = 255;\n  }\n}\n\nexport function decodeMono8(\n  mono8: Uint8Array,\n  width: number,\n  height: number,\n  output: Uint8ClampedArray,\n): void {\n  let inIdx = 0;\n  let outIdx = 0;\n\n  for (let i = 0; i < width * height; i++) {\n    const ch = mono8[inIdx++]!;\n    output[outIdx++] = ch;\n    output[outIdx++] = ch;\n    output[outIdx++] = ch;\n    output[outIdx++] = 255;\n  }\n}\n\nexport function decodeMono16(\n  mono16: Uint8Array,\n  width: number,\n  height: number,\n  // eslint-disable-next-line @foxglove/no-boolean-parameters\n  is_bigendian: boolean,\n  output: Uint8ClampedArray,\n  options?: { minValue?: number; maxValue?: number },\n): void {\n  const view = new DataView(mono16.buffer, mono16.byteOffset);\n\n  // Use user-provided max/min values, or default to 0-10000, consistent with image_view's default.\n  // References:\n  // https://github.com/ros-perception/image_pipeline/blob/42266892502427eb566a4dffa61b009346491ce7/image_view/src/nodes/image_view.cpp#L80-L88\n  // https://github.com/ros-visualization/rqt_image_view/blob/fe076acd265a05c11c04f9d04392fda951878f54/src/rqt_image_view/image_view.cpp#L582\n  // https://github.com/ros-visualization/rviz/blob/68b464fb6571b8760f91e8eca6fb933ba31190bf/src/rviz/image/ros_image_texture.cpp#L114\n  const minValue = options?.minValue ?? 0;\n  let maxValue = options?.maxValue ?? 10000;\n  if (maxValue === minValue) {\n    maxValue = minValue + 1;\n  }\n\n  let outIdx = 0;\n  for (let i = 0; i < width * height * 2; i += 2) {\n    let val = view.getUint16(i, !is_bigendian);\n\n    val = ((val - minValue) / (maxValue - minValue)) * 255;\n\n    output[outIdx++] = val;\n    output[outIdx++] = val;\n    output[outIdx++] = val;\n    output[outIdx++] = 255;\n  }\n}\n\n// Specialize the Bayer decode function to a certain encoding. For performance reasons, we use\n// new Function() -- this is about 20% faster than a switch statement and .bind().\nfunction makeSpecializedDecodeBayer(\n  tl: string,\n  tr: string,\n  bl: string,\n  br: string,\n): (data: Uint8Array, width: number, height: number, output: Uint8ClampedArray) => void {\n  // We probably can't afford real debayering/demosaicking, so do something simpler\n  // The input array look like a single-plane array of pixels.  However, each pixel represents a one particular color\n  // for a group of pixels in the 2x2 region.  For 'rggb', there color representatio for the 2x2 region looks like:\n  //\n  // R  | G0\n  // -------\n  // G1 | B\n  //\n  // In other words, a 2x2 region is represented by one R value, one B value, and two G values.  In sophisticated\n  // algorithms, each color will be weighted and interpolated to fill in the missing colors for the pixels.  These\n  // algorithms may reach beyond the local 2x2 region and use values from neighboring regions.\n  //\n  // We'll do something much simpler.  For each group of 2x2, we're replicate the R and B values for all pixels.\n  // For the two row, we'll replicate G0 for the green channels, and replicate G1 for the bottom row.\n  // eslint-disable-next-line no-new-func\n  return new Function(\n    \"data\",\n    \"width\",\n    \"height\",\n    \"output\",\n    `\n  for (let i = 0; i < height / 2; i++) {\n    let inIdx = i * 2 * width;\n    let outTopIdx = i * 2 * width * 4; // Addresses top row\n    let outBottomIdx = (i * 2 + 1) * width * 4; // Addresses bottom row\n    for (let j = 0; j < width / 2; j++) {\n      const tl = data[inIdx++];\n      const tr = data[inIdx++];\n      const bl = data[inIdx + width - 2];\n      const br = data[inIdx + width - 1];\n\n      const ${tl} = tl;\n      const ${tr} = tr;\n      const ${bl} = bl;\n      const ${br} = br;\n\n      // Top row\n      output[outTopIdx++] = r;\n      output[outTopIdx++] = g0;\n      output[outTopIdx++] = b;\n      output[outTopIdx++] = 255;\n\n      output[outTopIdx++] = r;\n      output[outTopIdx++] = g0;\n      output[outTopIdx++] = b;\n      output[outTopIdx++] = 255;\n\n      // Bottom row\n      output[outBottomIdx++] = r;\n      output[outBottomIdx++] = g1;\n      output[outBottomIdx++] = b;\n      output[outBottomIdx++] = 255;\n\n      output[outBottomIdx++] = r;\n      output[outBottomIdx++] = g1;\n      output[outBottomIdx++] = b;\n      output[outBottomIdx++] = 255;\n    }\n  }`,\n  ) as ReturnType<typeof makeSpecializedDecodeBayer>;\n}\n\nexport const decodeBayerRGGB8 = makeSpecializedDecodeBayer(\"r\", \"g0\", \"g1\", \"b\");\nexport const decodeBayerBGGR8 = makeSpecializedDecodeBayer(\"b\", \"g0\", \"g1\", \"r\");\nexport const decodeBayerGBRG8 = makeSpecializedDecodeBayer(\"g0\", \"b\", \"r\", \"g1\");\nexport const decodeBayerGRBG8 = makeSpecializedDecodeBayer(\"g0\", \"r\", \"b\", \"g1\");\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport type { CameraInfo } from \"./CameraInfo\";\n\ntype Vector2 = { x: number; y: number };\n\ntype Vector3 = { x: number; y: number; z: number };\n\ntype Matrix3 = [number, number, number, number, number, number, number, number, number];\n\n// prettier-ignore\ntype Matrix3x4 = [\n  number, number, number, number,\n  number, number, number, number,\n  number, number, number, number,\n];\n\ntype Vec8 = [number, number, number, number, number, number, number, number];\n\n/**\n * A pinhole camera model that can be used to rectify, unrectify, and project pixel coordinates.\n * Based on `ROSPinholeCameraModel` from the ROS `image_geometry` package. See\n * <http://docs.ros.org/diamondback/api/image_geometry/html/c++/pinhole__camera__model_8cpp_source.html>\n */\nexport class PinholeCameraModel {\n  /**\n   * Distortion parameters `[k1, k2, p1, p2, k3, k4, k5, k6]`. For `rational_polynomial`, all eight\n   * parameters are set. For `plumb_bob`, the last three parameters are set to zero. For no\n   * distortion model, all eight parameters are set to zero.\n   */\n  public D: Readonly<Vec8>;\n  /**\n   * Intrinsic camera matrix for the raw (distorted) images. 3x3 row-major matrix.\n   * ```\n   *     [fx  0 cx]\n   * K = [ 0 fy cy]\n   *     [ 0  0  1]\n   * ```\n   * Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal\n   * lengths `(fx, fy)` and principal point `(cx, cy)`.\n   */\n  public K: Readonly<Matrix3>;\n  /**\n   * Projection/camera matrix. 3x4 row-major matrix.\n   * This matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That\n   * is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.\n   *\n   * It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal\n   * lengths `(fx', fy')` and principal point `(cx', cy')` - these may differ from the values in K.\n   * For monocular cameras, `Tx = Ty = 0`. Normally, monocular cameras will also have R = the\n   * identity and `P[1:3,1:3] = K`.\n   *\n   * For a stereo pair, the fourth column `[Tx Ty 0]'` is related to the position of the optical\n   * center of the second camera in the first camera's frame. We assume `Tz = 0` so both cameras are\n   * in the same stereo image plane. The first camera always has `Tx = Ty = 0`. For the right\n   * (second) camera of a horizontal stereo pair, `Ty = 0 and Tx = -fx' * B`, where `B` is the\n   * baseline between the cameras.\n   *\n   * Given a 3D point `[X Y Z]'`, the projection `(x, y)` of the point onto the rectified image is\n   * given by:\n   * ```\n   * [u v w]' = P * [X Y Z 1]'\n   *        x = u / w\n   *        y = v / w\n   * ```\n   * This holds for both images of a stereo pair.\n   */\n  public P: Readonly<Matrix3x4> | undefined;\n  /**\n   * Rectification matrix (stereo cameras only). 3x3 row-major matrix.\n   * A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so\n   * that epipolar lines in both stereo images are parallel.\n   */\n  public R: Readonly<Matrix3>;\n  /** The full camera image width in pixels. */\n  public readonly width: number;\n  /** The full camera image height in pixels. */\n  public readonly height: number;\n\n  // Mostly copied from `fromCameraInfo`\n  // <http://docs.ros.org/diamondback/api/image_geometry/html/c++/pinhole__camera__model_8cpp_source.html#l00064>\n  public constructor(info: CameraInfo) {\n    const { binning_x, binning_y, roi, distortion_model: model, D, K, P, R, width, height } = info;\n    const fx = P[0];\n    const fy = P[5];\n\n    if (width <= 0 || height <= 0) {\n      throw new Error(`Invalid image size ${width}x${height}`);\n    }\n    if (model.length > 0 && model !== \"plumb_bob\" && model !== \"rational_polynomial\") {\n      throw new Error(`Unrecognized distortion_model \"${model}\"`);\n    }\n    if (K.length !== 0 && K.length !== 9) {\n      throw new Error(`K.length=${K.length}, expected 9`);\n    }\n    if (P.length !== 0 && P.length !== 12) {\n      throw new Error(`P.length=${K.length}, expected 12`);\n    }\n    if (R.length !== 0 && R.length !== 9) {\n      throw new Error(`R.length=${R.length}, expected 9`);\n    }\n    if (fx === 0 || fy === 0) {\n      throw new Error(`Invalid focal length (fx=${fx}, fy=${fy})`);\n    }\n\n    const D8 = [...D];\n    while (D8.length < 8) {\n      D8.push(0);\n    }\n    this.D = D8 as Vec8;\n    this.K = K.length === 9 ? (K as Matrix3) : [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    this.P = P.length === 12 ? (P as Matrix3x4) : undefined;\n    this.R = R.length === 9 ? (R as Matrix3) : [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    this.width = width;\n    this.height = height;\n\n    // Binning = 0 is considered the same as binning = 1 (no binning).\n    const binningX = binning_x !== 0 ? binning_x : 1;\n    const binningY = binning_y !== 0 ? binning_y : 1;\n\n    const adjustBinning = binningX > 1 || binningY > 1;\n    const adjustRoi = roi.x_offset !== 0 || roi.y_offset !== 0;\n\n    if (adjustBinning || adjustRoi) {\n      throw new Error(\n        \"Failed to initialize camera model: unable to handle adjusted binning and adjusted roi camera models.\",\n      );\n    }\n  }\n\n  /**\n   * Projects a 2D image pixel to a point on a plane in 3D world coordinates a\n   * unit distance along the Z axis. This is equivalent to `projectPixelTo3dRay`\n   * before normalizing.\n   *\n   * @param out - The output vector to receive the 3D point.\n   * @param pixel - The 2D image pixel coordinate.\n   * @returns `true` if the projection was successful, or `false` if the camera\n   *   projection matrix `P` is not set.\n   */\n  public projectPixelTo3dPlane(out: Vector3, pixel: Readonly<Vector2>): boolean {\n    const P = this.P;\n    if (!P) {\n      return false;\n    }\n\n    const fx = P[0];\n    const fy = P[5];\n    const cx = P[2];\n    const cy = P[6];\n    const tx = P[3];\n    const ty = P[7];\n\n    out.x = (pixel.x - cx - tx) / fx;\n    out.y = (pixel.y - cy - ty) / fy;\n    out.z = 1.0;\n\n    return true;\n  }\n\n  /**\n   * Projects a 2D image pixel into a 3D ray in world coordinates. This is\n   * equivalent to normalizing the result of `projectPixelTo3dPlane` to get a\n   * direction vector.\n   *\n   * @param out - The output vector to receive the 3D ray direction.\n   * @param pixel - The 2D image pixel coordinate.\n   * @returns `true` if the projection was successful, or `false` if the camera\n   *   projection matrix `P` is not set.\n   */\n  public projectPixelTo3dRay(out: Vector3, pixel: Readonly<Vector2>): boolean {\n    if (!this.projectPixelTo3dPlane(out, pixel)) {\n      return false;\n    }\n\n    // Normalize the ray direction\n    const invNorm = 1.0 / Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z);\n    out.x *= invNorm;\n    out.y *= invNorm;\n    out.z *= invNorm;\n\n    return true;\n  }\n\n  /**\n   * Rectifies the given pixel 2D coordinate.\n   *\n   * @param out - The output rectified 2D pixel coordinate.\n   * @param point - The input unrectified 2D pixel to rectify.\n   * @param iterations - The number of iterations to use in the iterative optimization.\n   * @returns The rectified pixel, a reference to `out`.\n   */\n  public rectifyPixel(out: Vector2, point: Readonly<Vector2>, iterations = 5): Vector2 {\n    if (!this.P) {\n      out.x = point.x;\n      out.y = point.y;\n      return out;\n    }\n\n    const { P, D } = this;\n    const [k1, k2, p1, p2, k3] = D;\n\n    const fx = P[0];\n    const fy = P[5];\n    const cx = P[2];\n    const cy = P[6];\n\n    // This method does three things:\n    //   1. Convert the input 2D point from pixel coordinates to normalized\n    //      coordinates by subtracting the principal point (cx, cy) and dividing\n    //      by the focal lengths (fx, fy).\n    //   2. Apply the distortion model to the normalized point using an\n    //      iterative optimization algorithm. This undoes the distortion that\n    //      was applied to the original image and yields an approximation of the\n    //      rectified point.\n    //   3. Convert the rectified point back to pixel coordinates by multiplying\n    //      by the focal lengths and adding the principal point.\n    // The distortion model is non-linear, so we use fixed-point iteration to\n    // incrementally iterate to an approximation of the solution. This approach\n    // is described at <http://peterabeles.com/blog/?p=73>. The Jacobi method is\n    // used here, balancing accuracy and speed. A more precise method such as\n    // Levenberg-Marquardt or the exact formula described in\n    // <https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4934233/> could be used,\n    // but they are slower and less suitable for real-time applications such as\n    // visualization. Note that our method is only locally convergent, requiring\n    // a good \"initial guess\". This means we may not converge for extreme values\n    // such as points close to the focal plane.\n    //\n    // The implementation is based on code from\n    // <https://yangyushi.github.io/code/2020/03/04/opencv-undistort.html>\n    // You can read more about the equations used in the pinhole camera model at\n    // <https://docs.opencv.org/4.x/d9/d0c/group__calib3d.html#details>\n    let x = (point.x - cx) / fx;\n    let y = (point.y - cy) / fy;\n\n    const x0 = x;\n    const y0 = y;\n    const count = k1 !== 0 || k2 !== 0 || p1 !== 0 || p2 !== 0 || k3 !== 0 ? iterations : 1;\n    for (let i = 0; i < count; i++) {\n      const r2 = x * x + y * y; // squared distance in the image projected by the pinhole model\n      const k_inv = 1 / (1 + k1 * r2 + k2 * r2 * r2 + k3 * r2 * r2 * r2);\n      const delta_x = 2 * p1 * x * y + p2 * (r2 + 2 * x * x);\n      const delta_y = p1 * (r2 + 2 * y * y) + 2 * p2 * x * y;\n      x = (x0 - delta_x) * k_inv;\n      y = (y0 - delta_y) * k_inv;\n    }\n\n    out.x = x * fx + cx;\n    out.y = y * fy + cy;\n    return out;\n  }\n\n  /**\n   * Unrectifies the given 2D pixel coordinate.\n   *\n   * @param out - The output unrectified 2D pixel coordinate\n   * @param point - The input rectified 2D pixel coordinate\n   * @returns The unrectified pixel, a reference to `out`\n   */\n  public unrectifyPixel(out: Vector2, point: Readonly<Vector2>): Vector2 {\n    if (!this.P) {\n      out.x = point.x;\n      out.y = point.y;\n      return out;\n    }\n\n    const { P, R, D, K } = this;\n    const fx = P[0];\n    const fy = P[5];\n    const cx = P[2];\n    const cy = P[6];\n    const tx = P[3];\n    const ty = P[7];\n\n    // Formulae from docs for cv::initUndistortRectifyMap,\n    // <https://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html>\n\n    // x <- (u - c'x) / f'x\n    // y <- (v - c'y) / f'y\n    // c'x, f'x, etc. (primed) come from \"new camera matrix\" P[0:3, 0:3].\n    const x1 = (point.x - cx - tx) / fx;\n    const y1 = (point.y - cy - ty) / fy;\n    // [X Y W]^T <- R^-1 * [x y 1]^T\n    const X = R[0] * x1 + R[1] * y1 + R[2];\n    const Y = R[3] * x1 + R[4] * y1 + R[5];\n    const W = R[6] * x1 + R[7] * y1 + R[8];\n    const xp = X / W;\n    const yp = Y / W;\n\n    // x'' <- x'(1+k1*r^2+k2*r^4+k3*r^6) + 2p1*x'*y' + p2(r^2+2x'^2)\n    // y'' <- y'(1+k1*r^2+k2*r^4+k3*r^6) + p1(r^2+2y'^2) + 2p2*x'*y'\n    // where r^2 = x'^2 + y'^2\n    const r2 = xp * xp + yp * yp;\n    const r4 = r2 * r2;\n    const r6 = r4 * r2;\n    const a1 = 2 * xp * yp;\n    const k1 = D[0]!;\n    const k2 = D[1]!;\n    const p1 = D[2]!;\n    const p2 = D[3]!;\n    const k3 = D[4]!;\n    let barrel_correction = 1 + k1 * r2 + k2 * r4 + k3 * r6;\n    barrel_correction /= 1.0 + D[5] * r2 + D[6] * r4 + D[7] * r6;\n    const xpp = xp * barrel_correction + p1 * a1 + p2 * (r2 + 2 * (xp * xp));\n    const ypp = yp * barrel_correction + p1 * (r2 + 2 * (yp * yp)) + p2 * a1;\n\n    // map_x(u,v) <- x''fx + cx\n    // map_y(u,v) <- y''fy + cy\n    // cx, fx, etc. come from original camera matrix K.\n    out.x = xpp * K[0] + K[2];\n    out.y = ypp * K[4] + K[5];\n    return out;\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { indexToIDColor } from \"./util\";\n\n/**\n * This wraps a canvas rendering context to also render all context commands in parallel\n * to a separate hitmap context.\n */\nexport class HitmapRenderContext {\n  private _currentMarkerIndex: number = 0;\n  private readonly _hctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D | undefined;\n\n  public constructor(\n    private readonly _ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D,\n    private readonly _hitmapCanvas: HTMLCanvasElement | OffscreenCanvas | undefined,\n  ) {\n    this._hctx = (this._hitmapCanvas?.getContext(\"2d\") ?? undefined) as\n      | CanvasRenderingContext2D\n      | OffscreenCanvasRenderingContext2D\n      | undefined;\n    if (this._hctx) {\n      this._hctx.imageSmoothingEnabled = false;\n      this._hctx.clearRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);\n    }\n  }\n\n  public startMarker(): void {\n    if (this._hctx) {\n      const colorString = indexToIDColor(this._currentMarkerIndex);\n      this._hctx.fillStyle = `#${colorString}ff`;\n      this._hctx.strokeStyle = `#${colorString}ff`;\n    }\n    this._currentMarkerIndex++;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public get lineWidth(): number {\n    return this._ctx.lineWidth;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public set lineWidth(width: number) {\n    this._ctx.lineWidth = width;\n    if (this._hctx) {\n      this._hctx.lineWidth = width;\n    }\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public get fillStyle(): CanvasRenderingContext2D[\"fillStyle\"] {\n    return this._ctx.fillStyle;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public set fillStyle(style: CanvasRenderingContext2D[\"fillStyle\"]) {\n    this._ctx.fillStyle = style;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public get font(): string {\n    return this._ctx.font;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public set font(font: string) {\n    this._ctx.font = font;\n    if (this._hctx) {\n      this._hctx.font = font;\n    }\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public get strokeStyle(): CanvasRenderingContext2D[\"strokeStyle\"] {\n    return this._ctx.strokeStyle;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public set strokeStyle(style: CanvasRenderingContext2D[\"strokeStyle\"]) {\n    this._ctx.strokeStyle = style;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public get textBaseline(): CanvasRenderingContext2D[\"textBaseline\"] {\n    return this._ctx.textBaseline;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  public set textBaseline(baseline: CanvasRenderingContext2D[\"textBaseline\"]) {\n    this._ctx.textBaseline = baseline;\n    if (this._hctx) {\n      this._hctx.textBaseline = baseline;\n    }\n  }\n\n  public arc(\n    x: number,\n    y: number,\n    radius: number,\n    startAngle: number,\n    endAngle: number,\n    // eslint-disable-next-line @foxglove/no-boolean-parameters\n    counterclockwise?: boolean,\n  ): void {\n    this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise);\n    this._hctx?.arc(x, y, radius, startAngle, endAngle, counterclockwise);\n  }\n\n  public beginPath(): void {\n    this._ctx.beginPath();\n    this._hctx?.beginPath();\n  }\n\n  public clearRect(x: number, y: number, w: number, h: number): void {\n    this._ctx.clearRect(x, y, w, h);\n    this._hctx?.clearRect(x, y, w, h);\n  }\n\n  public closePath(): void {\n    this._ctx.closePath();\n    this._hctx?.closePath();\n  }\n\n  public drawImage(image: CanvasImageSource, dx: number, dy: number): void {\n    // Don't draw into hit context.\n    this._ctx.drawImage(image, dx, dy);\n  }\n\n  public fill(): void {\n    this._ctx.fill();\n    this._hctx?.fill();\n  }\n\n  public fillRect(x: number, y: number, w: number, h: number): void {\n    this._ctx.fillRect(x, y, w, h);\n    this._hctx?.fillRect(x, y, w, h);\n  }\n\n  public fillText(text: string, x: number, y: number): void {\n    this._ctx.fillText(text, x, y);\n    this._hctx?.fillText(text, x, y);\n  }\n\n  public getTransform(): DOMMatrix {\n    return this._ctx.getTransform();\n  }\n\n  public lineTo(x: number, y: number): void {\n    this._ctx.lineTo(x, y);\n    this._hctx?.lineTo(x, y);\n  }\n\n  public measureText(text: string): TextMetrics {\n    return this._ctx.measureText(text);\n  }\n\n  public moveTo(x: number, y: number): void {\n    this._ctx.moveTo(x, y);\n    this._hctx?.moveTo(x, y);\n  }\n\n  public restore(): void {\n    this._ctx.restore();\n    this._hctx?.restore();\n  }\n\n  public rotate(angle: number): void {\n    const rads = (angle * Math.PI) / 180;\n    this._ctx.rotate(rads);\n    this._hctx?.rotate(rads);\n  }\n\n  public save(): void {\n    this._ctx.save();\n    this._hctx?.save();\n  }\n\n  public scale(x: number, y: number): void {\n    this._ctx.scale(x, y);\n    this._hctx?.scale(x, y);\n  }\n\n  public stroke(): void {\n    this._ctx.stroke();\n    this._hctx?.stroke();\n  }\n\n  public strokeRect(x: number, y: number, w: number, h: number): void {\n    this._ctx.strokeRect(x, y, w, h);\n    this._hctx?.strokeRect(x, y, w, h);\n  }\n\n  public translate(x: number, y: number): void {\n    this._ctx.translate(x, y);\n    this._hctx?.translate(x, y);\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n//\n// This file incorporates work covered by the following copyright and\n// permission notice:\n//\n//   Copyright 2018-2021 Cruise LLC\n//\n//   This source code is licensed under the Apache License, Version 2.0,\n//   found at http://www.apache.org/licenses/LICENSE-2.0\n//   You may not use this file except in compliance with the License.\n\nimport {\n  PinholeCameraModel,\n  decodeYUV,\n  decodeYUYV,\n  decodeRGB8,\n  decodeRGBA8,\n  decodeBGRA8,\n  decodeBGR8,\n  decodeFloat1c,\n  decodeBayerRGGB8,\n  decodeBayerBGGR8,\n  decodeBayerGBRG8,\n  decodeBayerGRBG8,\n  decodeMono8,\n  decodeMono16,\n} from \"@foxglove/den/image\";\nimport { Color, Point2D } from \"@foxglove/studio-base/types/Messages\";\nimport sendNotification from \"@foxglove/studio-base/util/sendNotification\";\n\nimport { HitmapRenderContext } from \"./HitmapRenderContext\";\nimport { buildMarkerData, calculateZoomScale } from \"./util\";\nimport type {\n  MarkerData,\n  PanZoom,\n  RenderableCanvas,\n  RenderArgs,\n  RenderDimensions,\n  RenderGeometry,\n  RenderOptions,\n  Annotation,\n  CircleAnnotation,\n  PointsAnnotation,\n  TextAnnotation,\n  NormalizedImageMessage,\n} from \"../types\";\n\n// Just globally keep track of if we've shown an error in rendering, since typically when you get\n// one error, you'd then get a whole bunch more, which is spammy.\nlet hasLoggedCameraModelError: boolean = false;\n\n// Size threshold below which we do fast point rendering as rects.\n// Empirically 3 seems like a good threshold here.\nconst FAST_POINT_SIZE_THRESHOlD = 3;\n\n// Given a canvas, an image message, and marker info, render the image to the canvas.\nexport async function renderImage({\n  canvas,\n  hitmapCanvas,\n  geometry,\n  imageMessage,\n  rawMarkerData,\n  options,\n}: RenderArgs & { canvas: RenderableCanvas; hitmapCanvas: RenderableCanvas | undefined }): Promise<\n  RenderDimensions | undefined\n> {\n  if (!imageMessage) {\n    clearCanvas(canvas);\n    return undefined;\n  }\n\n  const { imageSmoothing = false } = options ?? {};\n\n  let markerData = undefined;\n  try {\n    markerData = buildMarkerData(rawMarkerData);\n  } catch (error) {\n    if (!hasLoggedCameraModelError) {\n      sendNotification(`Failed to initialize camera model from CameraInfo`, error, \"user\", \"warn\");\n      hasLoggedCameraModelError = true;\n    }\n  }\n\n  try {\n    const bitmap = await decodeMessageToBitmap(imageMessage, options);\n\n    if (options?.resizeCanvas === true) {\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n    }\n\n    const dimensions = render({\n      canvas,\n      geometry,\n      hitmapCanvas,\n      bitmap,\n      imageSmoothing,\n      markerData,\n    });\n    bitmap.close();\n    return dimensions;\n  } catch (error) {\n    // If there is an error, clear the image and re-throw it.\n    clearCanvas(canvas);\n    throw error;\n  }\n}\n\nfunction toRGBA(color: Color) {\n  return `rgba(${color.r * 255}, ${color.g * 255}, ${color.b * 255}, ${color.a})`;\n}\n\nfunction maybeUnrectifyPixel(cameraModel: PinholeCameraModel | undefined, point: Point2D): Point2D {\n  return cameraModel?.unrectifyPixel({ x: 0, y: 0 }, point) ?? point;\n}\n\n// Potentially performance-sensitive; await can be expensive\n// eslint-disable-next-line @typescript-eslint/promise-function-async\nfunction decodeMessageToBitmap(\n  imageMessage: NormalizedImageMessage,\n  options: RenderOptions = {},\n): Promise<ImageBitmap> {\n  const { data: rawData } = imageMessage;\n  if (!(rawData instanceof Uint8Array)) {\n    throw new Error(\"Message must have data of type Uint8Array\");\n  }\n\n  switch (imageMessage.type) {\n    case \"compressed\": {\n      const image = new Blob([rawData], { type: `image/${imageMessage.format}` });\n      return self.createImageBitmap(image);\n    }\n    case \"raw\": {\n      const { is_bigendian, width, height, encoding } = imageMessage;\n      const image = new ImageData(width, height);\n      switch (encoding) {\n        case \"yuv422\":\n          decodeYUV(rawData as unknown as Int8Array, width, height, image.data);\n          break;\n        // same thing as yuv422, but a distinct decoding from yuv422 and yuyv\n        case \"uyuv\":\n          decodeYUV(rawData as unknown as Int8Array, width, height, image.data);\n          break;\n        // change name in the future\n        case \"yuyv\":\n          decodeYUYV(rawData as unknown as Int8Array, width, height, image.data);\n          break;\n        case \"rgb8\":\n          decodeRGB8(rawData, width, height, image.data);\n          break;\n        case \"rgba8\":\n          decodeRGBA8(rawData, width, height, image.data);\n          break;\n        case \"bgra8\":\n          decodeBGRA8(rawData, width, height, image.data);\n          break;\n        case \"bgr8\":\n        case \"8UC3\":\n          decodeBGR8(rawData, width, height, image.data);\n          break;\n        case \"32FC1\":\n          decodeFloat1c(rawData, width, height, is_bigendian, image.data);\n          break;\n        case \"bayer_rggb8\":\n          decodeBayerRGGB8(rawData, width, height, image.data);\n          break;\n        case \"bayer_bggr8\":\n          decodeBayerBGGR8(rawData, width, height, image.data);\n          break;\n        case \"bayer_gbrg8\":\n          decodeBayerGBRG8(rawData, width, height, image.data);\n          break;\n        case \"bayer_grbg8\":\n          decodeBayerGRBG8(rawData, width, height, image.data);\n          break;\n        case \"mono8\":\n        case \"8UC1\":\n          decodeMono8(rawData, width, height, image.data);\n          break;\n        case \"mono16\":\n        case \"16UC1\":\n          decodeMono16(rawData, width, height, is_bigendian, image.data, options);\n          break;\n        default:\n          throw new Error(`Unsupported encoding ${encoding}`);\n      }\n      return self.createImageBitmap(image);\n    }\n  }\n}\n\nfunction clearCanvas(canvas?: RenderableCanvas) {\n  if (canvas) {\n    // https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1480\n    (\n      canvas.getContext(\"2d\") as\n        | CanvasRenderingContext2D\n        | OffscreenCanvasRenderingContext2D\n        | undefined\n    )?.clearRect(0, 0, canvas.width, canvas.height);\n  }\n}\n\nfunction render({\n  bitmap,\n  canvas,\n  geometry,\n  hitmapCanvas,\n  imageSmoothing,\n  markerData,\n}: {\n  bitmap: ImageBitmap;\n  canvas: RenderableCanvas;\n  geometry: RenderGeometry;\n  hitmapCanvas: RenderableCanvas | undefined;\n  imageSmoothing: boolean;\n  markerData: MarkerData | undefined;\n}): RenderDimensions | undefined {\n  const bitmapDimensions =\n    geometry.rotation % 180 === 0\n      ? { width: bitmap.width, height: bitmap.height }\n      : { width: bitmap.height, height: bitmap.width };\n\n  const canvasCtx = canvas.getContext(\"2d\") as  // https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/1480\n    | CanvasRenderingContext2D\n    | OffscreenCanvasRenderingContext2D\n    | undefined;\n  if (!canvasCtx) {\n    return;\n  }\n\n  canvasCtx.imageSmoothingEnabled = imageSmoothing;\n\n  const { markers = [], cameraModel } = markerData ?? {};\n\n  const viewportW = canvas.width;\n  const viewportH = canvas.height;\n\n  const imageViewportScale = calculateZoomScale(bitmapDimensions, canvas, geometry.zoomMode);\n\n  const ctx = new HitmapRenderContext(canvasCtx, hitmapCanvas);\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  ctx.save();\n\n  // translate x/y from the center of the canvas\n  ctx.translate(viewportW / 2, viewportH / 2);\n  ctx.translate(geometry.panZoom.x, geometry.panZoom.y);\n\n  ctx.scale(geometry.panZoom.scale, geometry.panZoom.scale);\n  ctx.scale(imageViewportScale, imageViewportScale);\n\n  if (geometry.flipHorizontal) {\n    ctx.scale(-1, 1);\n  }\n\n  if (geometry.flipVertical) {\n    ctx.scale(1, -1);\n  }\n\n  ctx.rotate(geometry.rotation);\n\n  // center the image in the viewport\n  // also sets 0,0 as the upper left corner of the image since markers are drawn from 0,0 on the image\n  ctx.translate(-bitmap.width / 2, -bitmap.height / 2);\n\n  ctx.drawImage(bitmap, 0, 0);\n\n  // The bitmap images from the image message may be resized to conserve space\n  // while the markers are positioned relative to the original image size.\n  // Original width/height are the image dimensions for the marker positions\n  // These dimensions are used to scale the markers positions separately from the bitmap size\n  const { originalWidth = bitmap.width, originalHeight = bitmap.height } = markerData ?? {};\n  ctx.scale(bitmap.width / originalWidth, bitmap.height / originalHeight);\n  const transform = ctx.getTransform();\n\n  try {\n    paintMarkers(ctx, markers, cameraModel, geometry.panZoom);\n  } catch (err) {\n    console.warn(\"error painting markers:\", err);\n  } finally {\n    ctx.restore();\n  }\n\n  return { ...bitmapDimensions, transform };\n}\n\nfunction paintMarkers(\n  ctx: HitmapRenderContext,\n  annotations: readonly Annotation[],\n  cameraModel: PinholeCameraModel | undefined,\n  panZoom: PanZoom,\n) {\n  for (const annotation of annotations) {\n    ctx.save();\n    try {\n      ctx.startMarker();\n\n      switch (annotation.type) {\n        case \"circle\":\n          paintCircleAnnotation(ctx, annotation, cameraModel);\n          break;\n        case \"points\":\n          paintPointsAnnotation(ctx, annotation, cameraModel, panZoom);\n          break;\n        case \"text\":\n          paintTextAnnotation(ctx, annotation, cameraModel);\n          break;\n      }\n    } catch (err) {\n      console.error(\"Unable to paint annotation to ImageView\", err, annotation);\n    } finally {\n      ctx.restore();\n    }\n  }\n}\n\nfunction paintLine(\n  ctx: HitmapRenderContext,\n  pointA: Point2D,\n  pointB: Point2D,\n  thickness: number,\n  outlineColor: Color,\n  cameraModel: PinholeCameraModel | undefined,\n) {\n  if (thickness <= 0 || outlineColor.a <= 0) {\n    return;\n  }\n\n  const { x: x1, y: y1 } = maybeUnrectifyPixel(cameraModel, pointA);\n  const { x: x2, y: y2 } = maybeUnrectifyPixel(cameraModel, pointB);\n\n  ctx.beginPath();\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n\n  ctx.lineWidth = thickness;\n  ctx.strokeStyle = toRGBA(outlineColor);\n  ctx.stroke();\n}\n\nfunction paintTextAnnotation(\n  ctx: HitmapRenderContext,\n  annotation: TextAnnotation,\n  cameraModel: PinholeCameraModel | undefined,\n) {\n  const { x, y } = maybeUnrectifyPixel(cameraModel, annotation.position);\n  const text = annotation.text;\n  if (!text) {\n    return;\n  }\n\n  const fontSize = annotation.fontSize;\n  const padding = annotation.padding;\n  ctx.font = `${fontSize}px sans-serif`;\n  ctx.textBaseline = \"bottom\";\n  if (annotation.backgroundColor) {\n    const metrics = ctx.measureText(text);\n    const height =\n      \"fontBoundingBoxAscent\" in metrics\n        ? metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent\n        : fontSize * 1.2;\n    ctx.fillStyle = toRGBA(annotation.backgroundColor);\n    ctx.fillRect(x, y - height, Math.ceil(metrics.width + 2 * padding), Math.ceil(height));\n  }\n  ctx.fillStyle = toRGBA(annotation.textColor);\n  ctx.fillText(text, x + padding, y);\n}\n\nfunction paintCircleAnnotation(\n  ctx: HitmapRenderContext,\n  annotation: CircleAnnotation,\n  cameraModel: PinholeCameraModel | undefined,\n) {\n  const { fillColor, outlineColor, radius, thickness, position } = annotation;\n\n  // perf-sensitive: function params instead of options object to avoid allocations\n  const hasFill = fillColor != undefined && fillColor.a > 0;\n  const hasStroke = outlineColor != undefined && outlineColor.a > 0 && thickness > 0;\n\n  if (radius <= 0 || (!hasFill && !hasStroke)) {\n    return;\n  }\n\n  const { x, y } = maybeUnrectifyPixel(cameraModel, position);\n  ctx.beginPath();\n  ctx.arc(x, y, radius, 0, 2 * Math.PI);\n\n  if (hasFill) {\n    ctx.fillStyle = toRGBA(fillColor);\n    ctx.fill();\n  }\n\n  if (hasStroke) {\n    ctx.lineWidth = thickness;\n    ctx.strokeStyle = toRGBA(outlineColor);\n    ctx.stroke();\n  }\n}\n\nfunction paintPointsAnnotation(\n  ctx: HitmapRenderContext,\n  annotation: PointsAnnotation,\n  cameraModel: PinholeCameraModel | undefined,\n  panZoom: PanZoom,\n) {\n  switch (annotation.style) {\n    case \"points\": {\n      for (let i = 0; i < annotation.points.length; i++) {\n        const point = annotation.points[i]!;\n        // This is not a typo. ImageMarker has an array for outline_colors but\n        // not fill_colors, even though points are filled and not outlined. We\n        // only fall back to fill_color if both outline_colors[i] and\n        // outline_color are fully transparent\n        const pointOutlineColor = annotation.outlineColors[i];\n        const fillColor = pointOutlineColor\n          ? pointOutlineColor\n          : annotation.outlineColor && annotation.outlineColor.a > 0\n          ? annotation.outlineColor\n          : annotation.fillColor;\n\n        // For points small enough to be visually indistinct at our current zoom level\n        // we do a fast render.\n        const size = annotation.thickness * panZoom.scale;\n        if (size <= FAST_POINT_SIZE_THRESHOlD) {\n          paintFastPoint(\n            ctx,\n            point,\n            annotation.thickness,\n            annotation.thickness,\n            undefined,\n            fillColor,\n            cameraModel,\n          );\n        } else {\n          paintCircle(\n            ctx,\n            point,\n            annotation.thickness,\n            annotation.thickness,\n            undefined,\n            fillColor,\n            cameraModel,\n          );\n        }\n      }\n      break;\n    }\n    case \"polygon\":\n    case \"line_strip\": {\n      if (annotation.points.length === 0) {\n        break;\n      }\n      ctx.beginPath();\n      const { x, y } = maybeUnrectifyPixel(cameraModel, annotation.points[0]!);\n      ctx.moveTo(x, y);\n      for (let i = 1; i < annotation.points.length; i++) {\n        const maybeUnrectifiedPoint = maybeUnrectifyPixel(cameraModel, annotation.points[i]!);\n        ctx.lineTo(maybeUnrectifiedPoint.x, maybeUnrectifiedPoint.y);\n      }\n      if (annotation.style === \"polygon\") {\n        ctx.closePath();\n        if (annotation.fillColor && annotation.fillColor.a > 0) {\n          ctx.fillStyle = toRGBA(annotation.fillColor);\n          ctx.fill();\n        }\n      }\n      if (annotation.outlineColor && annotation.outlineColor.a > 0 && annotation.thickness > 0) {\n        ctx.strokeStyle = toRGBA(annotation.outlineColor);\n        ctx.lineWidth = annotation.thickness;\n        ctx.stroke();\n      }\n      break;\n    }\n    case \"line_list\": {\n      const hasExactColors = annotation.outlineColors.length === annotation.points.length / 2;\n\n      for (let i = 0; i < annotation.points.length; i += 2) {\n        // Support the case where outline_colors is half the length of points,\n        // one color per line, and where outline_colors matches the length of\n        // points (although we only use the first color in this case). Fall back\n        // to marker.outline_color as needed\n        const outlineColor = hasExactColors\n          ? annotation.outlineColors[i / 2]!\n          : annotation.outlineColors.length > i\n          ? annotation.outlineColors[i]!\n          : annotation.outlineColor;\n        paintLine(\n          ctx,\n          annotation.points[i]!,\n          annotation.points[i + 1]!,\n          annotation.thickness,\n          outlineColor ?? { r: 0, g: 0, b: 0, a: 1 },\n          cameraModel,\n        );\n      }\n\n      break;\n    }\n  }\n}\n\nfunction paintCircle(\n  ctx: HitmapRenderContext,\n  point: Point2D,\n  radius: number,\n  thickness: number,\n  outlineColor: Color | undefined,\n  fillColor: Color | undefined,\n  cameraModel: PinholeCameraModel | undefined,\n) {\n  // perf-sensitive: function params instead of options object to avoid allocations\n  const hasFill = fillColor != undefined && fillColor.a > 0;\n  const hasStroke = outlineColor != undefined && outlineColor.a > 0 && thickness > 0;\n\n  if (radius <= 0 || (!hasFill && !hasStroke)) {\n    return;\n  }\n\n  const { x, y } = maybeUnrectifyPixel(cameraModel, point);\n  ctx.beginPath();\n  ctx.arc(x, y, radius, 0, 2 * Math.PI);\n\n  if (hasFill) {\n    ctx.fillStyle = toRGBA(fillColor);\n    ctx.fill();\n  }\n\n  if (hasStroke) {\n    ctx.lineWidth = thickness;\n    ctx.strokeStyle = toRGBA(outlineColor);\n    ctx.stroke();\n  }\n}\n\n/**\n * Renders small points as rectangles instead of circles for better performance.\n */\nfunction paintFastPoint(\n  ctx: HitmapRenderContext,\n  point: Point2D,\n  radius: number,\n  thickness: number,\n  outlineColor: Color | undefined,\n  fillColor: Color | undefined,\n  cameraModel: PinholeCameraModel | undefined,\n) {\n  // perf-sensitive: function params instead of options object to avoid allocations\n  const hasFill = fillColor != undefined && fillColor.a > 0;\n  const hasStroke = outlineColor != undefined && outlineColor.a > 0 && thickness > 0;\n\n  if (radius <= 0 || (!hasFill && !hasStroke)) {\n    return;\n  }\n\n  const { x, y } = maybeUnrectifyPixel(cameraModel, point);\n  const size = Math.round(radius * 2);\n  const rx = Math.round(x - size / 2);\n  const ry = Math.round(y - size / 2);\n\n  if (hasFill) {\n    ctx.fillStyle = toRGBA(fillColor);\n    ctx.fillRect(rx, ry, size, size);\n  }\n\n  if (hasStroke) {\n    ctx.lineWidth = thickness;\n    ctx.strokeStyle = toRGBA(outlineColor);\n    ctx.strokeRect(rx, ry, size, size);\n  }\n}\n"],"names":["yuvToRGBA8","y1","u","y2","v","c","output","decodeYUV","yuv","width","height","off","max","r","decodeYUYV","yuyv","decodeRGB8","rgb","inIdx","outIdx","i","g","b","decodeRGBA8","rgba","a","decodeBGRA8","decodeBGR8","bgr","decodeFloat1c","gray","is_bigendian","view","val","decodeMono8","mono8","ch","decodeMono16","mono16","options","minValue","maxValue","makeSpecializedDecodeBayer","tl","tr","bl","br","decodeBayerRGGB8","decodeBayerBGGR8","decodeBayerGBRG8","decodeBayerGRBG8","PinholeCameraModel","info","binning_x","binning_y","roi","model","D","K","P","R","fx","fy","D8","binningX","binningY","adjustBinning","adjustRoi","out","pixel","cx","cy","tx","ty","invNorm","point","iterations","k1","k2","p1","p2","k3","x","y","x0","y0","count","r2","k_inv","delta_x","delta_y","x1","X","Y","W","xp","yp","r4","r6","a1","barrel_correction","xpp","ypp","HitmapRenderContext","_ctx","_hitmapCanvas","colorString","style","font","baseline","radius","startAngle","endAngle","counterclockwise","w","h","image","dx","dy","text","angle","rads","hasLoggedCameraModelError","FAST_POINT_SIZE_THRESHOlD","renderImage","canvas","hitmapCanvas","geometry","imageMessage","rawMarkerData","clearCanvas","imageSmoothing","markerData","error","sendNotification","bitmap","decodeMessageToBitmap","dimensions","render","toRGBA","color","maybeUnrectifyPixel","cameraModel","rawData","encoding","bitmapDimensions","canvasCtx","markers","viewportW","viewportH","imageViewportScale","ctx","originalWidth","originalHeight","transform","paintMarkers","err","annotations","panZoom","annotation","paintCircleAnnotation","paintPointsAnnotation","paintTextAnnotation","paintLine","pointA","pointB","thickness","outlineColor","x2","fontSize","padding","metrics","fillColor","position","hasFill","hasStroke","pointOutlineColor","paintFastPoint","paintCircle","maybeUnrectifiedPoint","hasExactColors","size","rx","ry"],"sourceRoot":""}