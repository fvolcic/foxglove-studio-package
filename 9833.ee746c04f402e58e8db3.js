"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9833],{39833:(S,O,d)=>{d.d(O,{W:()=>u});var v=d(11168),D=d.n(v),T=d(18458),b=d(17417),j=d(92897),m=d(62098),h=d(89389),t=d(98357);function i(e){switch(e){case t.rB.Bool:return"bool";case t.rB.Byte:return"int8";case t.rB.UType:case t.rB.UByte:return"uint8";case t.rB.Short:return"int16";case t.rB.UShort:return"uint16";case t.rB.Int:return"int32";case t.rB.UInt:return"uint32";case t.rB.Long:return"int64";case t.rB.ULong:return"uint64";case t.rB.Float:return"float32";case t.rB.Double:return"float64";case t.rB.String:return"string";case t.rB.Vector:case t.rB.Obj:case t.rB.Union:case t.rB.Array:throw new Error(`${e} is not a simple type.`);case t.rB.None:case t.rB.MaxBaseType:throw new Error("None is not a valid type.")}}function p(e){if(typeof e=="string")return e;throw new Error(`Expected string, found ${typeof e}`)}function g(e,s){const r=[];switch(s.type?.baseType){case t.rB.UType:case t.rB.Bool:case t.rB.Byte:case t.rB.UByte:case t.rB.Short:case t.rB.UShort:case t.rB.Int:case t.rB.UInt:case t.rB.Long:case t.rB.ULong:case t.rB.Float:case t.rB.Double:case t.rB.String:case t.rB.None:{const n=i(s.type.baseType);if(s.type.index!==-1){const a=e.enums[s.type.index]?.values;if(a==null)throw new Error(`Invalid schema, missing enum values for field type ${e.enums[s.type.index]?.name}`);for(const c of a)r.push({name:p(c.name),type:n,isConstant:!0,value:c.value})}r.push({name:p(s.name),type:n});break}case t.rB.Vector:switch(s.type.element){case t.rB.Vector:case t.rB.Union:case t.rB.Array:case t.rB.None:throw new Error("Vectors of vectors, unions, arrays, and None's are unsupported.");case t.rB.Obj:r.push({name:p(s.name),type:p(e.objects[s.type.index]?.name),isComplex:!0,isArray:!0});break;default:{const n=i(s.type.element);if(s.type.index!==-1){const a=e.enums[s.type.index]?.values;if(a==null)throw new Error("Invalid schema");for(const c of a)r.push({name:p(c.name),type:n,isConstant:!0,value:c.value})}r.push({name:p(s.name),type:n,isArray:!0});break}}break;case t.rB.Obj:r.push({name:p(s.name),type:p(e.objects[s.type.index]?.name),isComplex:!0});break;case t.rB.Union:case t.rB.Array:case t.rB.MaxBaseType:case void 0:throw new Error("Unions and Arrays are not supported in mcap-support currently.")}return r}function w(e,s){const r=new Map,n=new h.cZ(s),a=t.V_.getRootAsSchema(n),c=a.unpack();let l=-1;for(let B=0;B<c.objects.length;++B){const E=c.objects[B];E?.name===e&&(l=B);let A=[];if(E?.fields!=null){for(const U of E.fields)A=A.concat(g(c,U));r.set(p(E.name),{definitions:A})}}if(l===-1&&c.rootTable?.name!==e)throw new Error(`Type "${e}" is not available in the schema for "${c.rootTable?.name}".`);const $=new t._b(a);return{datatypes:r,deserialize:B=>{const E=new h.cZ(new Uint8Array(B.buffer,B.byteOffset,B.byteLength)),A=new t.iA(E,l,E.readInt32(E.position())+E.position());return $.toObject(A)}}}var f=d(21509),o=d(25673);function y(e,s){const r=new Map;return e.forEach(({name:n,definitions:a},c)=>{c===0?r.set(s,{name:s,definitions:a}):n!=null&&r.set(n,{name:n,definitions:a})}),r}function u(e){if(e.messageEncoding==="json"){if(e.schema!=null&&e.schema.encoding!=="jsonschema")throw new Error(`Message encoding ${e.messageEncoding} with schema encoding '${e.schema.encoding}' is not supported (expected jsonschema or no schema)`);const s=new TextDecoder;let r=new Map,n=a=>JSON.parse(s.decode(a));if(e.schema!=null){const a=e.schema.data.length>0?JSON.parse(s.decode(e.schema.data)):void 0;if(a!=null){if(typeof a!="object")throw new Error(`Invalid schema, expected JSON object, got ${typeof a}`);const{datatypes:c,postprocessValue:l}=(0,f.h)(a,e.schema.name);r=c,n=$=>l(JSON.parse(s.decode($)))}}return{deserialize:n,datatypes:r}}if(e.messageEncoding==="flatbuffer"){if(e.schema?.encoding!=="flatbuffer")throw new Error(`Message encoding ${e.messageEncoding} with ${e.schema==null?"no encoding":`schema encoding '${e.schema.encoding}'`} is not supported (expected flatbuffer)`);return w(e.schema.name,e.schema.data)}if(e.messageEncoding==="protobuf"){if(e.schema?.encoding!=="protobuf")throw new Error(`Message encoding ${e.messageEncoding} with ${e.schema==null?"no encoding":`schema encoding '${e.schema.encoding}'`} is not supported (expected protobuf)`);const s=T.FileDescriptorSet.decode(e.schema.data);for(const l of s.file)if(l.package==="google.protobuf"){for(const $ of l.messageType??[])if($.name==="Timestamp"||$.name==="Duration")for(const x of $.field??[])x.name==="seconds"?x.name="sec":x.name==="nanos"&&(x.name="nsec")}const r=D().Root.fromDescriptor(s);r.resolveAll();const n=r.lookupType(e.schema.name),a=l=>n.toObject(n.decode(new Uint8Array(l.buffer,l.byteOffset,l.byteLength)),{defaults:!0}),c=new Map;if((0,o.O)(c,n),!c.has(e.schema.name))throw new Error(`Protobuf schema does not contain an entry for '${e.schema.name}'. The schema name should be fully-qualified, e.g. '${(0,o.T)(n.fullName)}'.`);return{deserialize:a,datatypes:c}}if(e.messageEncoding==="ros1"){if(e.schema?.encoding!=="ros1msg")throw new Error(`Message encoding ${e.messageEncoding} with ${e.schema==null?"no encoding":`schema encoding '${e.schema.encoding}'`} is not supported (expected ros1msg)`);const s=new TextDecoder().decode(e.schema.data),r=(0,b.parse)(s),n=new j.MessageReader(r);return{datatypes:y(r,e.schema.name),deserialize:a=>n.readMessage(a)}}if(e.messageEncoding==="cdr"){if(e.schema?.encoding!=="ros2msg"&&e.schema?.encoding!=="ros2idl")throw new Error(`Message encoding ${e.messageEncoding} with ${e.schema==null?"no encoding":`schema encoding '${e.schema.encoding}'`} is not supported (expected "ros2msg" or "ros2idl")`);const s=new TextDecoder().decode(e.schema.data),n=e.schema.encoding==="ros2idl"?(0,b.parseRos2idl)(s):(0,b.parse)(s,{ros2:!0}),a=new m.MessageReader(n);return{datatypes:y(n,e.schema.name),deserialize:c=>a.readMessage(c)}}throw new Error(`Unsupported encoding ${e.messageEncoding}`)}},21509:(S,O,d)=>{d.d(O,{h:()=>T});var v=d(87026),D=d.n(v);function T(b,j){const m=new Map;function h(i,p,g){let w=o=>o;const f=[];if(i.type!=="object")throw new Error(`Expected "type": "object" for schema ${p}, got ${JSON.stringify(i.type)}`);for(const[o,y]of Object.entries(i.properties)){if(Array.isArray(y.oneOf))if(y.oneOf.every(u=>typeof u.const=="number")){for(const u of y.oneOf)f.push({name:u.title,type:"uint32",isConstant:!0,value:u.const});f.push({name:o,type:"uint32"});continue}else throw new Error(`Unsupported type for ${g.concat(o).join(".")}: oneOf alternatives must have number values`);switch(y.type){case"boolean":f.push({name:o,type:"bool"});break;case"string":switch(y.contentEncoding){case void 0:f.push({name:o,type:"string"});break;case"base64":{f.push({name:o,type:"uint8",isArray:!0});const u=w;w=e=>{const s=e[o];if(typeof s=="string"){const r=new Uint8Array(v.length(s));if(v.decode(s,r,0)!==r.byteLength)throw new Error(`Failed to decode base64 data for ${g.concat(o).join(".")}`);e[o]=r}return u(e)};break}default:throw new Error(`Unsupported contentEncoding ${JSON.stringify(y.contentEncoding)} in ${g.concat(o).join(".")}`)}break;case"number":case"integer":f.push({name:o,type:"float64"});break;case"object":{const u=`${p}.${o}`,e=h(y,u,g.concat(o)),s=w;w=r=>{const n=r[o];return n!=null&&typeof n=="object"&&(r[o]=e(n)),s(r)},f.push({name:o,type:u,isComplex:!0});break}case"array":{const u=y.items;switch(u.type){case"boolean":f.push({name:o,type:"bool",isArray:!0});break;case"string":if(u.contentEncoding!=null)throw new Error(`Unsupported contentEncoding ${JSON.stringify(u.contentEncoding)} for array item ${g.concat(o).join(".")}`);f.push({name:o,type:"string",isArray:!0});break;case"number":case"integer":f.push({name:o,type:"float64",isArray:!0});break;case"object":{const e=`${p}.${o}`,s=h(y.items,e,g.concat(o)),r=w;w=n=>{const a=n[o];return Array.isArray(a)&&(n[o]=a.map(s)),r(n)},f.push({name:o,type:e,isComplex:!0,isArray:!0});break}default:throw new Error(`Unsupported type ${JSON.stringify(u.type)} for array item ${g.concat(o).join(".")}`)}break}case"null":default:throw new Error(`Unsupported type ${JSON.stringify(y.type)} for ${g.concat(o).join(".")}`)}}return m.set(p,{definitions:f}),w}const t=h(b,j,[]);return{datatypes:m,postprocessValue:t}}},25673:(S,O,d)=>{d.d(O,{O:()=>j,T:()=>b});var v=d(11168),D=d.n(v);function T(m){switch(m){case"double":return"float64";case"float":return"float32";case"int32":case"sint32":case"sfixed32":return"int32";case"uint32":case"fixed32":return"uint32";case"int64":case"sint64":case"sfixed64":return"int64";case"uint64":case"fixed64":return"uint64";case"bool":return"bool";case"string":return"string"}throw new Error(`Expected protobuf scalar type, got ${m}`)}function b(m){return m.replace(/^\./,"")}function j(m,h){const t=[];m.set(b(h.fullName),{definitions:t});for(const i of h.fieldsArray)if(i.resolvedType instanceof D().Enum){for(const[p,g]of Object.entries(i.resolvedType.values))t.push({name:p,type:"int32",isConstant:!0,value:g});t.push({type:"int32",name:i.name})}else if(i.resolvedType){const p=b(i.resolvedType.fullName);t.push({type:p,name:i.name,isComplex:!0,isArray:i.repeated}),m.has(p)||j(m,i.resolvedType)}else if(i.type==="bytes"){if(i.repeated)throw new Error("Repeated bytes are not currently supported");t.push({type:"uint8",name:i.name,isArray:!0})}else t.push({type:T(i.type),name:i.name,isArray:i.repeated})}}}]);

//# sourceMappingURL=9833.ee746c04f402e58e8db3.js.map