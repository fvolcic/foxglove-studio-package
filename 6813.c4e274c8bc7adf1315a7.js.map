{"version":3,"file":"6813.c4e274c8bc7adf1315a7.js","mappings":"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","sources":["webpack:///../../packages/mcap-support/src/decompressHandlers.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/FileReadable.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIndexedIterableSource.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/McapStreamingIterableSource.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/RemoteFileReadable.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIterableSource.ts","webpack:///../../packages/studio-base/src/players/IterablePlayer/Mcap/McapIterableSourceWorker.worker.ts"],"sourcesContent":["// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { McapTypes } from \"@mcap/core\";\n\nlet handlersPromise: Promise<McapTypes.DecompressHandlers> | undefined;\nexport async function loadDecompressHandlers(): Promise<McapTypes.DecompressHandlers> {\n  return await (handlersPromise ??= _loadDecompressHandlers());\n}\n\n// eslint-disable-next-line no-underscore-dangle\nasync function _loadDecompressHandlers(): Promise<McapTypes.DecompressHandlers> {\n  const [decompressZstd, decompressLZ4, bzip2] = await Promise.all([\n    import(\"@foxglove/wasm-zstd\").then(async (mod) => {\n      await mod.isLoaded;\n      return mod.decompress;\n    }),\n    import(\"@foxglove/wasm-lz4\").then(async (mod) => {\n      await mod.default.isLoaded;\n      return mod.default;\n    }),\n    import(\"@foxglove/wasm-bz2\").then(async (mod) => await mod.default.init()),\n  ]);\n\n  return {\n    lz4: (buffer, decompressedSize) => decompressLZ4(buffer, Number(decompressedSize)),\n\n    bz2: (buffer, decompressedSize) =>\n      bzip2.decompress(buffer, Number(decompressedSize), { small: false }),\n\n    zstd: (buffer, decompressedSize) => decompressZstd(buffer, Number(decompressedSize)),\n  };\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nexport class FileReadable {\n  public constructor(private file: File) {}\n  public async size(): Promise<bigint> {\n    return BigInt(this.file.size);\n  }\n  public async read(offset: bigint, size: bigint): Promise<Uint8Array> {\n    if (offset + size > this.file.size) {\n      throw new Error(\n        `Read of ${size} bytes at offset ${offset} exceeds file size ${this.file.size}`,\n      );\n    }\n    return new Uint8Array(\n      await this.file.slice(Number(offset), Number(offset + size)).arrayBuffer(),\n    );\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { McapIndexedReader, McapTypes } from \"@mcap/core\";\n\nimport Logger from \"@foxglove/log\";\nimport { ParsedChannel, parseChannel } from \"@foxglove/mcap-support\";\nimport { Time, fromNanoSec, toNanoSec, compare } from \"@foxglove/rostime\";\nimport { MessageEvent } from \"@foxglove/studio\";\nimport {\n  GetBackfillMessagesArgs,\n  IIterableSource,\n  Initalization,\n  IteratorResult,\n  MessageIteratorArgs,\n} from \"@foxglove/studio-base/players/IterablePlayer/IIterableSource\";\nimport { PlayerProblem, Topic, TopicStats } from \"@foxglove/studio-base/players/types\";\nimport { RosDatatypes } from \"@foxglove/studio-base/types/RosDatatypes\";\n\nconst log = Logger.getLogger(__filename);\n\nexport class McapIndexedIterableSource implements IIterableSource {\n  private reader: McapIndexedReader;\n  private channelInfoById = new Map<\n    number,\n    { channel: McapTypes.Channel; parsedChannel: ParsedChannel; schemaName: string | undefined }\n  >();\n  private start?: Time;\n  private end?: Time;\n\n  public constructor(reader: McapIndexedReader) {\n    this.reader = reader;\n  }\n\n  public async initialize(): Promise<Initalization> {\n    let startTime: bigint | undefined;\n    let endTime: bigint | undefined;\n    for (const chunk of this.reader.chunkIndexes) {\n      if (startTime == undefined || chunk.messageStartTime < startTime) {\n        startTime = chunk.messageStartTime;\n      }\n      if (endTime == undefined || chunk.messageEndTime > endTime) {\n        endTime = chunk.messageEndTime;\n      }\n    }\n\n    const topicStats = new Map<string, TopicStats>();\n    const topicsByName = new Map<string, Topic>();\n    const datatypes: RosDatatypes = new Map();\n    const problems: PlayerProblem[] = [];\n    const publishersByTopic = new Map<string, Set<string>>();\n\n    for (const channel of this.reader.channelsById.values()) {\n      const schema = this.reader.schemasById.get(channel.schemaId);\n      if (channel.schemaId !== 0 && schema == undefined) {\n        problems.push({\n          severity: \"error\",\n          message: `Missing schema info for schema id ${channel.schemaId} (channel ${channel.id}, topic ${channel.topic})`,\n        });\n        continue;\n      }\n\n      let parsedChannel;\n      try {\n        parsedChannel = parseChannel({ messageEncoding: channel.messageEncoding, schema });\n      } catch (error) {\n        problems.push({\n          severity: \"error\",\n          message: `Error in topic ${channel.topic} (channel ${channel.id}): ${error.message}`,\n          error,\n        });\n        continue;\n      }\n      this.channelInfoById.set(channel.id, { channel, parsedChannel, schemaName: schema?.name });\n\n      let topic = topicsByName.get(channel.topic);\n      if (!topic) {\n        topic = { name: channel.topic, schemaName: schema?.name };\n        topicsByName.set(channel.topic, topic);\n\n        const numMessages = this.reader.statistics?.channelMessageCounts.get(channel.id);\n        if (numMessages != undefined) {\n          topicStats.set(channel.topic, { numMessages: Number(numMessages) });\n        }\n      }\n\n      // Track the publisher for this topic. \"callerid\" is defined in the MCAP ROS 1 Well-known\n      // profile at <https://mcap.dev/specification/appendix.html>. We skip the profile check to\n      // allow non-ROS profiles to utilize this functionality as well\n      const publisherId = channel.metadata.get(\"callerid\") ?? String(channel.id);\n      let publishers = publishersByTopic.get(channel.topic);\n      if (!publishers) {\n        publishers = new Set();\n        publishersByTopic.set(channel.topic, publishers);\n      }\n      publishers.add(publisherId);\n\n      // Final datatypes is an unholy union of schemas across all channels\n      for (const [name, datatype] of parsedChannel.datatypes) {\n        datatypes.set(name, datatype);\n      }\n    }\n\n    this.start = fromNanoSec(startTime ?? 0n);\n    this.end = fromNanoSec(endTime ?? startTime ?? 0n);\n\n    return {\n      start: this.start,\n      end: this.end,\n      topics: [...topicsByName.values()],\n      datatypes,\n      profile: this.reader.header.profile,\n      problems,\n      publishersByTopic,\n      topicStats,\n    };\n  }\n\n  public async *messageIterator(\n    args: MessageIteratorArgs,\n  ): AsyncIterableIterator<Readonly<IteratorResult>> {\n    const topics = args.topics;\n    const start = args.start ?? this.start;\n    const end = args.end ?? this.end;\n\n    if (topics.length === 0 || !start || !end) {\n      return;\n    }\n\n    for await (const message of this.reader.readMessages({\n      startTime: toNanoSec(start),\n      endTime: toNanoSec(end),\n      topics,\n    })) {\n      const channelInfo = this.channelInfoById.get(message.channelId);\n      if (!channelInfo) {\n        yield {\n          type: \"problem\",\n          problem: {\n            message: `Received message on channel ${message.channelId} without prior channel info`,\n            severity: \"error\",\n          },\n        };\n        continue;\n      }\n      try {\n        yield {\n          type: \"message-event\",\n          msgEvent: {\n            topic: channelInfo.channel.topic,\n            receiveTime: fromNanoSec(message.logTime),\n            publishTime: fromNanoSec(message.publishTime),\n            message: channelInfo.parsedChannel.deserialize(message.data),\n            sizeInBytes: message.data.byteLength,\n            schemaName: channelInfo.schemaName ?? \"\",\n          },\n        };\n      } catch (error) {\n        yield {\n          type: \"problem\",\n          problem: {\n            message: `Error decoding message on ${channelInfo.channel.topic}`,\n            error,\n            severity: \"error\",\n          },\n        };\n      }\n    }\n  }\n\n  public async getBackfillMessages(\n    args: GetBackfillMessagesArgs,\n  ): Promise<MessageEvent<unknown>[]> {\n    const { topics, time } = args;\n\n    const messages: MessageEvent<unknown>[] = [];\n    for (const topic of topics) {\n      // NOTE: An iterator is made for each topic to get the latest message on that topic.\n      // An single iterator for all the topics could result in iterating through many\n      // irrelevant messages to get to an older message on a topic.\n      for await (const message of this.reader.readMessages({\n        endTime: toNanoSec(time),\n        topics: [topic],\n        reverse: true,\n      })) {\n        const channelInfo = this.channelInfoById.get(message.channelId);\n        if (!channelInfo) {\n          log.error(`Missing channel info for channel: ${message.channelId} on topic: ${topic}`);\n          continue;\n        }\n\n        try {\n          messages.push({\n            topic: channelInfo.channel.topic,\n            receiveTime: fromNanoSec(message.logTime),\n            publishTime: fromNanoSec(message.publishTime),\n            message: channelInfo.parsedChannel.deserialize(message.data),\n            sizeInBytes: message.data.byteLength,\n            schemaName: channelInfo.schemaName ?? \"\",\n          });\n        } catch (err) {\n          log.error(err);\n        }\n\n        break;\n      }\n    }\n    messages.sort((a, b) => compare(a.receiveTime, b.receiveTime));\n    return messages;\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { McapStreamReader, McapTypes } from \"@mcap/core\";\nimport { isEqual } from \"lodash\";\n\nimport { loadDecompressHandlers, parseChannel, ParsedChannel } from \"@foxglove/mcap-support\";\nimport {\n  Time,\n  isLessThan,\n  isGreaterThan,\n  isTimeInRangeInclusive,\n  fromNanoSec,\n  subtract,\n  toSec,\n  toRFC3339String,\n  compare,\n} from \"@foxglove/rostime\";\nimport { MessageEvent } from \"@foxglove/studio\";\nimport {\n  GetBackfillMessagesArgs,\n  IIterableSource,\n  Initalization,\n  IteratorResult,\n  MessageIteratorArgs,\n} from \"@foxglove/studio-base/players/IterablePlayer/IIterableSource\";\nimport { PlayerProblem, Topic, TopicStats } from \"@foxglove/studio-base/players/types\";\nimport { RosDatatypes } from \"@foxglove/studio-base/types/RosDatatypes\";\n\nconst DURATION_YEAR_SEC = 365 * 24 * 60 * 60;\n\ntype Options = { size: number; stream: ReadableStream<Uint8Array> };\n\nexport class McapStreamingIterableSource implements IIterableSource {\n  private options: Options;\n  private msgEventsByChannel?: Map<number, MessageEvent<unknown>[]>;\n  private start?: Time;\n  private end?: Time;\n\n  public constructor(options: Options) {\n    this.options = options;\n  }\n\n  public async initialize(): Promise<Initalization> {\n    if (this.options.size > 1024 * 1024 * 1024) {\n      // This provider uses a simple approach of loading everything into memory up front, so we\n      // can't handle large files\n      throw new Error(\"Unable to stream MCAP file; too large\");\n    }\n    const decompressHandlers = await loadDecompressHandlers();\n\n    const streamReader = this.options.stream.getReader();\n\n    const problems: PlayerProblem[] = [];\n    const channelIdsWithErrors = new Set<number>();\n\n    const messagesByChannel = new Map<number, MessageEvent<unknown>[]>();\n    const schemasById = new Map<number, McapTypes.TypedMcapRecords[\"Schema\"]>();\n    const channelInfoById = new Map<\n      number,\n      { channel: McapTypes.Channel; parsedChannel: ParsedChannel; schemaName: string | undefined }\n    >();\n\n    let startTime: Time | undefined;\n    let endTime: Time | undefined;\n    let profile: string | undefined;\n    function processRecord(record: McapTypes.TypedMcapRecord) {\n      switch (record.type) {\n        default:\n          break;\n\n        case \"Header\": {\n          profile = record.profile;\n          break;\n        }\n\n        case \"Schema\": {\n          const existingSchema = schemasById.get(record.id);\n          if (existingSchema) {\n            if (!isEqual(existingSchema, record)) {\n              throw new Error(`differing schemas for id ${record.id}`);\n            }\n          }\n          schemasById.set(record.id, record);\n          break;\n        }\n\n        case \"Channel\": {\n          const existingInfo = channelInfoById.get(record.id);\n          if (existingInfo) {\n            if (!isEqual(existingInfo.channel, record)) {\n              throw new Error(`differing channel infos for id ${record.id}`);\n            }\n            break;\n          }\n          if (channelIdsWithErrors.has(record.id)) {\n            break;\n          }\n          const schema = schemasById.get(record.schemaId);\n          if (record.schemaId !== 0 && !schema) {\n            throw new Error(\n              `Encountered channel with schema id ${record.schemaId} but no prior schema`,\n            );\n          }\n\n          try {\n            const parsedChannel = parseChannel({ messageEncoding: record.messageEncoding, schema });\n            channelInfoById.set(record.id, {\n              channel: record,\n              parsedChannel,\n              schemaName: schema?.name,\n            });\n            messagesByChannel.set(record.id, []);\n          } catch (error) {\n            channelIdsWithErrors.add(record.id);\n            problems.push({\n              severity: \"error\",\n              message: `Error in topic ${record.topic} (channel ${record.id}): ${error.message}`,\n              error,\n            });\n          }\n          break;\n        }\n\n        case \"Message\": {\n          const channelId = record.channelId;\n          const channelInfo = channelInfoById.get(channelId);\n          const messages = messagesByChannel.get(channelId);\n          if (!channelInfo || !messages) {\n            if (channelIdsWithErrors.has(channelId)) {\n              break; // error has already been reported\n            }\n            throw new Error(`message for channel ${channelId} with no prior channel info`);\n          }\n          const receiveTime = fromNanoSec(record.logTime);\n          if (!startTime || isLessThan(receiveTime, startTime)) {\n            startTime = receiveTime;\n          }\n          if (!endTime || isGreaterThan(receiveTime, endTime)) {\n            endTime = receiveTime;\n          }\n\n          messages.push({\n            topic: channelInfo.channel.topic,\n            receiveTime,\n            publishTime: fromNanoSec(record.publishTime),\n            message: channelInfo.parsedChannel.deserialize(record.data),\n            sizeInBytes: record.data.byteLength,\n            schemaName: channelInfo.schemaName ?? \"\",\n          });\n          break;\n        }\n      }\n    }\n\n    const reader = new McapStreamReader({ decompressHandlers });\n    for (let result; (result = await streamReader.read()), !result.done; ) {\n      reader.append(result.value);\n      for (let record; (record = reader.nextRecord()); ) {\n        processRecord(record);\n      }\n    }\n\n    this.msgEventsByChannel = messagesByChannel;\n\n    const topics: Topic[] = [];\n    const topicStats = new Map<string, TopicStats>();\n    const datatypes: RosDatatypes = new Map();\n    const publishersByTopic = new Map<string, Set<string>>();\n\n    for (const { channel, parsedChannel, schemaName } of channelInfoById.values()) {\n      topics.push({ name: channel.topic, schemaName });\n      const numMessages = messagesByChannel.get(channel.id)?.length;\n      if (numMessages != undefined) {\n        topicStats.set(channel.topic, { numMessages });\n      }\n\n      // Track the publisher for this topic. \"callerid\" is defined in the MCAP ROS 1 Well-known\n      // profile at <https://mcap.dev/specification/appendix.html>. We skip the profile check to\n      // allow non-ROS profiles to utilize this functionality as well\n      const publisherId = channel.metadata.get(\"callerid\") ?? String(channel.id);\n      let publishers = publishersByTopic.get(channel.topic);\n      if (!publishers) {\n        publishers = new Set();\n        publishersByTopic.set(channel.topic, publishers);\n      }\n      publishers.add(publisherId);\n\n      // Final datatypes is an unholy union of schemas across all channels\n      for (const [name, datatype] of parsedChannel.datatypes) {\n        datatypes.set(name, datatype);\n      }\n    }\n\n    this.start = startTime ?? { sec: 0, nsec: 0 };\n    this.end = endTime ?? { sec: 0, nsec: 0 };\n\n    const fileDuration = toSec(subtract(this.end, this.start));\n    if (fileDuration > DURATION_YEAR_SEC) {\n      const startRfc = toRFC3339String(this.start);\n      const endRfc = toRFC3339String(this.end);\n\n      problems.push({\n        message: \"This file has an abnormally long duration.\",\n        tip: `The start ${startRfc} and end ${endRfc} are greater than a year.`,\n        severity: \"warn\",\n      });\n    }\n\n    problems.push({\n      message: \"This file is unindexed. Unindexed files may have degraded performance.\",\n      tip: \"See the mcap spec: https://mcap.dev/specification/index.html#summary-section\",\n      severity: \"warn\",\n    });\n\n    return {\n      start: this.start,\n      end: this.end,\n      topics,\n      datatypes,\n      profile,\n      problems,\n      publishersByTopic,\n      topicStats,\n    };\n  }\n\n  public async *messageIterator(\n    args: MessageIteratorArgs,\n  ): AsyncIterableIterator<Readonly<IteratorResult>> {\n    if (!this.msgEventsByChannel) {\n      throw new Error(\"initialization not completed\");\n    }\n\n    const topics = args.topics;\n    const start = args.start ?? this.start;\n    const end = args.end ?? this.end;\n\n    if (topics.length === 0 || !start || !end) {\n      return;\n    }\n\n    const topicsSet = new Set(topics);\n\n    for (const [channelId, msgEvents] of this.msgEventsByChannel) {\n      for (const msgEvent of msgEvents) {\n        if (\n          isTimeInRangeInclusive(msgEvent.receiveTime, start, end) &&\n          topicsSet.has(msgEvent.topic)\n        ) {\n          yield {\n            type: \"message-event\",\n            connectionId: channelId,\n            msgEvent,\n          };\n        }\n      }\n    }\n  }\n\n  public async getBackfillMessages(\n    args: GetBackfillMessagesArgs,\n  ): Promise<MessageEvent<unknown>[]> {\n    if (!this.msgEventsByChannel) {\n      throw new Error(\"initialization not completed\");\n    }\n\n    const needTopics = args.topics;\n    const msgEventsByTopic = new Map<string, MessageEvent<unknown>>();\n    for (const [_, msgEvents] of this.msgEventsByChannel) {\n      for (const msgEvent of msgEvents) {\n        if (compare(msgEvent.receiveTime, args.time) <= 0 && needTopics.includes(msgEvent.topic)) {\n          msgEventsByTopic.set(msgEvent.topic, msgEvent);\n        }\n      }\n    }\n    return [...msgEventsByTopic.values()];\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport BrowserHttpReader from \"@foxglove/studio-base/util/BrowserHttpReader\";\nimport CachedFilelike from \"@foxglove/studio-base/util/CachedFilelike\";\n\nexport class RemoteFileReadable {\n  private remoteReader: CachedFilelike;\n\n  public constructor(url: string) {\n    const fileReader = new BrowserHttpReader(url);\n    this.remoteReader = new CachedFilelike({\n      fileReader,\n      cacheSizeInBytes: 1024 * 1024 * 200, // 200MiB\n    });\n  }\n\n  public async open(): Promise<void> {\n    await this.remoteReader.open(); // Important that we call this first, because it might throw an error if the file can't be read.\n  }\n\n  public async size(): Promise<bigint> {\n    return BigInt(this.remoteReader.size());\n  }\n  public async read(offset: bigint, size: bigint): Promise<Uint8Array> {\n    if (offset + size > Number.MAX_SAFE_INTEGER) {\n      throw new Error(`Read too large: offset ${offset}, size ${size}`);\n    }\n    return await this.remoteReader.read(Number(offset), Number(size));\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport { McapIndexedReader, McapTypes } from \"@mcap/core\";\n\nimport Log from \"@foxglove/log\";\nimport { loadDecompressHandlers } from \"@foxglove/mcap-support\";\nimport { MessageEvent } from \"@foxglove/studio-base/players/types\";\n\nimport { FileReadable } from \"./FileReadable\";\nimport { McapIndexedIterableSource } from \"./McapIndexedIterableSource\";\nimport { McapStreamingIterableSource } from \"./McapStreamingIterableSource\";\nimport { RemoteFileReadable } from \"./RemoteFileReadable\";\nimport {\n  IIterableSource,\n  IteratorResult,\n  Initalization,\n  MessageIteratorArgs,\n  GetBackfillMessagesArgs,\n} from \"../IIterableSource\";\n\nconst log = Log.getLogger(__filename);\n\ntype McapSource = { type: \"file\"; file: File } | { type: \"url\"; url: string };\n\nasync function tryCreateIndexedReader(readable: McapTypes.IReadable) {\n  const decompressHandlers = await loadDecompressHandlers();\n  try {\n    const reader = await McapIndexedReader.Initialize({ readable, decompressHandlers });\n\n    if (reader.chunkIndexes.length === 0 || reader.channelsById.size === 0) {\n      return undefined;\n    }\n    return reader;\n  } catch (err) {\n    log.error(err);\n    return undefined;\n  }\n}\n\nexport class McapIterableSource implements IIterableSource {\n  private _source: McapSource;\n  private _sourceImpl: IIterableSource | undefined;\n\n  public constructor(source: McapSource) {\n    this._source = source;\n  }\n\n  public async initialize(): Promise<Initalization> {\n    const source = this._source;\n\n    switch (source.type) {\n      case \"file\": {\n        // Ensure the file is readable before proceeding (will throw in the event of a permission\n        // error). Workaround for the fact that `file.stream().getReader()` returns a generic\n        // \"network error\" in the event of a permission error.\n        await source.file.slice(0, 1).arrayBuffer();\n\n        const readable = new FileReadable(source.file);\n        const reader = await tryCreateIndexedReader(readable);\n        if (reader) {\n          this._sourceImpl = new McapIndexedIterableSource(reader);\n        } else {\n          this._sourceImpl = new McapStreamingIterableSource({\n            size: source.file.size,\n            stream: source.file.stream(),\n          });\n        }\n        break;\n      }\n      case \"url\": {\n        const readable = new RemoteFileReadable(source.url);\n        await readable.open();\n        const reader = await tryCreateIndexedReader(readable);\n        if (reader) {\n          this._sourceImpl = new McapIndexedIterableSource(reader);\n        } else {\n          const response = await fetch(source.url);\n          if (!response.body) {\n            throw new Error(`Unable to stream remote file. <${source.url}>`);\n          }\n          const size = response.headers.get(\"content-length\");\n          if (size == undefined) {\n            throw new Error(`Remote file is missing Content-Length header. <${source.url}>`);\n          }\n\n          this._sourceImpl = new McapStreamingIterableSource({\n            size: parseInt(size),\n            stream: response.body,\n          });\n        }\n        break;\n      }\n    }\n\n    return await this._sourceImpl.initialize();\n  }\n\n  public messageIterator(\n    opt: MessageIteratorArgs,\n  ): AsyncIterableIterator<Readonly<IteratorResult>> {\n    if (!this._sourceImpl) {\n      throw new Error(\"Invariant: uninitialized\");\n    }\n\n    return this._sourceImpl.messageIterator(opt);\n  }\n\n  public async getBackfillMessages(\n    args: GetBackfillMessagesArgs,\n  ): Promise<MessageEvent<unknown>[]> {\n    if (!this._sourceImpl) {\n      throw new Error(\"Invariant: uninitialized\");\n    }\n\n    return await this._sourceImpl.getBackfillMessages(args);\n  }\n}\n","// This Source Code Form is subject to the terms of the Mozilla Public\n// License, v2.0. If a copy of the MPL was not distributed with this\n// file, You can obtain one at http://mozilla.org/MPL/2.0/\n\nimport * as Comlink from \"comlink\";\n\nimport { IterableSourceInitializeArgs } from \"@foxglove/studio-base/players/IterablePlayer/IIterableSource\";\nimport { WorkerIterableSourceWorker } from \"@foxglove/studio-base/players/IterablePlayer/WorkerIterableSourceWorker\";\n\nimport { McapIterableSource } from \"./McapIterableSource\";\n\nexport function initialize(args: IterableSourceInitializeArgs): WorkerIterableSourceWorker {\n  if (args.file) {\n    const source = new McapIterableSource({ type: \"file\", file: args.file });\n    const wrapped = new WorkerIterableSourceWorker(source);\n    return Comlink.proxy(wrapped);\n  } else if (args.url) {\n    const source = new McapIterableSource({ type: \"url\", url: args.url });\n    const wrapped = new WorkerIterableSourceWorker(source);\n    return Comlink.proxy(wrapped);\n  }\n\n  throw new Error(\"file or url required\");\n}\n\nComlink.expose(initialize);\n"],"names":["handlersPromise","loadDecompressHandlers","_loadDecompressHandlers","decompressZstd","decompressLZ4","bzip2","mod","buffer","decompressedSize","FileReadable","file","offset","size","log","McapIndexedIterableSource","reader","startTime","endTime","chunk","topicStats","topicsByName","datatypes","problems","publishersByTopic","channel","schema","parsedChannel","parseChannel","error","topic","numMessages","publisherId","publishers","name","datatype","args","topics","start","end","message","channelInfo","time","messages","err","a","b","DURATION_YEAR_SEC","McapStreamingIterableSource","options","decompressHandlers","streamReader","channelIdsWithErrors","messagesByChannel","schemasById","channelInfoById","profile","processRecord","record","existingSchema","existingInfo","channelId","receiveTime","result","schemaName","startRfc","endRfc","topicsSet","msgEvents","msgEvent","needTopics","msgEventsByTopic","_","RemoteFileReadable","url","fileReader","BrowserHttpReader","CachedFilelike","tryCreateIndexedReader","readable","McapIterableSource","source","response","opt","initialize","wrapped","WorkerIterableSourceWorker"],"sourceRoot":""}