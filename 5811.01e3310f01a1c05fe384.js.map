{"version":3,"file":"5811.01e3310f01a1c05fe384.js","mappings":"gHAmBO,SAASA,EAAoB,CAAE,WAAAC,EAAY,UAAAC,CAAW,EAAG,CAC5D,MAAMC,EAAQ,IAAI,YAAY,IAAMD,CAAS,EAC7C,QAASE,EAAI,EAAGA,EAAI,IAAKA,IAAK,CAC1B,IAAIC,EAAID,EACRC,GAAMA,EAAI,GAAKJ,EAAeI,IAAM,EACpCA,GAAMA,EAAI,GAAKJ,EAAeI,IAAM,EACpCA,GAAMA,EAAI,GAAKJ,EAAeI,IAAM,EACpCA,GAAMA,EAAI,GAAKJ,EAAeI,IAAM,EACpCA,GAAMA,EAAI,GAAKJ,EAAeI,IAAM,EACpCA,GAAMA,EAAI,GAAKJ,EAAeI,IAAM,EACpCA,GAAMA,EAAI,GAAKJ,EAAeI,IAAM,EACpCA,GAAMA,EAAI,GAAKJ,EAAeI,IAAM,EACpCF,EAAMC,CAAC,EAAIC,CACf,CACA,QAASD,EAAI,IAAKA,EAAID,EAAM,OAAQC,IAAK,CACrC,MAAME,EAAQH,EAAMC,EAAI,GAAG,EAC3BD,EAAMC,CAAC,EAAID,EAAMG,EAAQ,GAAI,EAAKA,IAAU,CAChD,CACA,OAAOH,CACX,CACA,MAAMI,EAAcP,EAAoB,CAAE,WAAY,WAAY,UAAW,CAAE,CAAC,EAIzE,SAAS,GAAY,CACxB,MAAO,EACX,CAOO,SAAS,EAAYQ,EAAMC,EAAM,CACpC,MAAMC,EAAaD,EAAK,WAClBE,EAAO,IAAI,SAASF,EAAK,OAAQA,EAAK,WAAYC,CAAU,EAClE,IAAIL,EAAIG,EACJI,EAAS,EAEb,MAAMC,EAAU,CAACF,EAAK,WAAa,EACnC,KAAOC,EAASC,GAAWD,EAASF,EAAYE,IAC5CP,EAAIE,GAAaF,EAAIM,EAAK,SAASC,CAAM,GAAK,GAAI,EAAKP,IAAM,EAEjE,GAAIO,IAAWF,EACX,OAAOL,EAEXO,EAASC,EAET,IAAIC,EAAiBJ,EAAaE,EAClC,KAAOE,GAAkB,EAAGF,GAAU,EAAGE,GAAkB,EAAG,CAC1DT,GAAKM,EAAK,UAAUC,EAAQ,EAAI,EAChC,MAAMG,EAAKJ,EAAK,UAAUC,EAAS,EAAG,EAAI,EAC1CP,EACIE,EAAY,EAAI,KAAQQ,IAAO,GAAM,IAAK,EACtCR,EAAY,EAAI,KAAQQ,IAAO,GAAM,IAAK,EAC1CR,EAAY,EAAI,KAAQQ,IAAO,EAAK,IAAK,EACzCR,EAAY,EAAI,KAAQQ,IAAO,EAAK,IAAK,EACzCR,EAAY,EAAI,KAAQF,IAAM,GAAM,IAAK,EACzCE,EAAY,EAAI,KAAQF,IAAM,GAAM,IAAK,EACzCE,EAAY,EAAI,KAAQF,IAAM,EAAK,IAAK,EACxCE,EAAY,EAAI,KAAQF,IAAM,EAAK,IAAK,CACpD,CAGA,QAASD,EAAIQ,EAAQR,EAAIM,EAAYN,IACjCC,EAAIE,GAAaF,EAAIM,EAAK,SAASP,CAAC,GAAK,GAAI,EAAKC,IAAM,EAE5D,OAAOA,CACX,CAIO,SAAS,EAAWG,EAAM,CAC7B,OAAQA,EAAO,MAAQ,CAC3B,CAKO,SAAS,EAAMC,EAAM,CACxB,OAAO,EAAW,EAAY,EAAU,EAAGA,CAAI,CAAC,CACpD,CCpGA,IAAIO,EAAsD,SAAUC,EAASC,EAAM,CAC/E,IAAIC,EAAI,CAAE,MAAO,EAAG,KAAM,UAAW,CAAE,GAAIC,EAAE,CAAC,EAAI,EAAG,MAAMA,EAAE,CAAC,EAAG,OAAOA,EAAE,CAAC,CAAG,EAAG,KAAM,CAAC,EAAG,IAAK,CAAC,CAAE,EAAGC,EAAGC,EAAGF,EAAGG,EAC/G,OAAOA,EAAI,CAAE,KAAMC,EAAK,CAAC,EAAG,MAASA,EAAK,CAAC,EAAG,OAAUA,EAAK,CAAC,CAAE,EAAG,OAAO,QAAW,aAAeD,EAAE,OAAO,QAAQ,EAAI,UAAW,CAAE,OAAO,IAAM,GAAIA,EACvJ,SAASC,EAAKC,EAAG,CAAE,OAAO,SAAUC,EAAG,CAAE,OAAOC,EAAK,CAACF,EAAGC,CAAC,CAAC,CAAG,CAAG,CACjE,SAASC,EAAKC,EAAI,CACd,GAAIP,EAAG,MAAM,IAAI,UAAU,iCAAiC,EAC5D,KAAOF,GAAG,GAAI,CACV,GAAIE,EAAI,EAAGC,IAAMF,EAAIQ,EAAG,CAAC,EAAI,EAAIN,EAAE,OAAYM,EAAG,CAAC,EAAIN,EAAE,SAAcF,EAAIE,EAAE,SAAcF,EAAE,KAAKE,CAAC,EAAG,GAAKA,EAAE,OAAS,EAAEF,EAAIA,EAAE,KAAKE,EAAGM,EAAG,CAAC,CAAC,GAAG,KAAM,OAAOR,EAE3J,OADIE,EAAI,EAAGF,IAAGQ,EAAK,CAACA,EAAG,CAAC,EAAI,EAAGR,EAAE,KAAK,GAC9BQ,EAAG,CAAC,EAAG,CACX,IAAK,GAAG,IAAK,GAAGR,EAAIQ,EAAI,MACxB,IAAK,GAAG,OAAAT,EAAE,QAAgB,CAAE,MAAOS,EAAG,CAAC,EAAG,KAAM,EAAM,EACtD,IAAK,GAAGT,EAAE,QAASG,EAAIM,EAAG,CAAC,EAAGA,EAAK,CAAC,CAAC,EAAG,SACxC,IAAK,GAAGA,EAAKT,EAAE,IAAI,IAAI,EAAGA,EAAE,KAAK,IAAI,EAAG,SACxC,QACI,GAAMC,EAAID,EAAE,KAAM,EAAAC,EAAIA,EAAE,OAAS,GAAKA,EAAEA,EAAE,OAAS,CAAC,KAAOQ,EAAG,CAAC,IAAM,GAAKA,EAAG,CAAC,IAAM,GAAI,CAAET,EAAI,EAAG,QAAU,CAC3G,GAAIS,EAAG,CAAC,IAAM,IAAM,CAACR,GAAMQ,EAAG,CAAC,EAAIR,EAAE,CAAC,GAAKQ,EAAG,CAAC,EAAIR,EAAE,CAAC,GAAK,CAAED,EAAE,MAAQS,EAAG,CAAC,EAAG,KAAO,CACrF,GAAIA,EAAG,CAAC,IAAM,GAAKT,EAAE,MAAQC,EAAE,CAAC,EAAG,CAAED,EAAE,MAAQC,EAAE,CAAC,EAAGA,EAAIQ,EAAI,KAAO,CACpE,GAAIR,GAAKD,EAAE,MAAQC,EAAE,CAAC,EAAG,CAAED,EAAE,MAAQC,EAAE,CAAC,EAAGD,EAAE,IAAI,KAAKS,CAAE,EAAG,KAAO,CAC9DR,EAAE,CAAC,GAAGD,EAAE,IAAI,IAAI,EACpBA,EAAE,KAAK,IAAI,EAAG,QACtB,CACAS,EAAKV,EAAK,KAAKD,EAASE,CAAC,CAC7B,OAASU,EAAP,CAAYD,EAAK,CAAC,EAAGC,CAAC,EAAGP,EAAI,CAAG,QAAE,CAAUD,EAAID,EAAI,CAAG,CACzD,GAAIQ,EAAG,CAAC,EAAI,EAAG,MAAMA,EAAG,CAAC,EAAG,MAAO,CAAE,MAAOA,EAAG,CAAC,EAAIA,EAAG,CAAC,EAAI,OAAQ,KAAM,EAAK,CACnF,CACJ,EACIE,EAA4C,SAAUC,EAAGN,EAAG,CAC5D,IAAIO,EAAI,OAAO,QAAW,YAAcD,EAAE,OAAO,QAAQ,EACzD,GAAI,CAACC,EAAG,OAAOD,EACf,IAAI3B,EAAI4B,EAAE,KAAKD,CAAC,EAAG1B,EAAG4B,EAAK,CAAC,EAAGJ,EAC/B,GAAI,CACA,MAAQJ,IAAM,QAAUA,KAAM,IAAM,EAAEpB,EAAID,EAAE,KAAK,GAAG,MAAM6B,EAAG,KAAK5B,EAAE,KAAK,CAC7E,OACO6B,EAAP,CAAgBL,EAAI,CAAE,MAAOK,CAAM,CAAG,QACtC,CACI,GAAI,CACI7B,GAAK,CAACA,EAAE,OAAS2B,EAAI5B,EAAE,SAAY4B,EAAE,KAAK5B,CAAC,CACnD,QACA,CAAU,GAAIyB,EAAG,MAAMA,EAAE,KAAO,CACpC,CACA,OAAOI,CACX,EACIE,EAA0D,SAAUC,EAAIC,EAAMC,EAAM,CACpF,GAAIA,GAAQ,UAAU,SAAW,EAAG,QAASlC,EAAI,EAAGmC,EAAIF,EAAK,OAAQJ,EAAI7B,EAAImC,EAAGnC,KACxE6B,GAAM,EAAE7B,KAAKiC,MACRJ,IAAIA,EAAK,MAAM,UAAU,MAAM,KAAKI,EAAM,EAAGjC,CAAC,GACnD6B,EAAG7B,CAAC,EAAIiC,EAAKjC,CAAC,GAGtB,OAAOgC,EAAG,OAAOH,GAAM,MAAM,UAAU,MAAM,KAAKI,CAAI,CAAC,CAC3D,EACIG,EAAQ,SAAU,EAAG,CAAE,MAAO,CAAC,CAAC,CAAG,EAKnCC,EAAsB,UAAY,CAKlC,SAASA,EAAKC,EAAS,CACfA,IAAY,SAAUA,EAAUD,EAAK,eACzC,IAAIE,EAAQ,KACZ,KAAK,QAAUD,EACf,KAAK,UAAY,CAAC,EAClB,KAAK,OAAS,EAId,KAAK,MAAQ,KAAK,IAIlB,KAAK,QAAU,KAAK,KAIpB,KAAK,KAAO,KAAK,IAKjB,KAAK,iBAAmB,SAAUE,EAAGC,EAAG,CACpC,MAAO,GAAKF,EAAM,QAAQC,EAAGC,CAAC,CAClC,CACJ,CASA,OAAAJ,EAAK,mBAAqB,SAAUK,EAAK,CACrC,MAAO,CAACA,EAAM,EAAI,EAAGA,EAAM,EAAI,CAAC,CACpC,EAMAL,EAAK,iBAAmB,SAAUK,EAAK,CACnC,GAAIA,GAAO,EACP,MAAO,GAEX,IAAIC,EAAgBD,EAAM,EAAI,EAAI,EAClC,OAAO,KAAK,OAAOA,EAAMC,GAAiB,CAAC,CAC/C,EAMAN,EAAK,kBAAoB,SAAUK,EAAK,CACpC,GAAIA,GAAO,EACP,MAAO,GAEX,IAAIC,EAAgBD,EAAM,EAAI,EAAI,GAClC,OAAOA,EAAMC,CACjB,EAOAN,EAAK,cAAgB,SAAUG,EAAGC,EAAG,CACjC,OAAID,EAAIC,EACG,EAEFD,EAAIC,EACF,GAGA,CAEf,EAOAJ,EAAK,cAAgB,SAAUG,EAAGC,EAAG,CACjC,OAAIA,EAAID,EACG,EAEFC,EAAID,EACF,GAGA,CAEf,EAOAH,EAAK,oBAAsB,SAAUG,EAAGC,EAAG,CACvC,OAAOD,EAAIC,CACf,EAOAJ,EAAK,oBAAsB,SAAUG,EAAGC,EAAG,CACvC,OAAOA,EAAID,CACf,EAOAH,EAAK,eAAiB,SAAUG,EAAGC,EAAG,CAClC,OAAOD,IAAMC,CACjB,EAMAJ,EAAK,MAAQ,SAAUO,EAAM,CACzB,SAASC,EAAK7C,EAAG,CACb,IAAI8C,EAAKT,EAAK,iBAAiBrC,CAAC,EAChC,OAAO,KAAK,MAAM,KAAK,KAAK8C,EAAK,CAAC,CAAC,CACvC,CACA,SAASC,EAAOC,EAAKC,EAAO,CAExB,QADIC,EAAM,GACHD,EAAQ,EAAG,EAAEA,EAChBC,GAAOF,EAEX,OAAOE,CACX,CAKA,QAJIC,EAAO,EACPC,EAAQ,CAAC,EACTC,EAAWR,EAAKD,EAAK,OAAS,CAAC,EAAI,EACnCU,EAAY,EACTH,EAAOP,EAAK,QAAQ,CACvB,IAAI5C,EAAI6C,EAAKM,CAAI,EAAI,EACjBA,IAAS,IACTnD,EAAI,GAGR,IAAIuD,EAAW,OAAOX,EAAK,IAAIO,CAAI,CAAC,EAChCI,EAAS,OAASD,IAClBA,EAAYC,EAAS,QAGzBH,EAAMpD,CAAC,EAAIoD,EAAMpD,CAAC,GAAK,CAAC,EACxBoD,EAAMpD,CAAC,EAAE,KAAKuD,CAAQ,EACtBJ,GAAQ,CACZ,CACA,OAAOC,EACF,IAAI,SAAUI,EAAMxD,EAAG,CACxB,IAAIiD,EAAQ,KAAK,IAAI,EAAGI,EAAWrD,CAAC,EAAI,EACxC,OAAQ+C,EAAO,IAAK,KAAK,MAAME,EAAQ,CAAC,EAAIK,CAAS,EACjDE,EACK,IAAI,SAAUC,EAAI,CAEnB,IAAIC,GAAQJ,EAAYG,EAAG,QAAU,EACrC,OAAOV,EAAO,IAAK,KAAK,KAAKW,CAAI,CAAC,EAAID,EAAKV,EAAO,IAAK,KAAK,MAAMW,CAAI,CAAC,CAC3E,CAAC,EACI,KAAKX,EAAO,IAAKE,EAAQK,CAAS,CAAC,CAChD,CAAC,EACI,KAAK;AAAA,CAAI,CAClB,EAUAjB,EAAK,QAAU,SAAUsB,EAAKrB,EAAS,CACnC,IAAIM,EAAO,IAAIP,EAAKC,CAAO,EAC3B,OAAAM,EAAK,UAAYe,EACjBf,EAAK,KAAK,EACHA,CACX,EAOAP,EAAK,QAAU,SAAUuB,EAAStB,EAAS,CACvC,IAAIM,EAAO,IAAIP,EAAKC,CAAO,EAC3B,OAAAM,EAAK,UAAYgB,EACVhB,EAAK,IAAI,CACpB,EAOAP,EAAK,SAAW,SAAUuB,EAASC,EAAMvB,EAAS,CAC9C,IAAIM,EAAO,IAAIP,EAAKC,CAAO,EAC3BM,EAAK,UAAYgB,EACjBhB,EAAK,KAAKiB,CAAI,CAClB,EAQAxB,EAAK,YAAc,SAAUuB,EAASC,EAAMvB,EAAS,CACjD,IAAIM,EAAO,IAAIP,EAAKC,CAAO,EAC3B,OAAAM,EAAK,UAAYgB,EACVhB,EAAK,QAAQiB,CAAI,CAC5B,EAQAxB,EAAK,YAAc,SAAUuB,EAASC,EAAMvB,EAAS,CACjD,IAAIM,EAAO,IAAIP,EAAKC,CAAO,EAC3B,OAAAM,EAAK,UAAYgB,EACVhB,EAAK,QAAQiB,CAAI,CAC5B,EAQAxB,EAAK,QAAU,SAAUuB,EAASvC,EAAGiB,EAAS,CACtCjB,IAAM,SAAUA,EAAI,GACxB,IAAIuB,EAAO,IAAIP,EAAKC,CAAO,EAC3B,OAAAM,EAAK,UAAYgB,EACVhB,EAAK,IAAIvB,CAAC,CACrB,EAQAgB,EAAK,WAAa,SAAUuB,EAASvC,EAAGiB,EAAS,CACzCjB,IAAM,SAAUA,EAAI,GACxB,IAAIuB,EAAO,IAAIP,EAAKC,CAAO,EAC3B,OAAAM,EAAK,UAAYgB,EACVhB,EAAK,OAAOvB,CAAC,CACxB,EAQAgB,EAAK,SAAW,SAAUhB,EAAGyC,EAAUxB,EAAS,CAC5C,IAAIM,EAAO,IAAIP,EAAKC,CAAO,EAC3B,OAAAM,EAAK,UAAYb,EAAc,CAAC,EAAGL,EAAOoC,CAAQ,EAAG,EAAK,EAC1DlB,EAAK,KAAK,EACHA,EAAK,IAAIvB,CAAC,CACrB,EAQAgB,EAAK,UAAY,SAAUhB,EAAGyC,EAAUxB,EAAS,CAC7C,IAAIM,EAAO,IAAIP,EAAKC,CAAO,EAC3B,OAAAM,EAAK,UAAYb,EAAc,CAAC,EAAGL,EAAOoC,CAAQ,EAAG,EAAK,EAC1DlB,EAAK,KAAK,EACHA,EAAK,OAAOvB,CAAC,CACxB,EAUAgB,EAAK,UAAU,IAAM,SAAU0B,EAAS,CACpC,YAAK,YAAY,KAAK,UAAU,KAAKA,CAAO,EAAI,CAAC,EACjD,KAAK,YAAY,EACV,EACX,EAOA1B,EAAK,UAAU,OAAS,SAAU2B,EAAU,CACxC,IAAIC,EACAjE,EAAI,KAAK,QACZiE,EAAK,KAAK,WAAW,KAAK,MAAMA,EAAIlC,EAAc,CAAC,EAAGL,EAAOsC,CAAQ,EAAG,EAAK,CAAC,EAC/E,QAAS7B,EAAI,KAAK,OAAQnC,EAAImC,EAAG,EAAEnC,EAC/B,KAAK,YAAYA,CAAC,EAEtB,YAAK,YAAY,EACV,EACX,EAOAqC,EAAK,UAAU,OAAS,SAAUhB,EAAG,CAEjC,GADIA,IAAM,SAAUA,EAAI,GACpB,KAAK,UAAU,SAAW,GAAKA,GAAK,EAEpC,MAAO,CAAC,EAEP,GAAI,KAAK,UAAU,SAAW,EAE/B,MAAO,CAAC,KAAK,UAAU,CAAC,CAAC,EAExB,GAAIA,GAAK,KAAK,UAAU,OAEzB,OAAOU,EAAc,CAAC,EAAGL,EAAO,KAAK,SAAS,EAAG,EAAK,EAItD,IAAIwC,EAAS,KAAK,cAAc,CAAC,CAAC7C,CAAC,EACnC,OAAO6C,CAEf,EAKA7B,EAAK,UAAU,MAAQ,UAAY,CAC/B,IAAIE,EAAQ,KACZ,OAAO,KAAK,UAAU,KAAK,SAAUkB,EAAIU,EAAG,CAAE,MAAO,CAAC,CAAC5B,EAAM,cAAc4B,CAAC,EAAE,KAAK,SAAUC,EAAI,CAAE,OAAO7B,EAAM,QAAQkB,EAAIW,CAAE,EAAI,CAAG,CAAC,CAAG,CAAC,CAC9I,EAIA/B,EAAK,UAAU,MAAQ,UAAY,CAC/B,KAAK,UAAY,CAAC,CACtB,EAKAA,EAAK,UAAU,MAAQ,UAAY,CAC/B,IAAIgC,EAAS,IAAIhC,EAAK,KAAK,WAAW,CAAC,EACvC,OAAAgC,EAAO,UAAY,KAAK,QAAQ,EAChCA,EAAO,OAAS,KAAK,OACdA,CACX,EAKAhC,EAAK,UAAU,WAAa,UAAY,CACpC,OAAO,KAAK,OAChB,EAOAA,EAAK,UAAU,SAAW,SAAUV,EAAG2C,EAAI,CACvC,OAAIA,IAAO,SAAUA,EAAKjC,EAAK,gBACxB,KAAK,UAAU,UAAU,SAAUoB,EAAI,CAAE,OAAOa,EAAGb,EAAI9B,CAAC,CAAG,CAAC,GAAK,CAC5E,EAKAU,EAAK,UAAU,KAAO,SAAUkC,EAAO,CAC/BA,IACA,KAAK,UAAYxC,EAAc,CAAC,EAAGL,EAAO6C,CAAK,EAAG,EAAK,GAE3D,QAASvE,EAAI,KAAK,MAAM,KAAK,UAAU,MAAM,EAAGA,GAAK,EAAG,EAAEA,EACtD,KAAK,cAAcA,CAAC,EAExB,KAAK,YAAY,CACrB,EAKAqC,EAAK,UAAU,QAAU,UAAY,CACjC,OAAO,KAAK,SAAW,CAC3B,EAIAA,EAAK,UAAU,MAAQ,UAAY,CAC/B,GAAI,KAAK,UAAU,SAAW,EAC1B,MAAO,CAAC,EAEZ,IAAIS,EAAKT,EAAK,iBAAiB,KAAK,UAAU,OAAS,CAAC,EACxD,OAAO,KAAK,UAAU,MAAMS,EAAK,CAAC,CACtC,EACA,OAAO,eAAeT,EAAK,UAAW,SAAU,CAK5C,IAAK,UAAY,CACb,OAAO,KAAK,UAAU,MAC1B,EACA,WAAY,GACZ,aAAc,EAClB,CAAC,EACD,OAAO,eAAeA,EAAK,UAAW,QAAS,CAK3C,IAAK,UAAY,CACb,OAAO,KAAK,MAChB,EAKA,IAAK,SAAUmC,EAAI,CACf,KAAK,OAAS,CAAC,CAACA,EAChB,KAAK,YAAY,CACrB,EACA,WAAY,GACZ,aAAc,EAClB,CAAC,EAMDnC,EAAK,UAAU,KAAO,UAAY,CAC9B,OAAO,KAAK,UAAU,CAAC,CAC3B,EAKAA,EAAK,UAAU,IAAM,UAAY,CAC7B,IAAIoC,EAAO,KAAK,UAAU,IAAI,EAC9B,OAAI,KAAK,OAAS,GAAKA,IAAS,OACrB,KAAK,QAAQA,CAAI,EAErBA,CACX,EAMApC,EAAK,UAAU,KAAO,UAAY,CAE9B,QADI2B,EAAW,CAAC,EACPU,EAAK,EAAGA,EAAK,UAAU,OAAQA,IACpCV,EAASU,CAAE,EAAI,UAAUA,CAAE,EAE/B,OAAIV,EAAS,OAAS,EACX,GAEFA,EAAS,SAAW,EAClB,KAAK,IAAIA,EAAS,CAAC,CAAC,EAGpB,KAAK,OAAOA,CAAQ,CAEnC,EAMA3B,EAAK,UAAU,QAAU,SAAU0B,EAAS,CACxC,IAAIE,EACJ,OAAI,KAAK,QAAQ,KAAK,UAAU,CAAC,EAAGF,CAAO,EAAI,IAC3CE,EAAKvC,EAAO,CAAC,KAAK,UAAU,CAAC,EAAGqC,CAAO,EAAG,CAAC,EAAGA,EAAUE,EAAG,CAAC,EAAG,KAAK,UAAU,CAAC,EAAIA,EAAG,CAAC,EACvF,KAAK,cAAc,CAAC,GAEjBF,CACX,EAOA1B,EAAK,UAAU,OAAS,SAAUV,EAAG2C,EAAI,CAErC,GADIA,IAAO,SAAUA,EAAKjC,EAAK,gBAC3B,KAAK,OAAS,EAAG,CACjB,GAAIV,IAAM,OACN,YAAK,IAAI,EACF,GAGP,IAAIe,EAAM,KAAK,UAAU,UAAU,SAAUe,EAAI,CAAE,OAAOa,EAAGb,EAAI9B,CAAC,CAAG,CAAC,EACtE,GAAIe,GAAO,EACP,OAAIA,IAAQ,EACR,KAAK,IAAI,EAEJA,IAAQ,KAAK,OAAS,EAC3B,KAAK,UAAU,IAAI,GAGnB,KAAK,UAAU,OAAOA,EAAK,EAAG,KAAK,UAAU,IAAI,CAAC,EAClD,KAAK,YAAYA,CAAG,EACpB,KAAK,cAAcA,CAAG,GAEnB,EAGnB,CACA,MAAO,EACX,EAMAL,EAAK,UAAU,QAAU,SAAU0B,EAAS,CACxC,IAAIY,EAAO,KAAK,UAAU,CAAC,EAC3B,YAAK,UAAU,CAAC,EAAIZ,EACpB,KAAK,cAAc,CAAC,EACbY,CACX,EAKAtC,EAAK,UAAU,KAAO,UAAY,CAC9B,OAAO,KAAK,MAChB,EAOAA,EAAK,UAAU,IAAM,SAAUhB,EAAG,CAE9B,GADIA,IAAM,SAAUA,EAAI,GACpB,KAAK,UAAU,SAAW,GAAKA,GAAK,EAEpC,MAAO,CAAC,EAEP,GAAI,KAAK,UAAU,SAAW,GAAKA,IAAM,EAE1C,MAAO,CAAC,KAAK,UAAU,CAAC,CAAC,EAExB,GAAIA,GAAK,KAAK,UAAU,OAEzB,OAAOU,EAAc,CAAC,EAAGL,EAAO,KAAK,SAAS,EAAG,EAAK,EAItD,IAAIwC,EAAS,KAAK,WAAW,CAAC,CAAC7C,CAAC,EAChC,OAAO6C,CAEf,EAKA7B,EAAK,UAAU,QAAU,UAAY,CACjC,OAAON,EAAc,CAAC,EAAGL,EAAO,KAAK,SAAS,EAAG,EAAK,CAC1D,EAKAW,EAAK,UAAU,SAAW,UAAY,CAClC,OAAO,KAAK,UAAU,SAAS,CACnC,EAMAA,EAAK,UAAU,IAAM,SAAUrC,EAAG,CAC9B,OAAO,KAAK,UAAUA,CAAC,CAC3B,EAMAqC,EAAK,UAAU,cAAgB,SAAUK,EAAK,CAC1C,IAAIH,EAAQ,KACZ,OAAOF,EAAK,mBAAmBK,CAAG,EAC7B,IAAI,SAAU1C,EAAG,CAAE,OAAOuC,EAAM,UAAUvC,CAAC,CAAG,CAAC,EAC/C,OAAO,SAAUyB,EAAG,CAAE,OAAOA,IAAM,MAAW,CAAC,CACxD,EAMAY,EAAK,UAAU,YAAc,SAAUK,EAAK,CACxC,IAAII,EAAKT,EAAK,iBAAiBK,CAAG,EAClC,OAAO,KAAK,UAAUI,CAAE,CAC5B,EAIAT,EAAK,UAAU,OAAO,QAAQ,EAAI,UAAY,CAC1C,OAAOzB,EAAY,KAAM,SAAUqD,EAAI,CACnC,OAAQA,EAAG,MAAO,CACd,IAAK,GACD,OAAK,KAAK,OACH,CAAC,EAAa,KAAK,IAAI,CAAC,EADN,CAAC,EAAa,CAAC,EAE5C,IAAK,GACD,OAAAA,EAAG,KAAK,EACD,CAAC,EAAa,CAAC,EAC1B,IAAK,GAAG,MAAO,CAAC,CAAY,CAChC,CACJ,CAAC,CACL,EAIA5B,EAAK,UAAU,SAAW,UAAY,CAClC,OAAO,KAAK,QAAQ,CACxB,EAIAA,EAAK,UAAU,YAAc,UAAY,CACrC,GAAI,KAAK,QAAU,KAAK,OAAS,KAAK,UAAU,OAG5C,QAFIuC,EAAK,KAAK,UAAU,OAAS,KAAK,OAE/BA,GACH,KAAK,UAAU,IAAI,EACnB,EAAEA,CAGd,EAOAvC,EAAK,UAAU,cAAgB,SAAUhB,EAAG,CAExC,IAAIwD,EAAa,IAAIxC,EAAK,KAAK,OAAO,EACtCwC,EAAW,MAAQxD,EACnBwD,EAAW,UAAY,KAAK,UAAU,MAAM,CAACxD,CAAC,EAC9CwD,EAAW,KAAK,EAIhB,QAHIC,EAAU,KAAK,UAAU,OAAS,EAAIzD,EACtC0D,EAAgB1C,EAAK,iBAAiByC,CAAO,EAC7CE,EAAU,CAAC,EACNhF,EAAI8E,EAAS9E,EAAI+E,EAAe,EAAE/E,EACvCgF,EAAQ,KAAKhF,CAAC,EAGlB,QADI2D,EAAM,KAAK,UACRqB,EAAQ,QAAQ,CACnB,IAAIhF,EAAIgF,EAAQ,MAAM,EAClB,KAAK,QAAQrB,EAAI3D,CAAC,EAAG6E,EAAW,KAAK,CAAC,EAAI,IAC1CA,EAAW,QAAQlB,EAAI3D,CAAC,CAAC,EACrBA,EAAI,GACJgF,EAAQ,KAAK3C,EAAK,iBAAiBrC,CAAC,CAAC,EAGjD,CACA,OAAO6E,EAAW,QAAQ,CAC9B,EAMAxC,EAAK,UAAU,UAAY,SAAU8B,EAAGc,EAAG,CACvC,IAAIhB,EACJA,EAAKvC,EAAO,CAAC,KAAK,UAAUuD,CAAC,EAAG,KAAK,UAAUd,CAAC,CAAC,EAAG,CAAC,EAAG,KAAK,UAAUA,CAAC,EAAIF,EAAG,CAAC,EAAG,KAAK,UAAUgB,CAAC,EAAIhB,EAAG,CAAC,CAC/G,EAKA5B,EAAK,UAAU,cAAgB,SAAUrC,EAAG,CAUxC,QATIuC,EAAQ,KACR2C,EAASlF,EAAI,KAAK,UAAU,OAAS,EACrCmF,EAAO,KAAK,UAAUnF,CAAC,EACvBoF,EAAqB,SAAUC,EAAMlB,EAAG,CACxC,OAAI5B,EAAM,UAAU,OAAS4B,GAAK5B,EAAM,QAAQA,EAAM,UAAU4B,CAAC,EAAG5B,EAAM,UAAU8C,CAAI,CAAC,EAAI,IACzFA,EAAOlB,GAEJkB,CACX,EACOH,GAAQ,CACX,IAAII,EAAcjD,EAAK,mBAAmBrC,CAAC,EACvCuF,EAAiBD,EAAY,OAAOF,EAAoBE,EAAY,CAAC,CAAC,EACtEE,EAAY,KAAK,UAAUD,CAAc,EACzC,OAAOC,EAAc,KAAe,KAAK,QAAQL,EAAMK,CAAS,EAAI,GACpE,KAAK,UAAUxF,EAAGuF,CAAc,EAChCvF,EAAIuF,GAGJL,EAAS,EAEjB,CACJ,EAKA7C,EAAK,UAAU,YAAc,SAAUrC,EAAG,CAEtC,QADIkF,EAASlF,EAAI,EACVkF,GAAQ,CACX,IAAIpC,EAAKT,EAAK,iBAAiBrC,CAAC,EAC5B8C,GAAM,GAAK,KAAK,QAAQ,KAAK,UAAUA,CAAE,EAAG,KAAK,UAAU9C,CAAC,CAAC,EAAI,GACjE,KAAK,UAAUA,EAAG8C,CAAE,EACpB9C,EAAI8C,GAGJoC,EAAS,EAEjB,CACJ,EAQA7C,EAAK,UAAU,WAAa,SAAUhB,EAAG,CAErC,IAAIoE,EAAU,IAAIpD,EAAK,KAAK,gBAAgB,EAC5CoD,EAAQ,MAAQpE,EAGhB,QAFI2D,EAAU,CAAC,CAAC,EACZrB,EAAM,KAAK,UACRqB,EAAQ,QAAQ,CACnB,IAAIhF,EAAIgF,EAAQ,MAAM,EAClBhF,EAAI2D,EAAI,SACJ8B,EAAQ,OAASpE,GACjBoE,EAAQ,KAAK9B,EAAI3D,CAAC,CAAC,EACnBgF,EAAQ,KAAK,MAAMA,EAASjD,EAAc,CAAC,EAAGL,EAAOW,EAAK,mBAAmBrC,CAAC,CAAC,EAAG,EAAK,CAAC,GAEnF,KAAK,QAAQ2D,EAAI3D,CAAC,EAAGyF,EAAQ,KAAK,CAAC,EAAI,IAC5CA,EAAQ,QAAQ9B,EAAI3D,CAAC,CAAC,EACtBgF,EAAQ,KAAK,MAAMA,EAASjD,EAAc,CAAC,EAAGL,EAAOW,EAAK,mBAAmBrC,CAAC,CAAC,EAAG,EAAK,CAAC,GAGpG,CACA,OAAOyF,EAAQ,QAAQ,CAC3B,EAQApD,EAAK,UAAU,WAAa,SAAUhB,EAAG,CAErC,IAAIqE,EAAY,KAAK,UACjBD,EAAU,IAAIpD,EAAK,KAAK,gBAAgB,EAC5CoD,EAAQ,MAAQpE,EAChBoE,EAAQ,UAAYC,EAAU,MAAM,EAAGrE,CAAC,EACxCoE,EAAQ,KAAK,EAGb,QAFIE,EAAStD,EAAK,iBAAiBhB,EAAI,CAAC,EAAI,EACxC2D,EAAU,CAAC,EACNhF,EAAI2F,EAAQ3F,EAAIqB,EAAG,EAAErB,EAC1BgF,EAAQ,KAAK,MAAMA,EAASjD,EAAc,CAAC,EAAGL,EAAOW,EAAK,mBAAmBrC,CAAC,EAAE,OAAO,SAAUmC,EAAG,CAAE,OAAOA,EAAIuD,EAAU,MAAQ,CAAC,CAAC,EAAG,EAAK,CAAC,EAKlJ,KAHKrE,EAAI,GAAK,GACV2D,EAAQ,KAAK3D,CAAC,EAEX2D,EAAQ,QAAQ,CACnB,IAAIhF,EAAIgF,EAAQ,MAAM,EAClBhF,EAAI0F,EAAU,QACV,KAAK,QAAQA,EAAU1F,CAAC,EAAGyF,EAAQ,KAAK,CAAC,EAAI,IAC7CA,EAAQ,QAAQC,EAAU1F,CAAC,CAAC,EAC5BgF,EAAQ,KAAK,MAAMA,EAASjD,EAAc,CAAC,EAAGL,EAAOW,EAAK,mBAAmBrC,CAAC,CAAC,EAAG,EAAK,CAAC,EAGpG,CACA,OAAOyF,EAAQ,QAAQ,CAC3B,EAQApD,EAAK,UAAU,WAAa,SAAUhB,EAAG,CAGrC,QAFIoE,EAAU,KAAK,MAAM,EACrBvB,EAAS,CAAC,EACL,EAAI,EAAG,EAAI7C,EAAG,EAAE,EACrB6C,EAAO,KAAKuB,EAAQ,IAAI,CAAC,EAE7B,OAAOvB,CACX,EAKA7B,EAAK,UAAU,UAAY,SAAUuD,EAAM,CACvC,GAAI,CAACA,EAAK,OACN,MAAO,GAIX,QAFIlD,EAAM,EACNmD,EAAMD,EAAKlD,CAAG,EACT,EAAI,EAAG,EAAIkD,EAAK,OAAQ,EAAE,EAAG,CAClC,IAAIE,EAAO,KAAK,QAAQF,EAAK,CAAC,EAAGC,CAAG,EAChCC,EAAO,IACPpD,EAAM,EACNmD,EAAMD,EAAK,CAAC,EAEpB,CACA,OAAOlD,CACX,EAKAL,EAAK,UAAU,OAAS,UAAY,CAEhC,QADIuD,EAAO,CAAC,EACHlB,EAAK,EAAGA,EAAK,UAAU,OAAQA,IACpCkB,EAAKlB,CAAE,EAAI,UAAUA,CAAE,EAE3B,IAAI9B,EAAO,IAAIP,EAAK,KAAK,OAAO,EAChC,OAAAO,EAAK,KAAKgD,CAAI,EACPhD,EAAK,KAAK,CACrB,EACOP,CACX,EAAE,ECl4BK,MAAM0D,EAAe,OAAO,SAAS,UAAU,cAAiB,WACjE,SAAS,UAAU,aACnB,SAAUvF,EAAQwF,EAAc,CAC9B,MAAMC,EAAKD,IAAiB,GACtB,KAAK,UAAUxF,EAAQwF,CAAY,EACnC,KAAK,UAAUxF,EAAS,EAAGwF,CAAY,EACvCE,EAAKF,IAAiB,GACtB,KAAK,UAAUxF,EAAS,EAAGwF,CAAY,EACvC,KAAK,UAAUxF,EAAQwF,CAAY,EACzC,OAAQ,OAAOE,CAAE,GAAK,IAAO,OAAOD,CAAE,CAC1C,ECbW,MAAME,CAAO,CACxB,YAAY5F,EAAMC,EAAS,EAAG,CAC1B,KAAK,YAAc,IAAI,YACvB,KAAK,KAAOD,EACZ,KAAK,OAASC,CAClB,CACA,OAAQ,CACJ,MAAMN,EAAQ,KAAK,KAAK,SAAS,KAAK,MAAM,EAC5C,YAAK,QAAU,EACRA,CACX,CACA,QAAS,CACL,MAAMA,EAAQ,KAAK,KAAK,UAAU,KAAK,OAAQ,EAAI,EACnD,YAAK,QAAU,EACRA,CACX,CACA,QAAS,CACL,MAAMA,EAAQ,KAAK,KAAK,UAAU,KAAK,OAAQ,EAAI,EACnD,YAAK,QAAU,EACRA,CACX,CACA,QAAS,CACL,MAAMA,EAAQ6F,EAAa,KAAK,KAAK,KAAM,KAAK,OAAQ,EAAI,EAC5D,YAAK,QAAU,EACR7F,CACX,CACA,QAAS,CACL,MAAMkG,EAAS,KAAK,OAAO,EAC3B,GAAI,KAAK,OAASA,EAAS,KAAK,KAAK,WACjC,MAAM,IAAI,MAAM,iBAAiBA,4BAAiC,EAEtE,MAAMlG,EAAQ,KAAK,YAAY,OAAO,IAAI,WAAW,KAAK,KAAK,OAAQ,KAAK,KAAK,WAAa,KAAK,OAAQkG,CAAM,CAAC,EAClH,YAAK,QAAUA,EACRlG,CACX,CACA,cAAcmG,EAASC,EAAW,CAC9B,MAAMF,EAAS,KAAK,OAAO,EAC3B,GAAI,KAAK,OAASA,EAAS,KAAK,KAAK,WACjC,MAAM,IAAI,MAAM,0BAA0BA,4BAAiC,EAE/E,MAAMlC,EAAS,CAAC,EACVqC,EAAY,KAAK,OAASH,EAChC,GAAI,CACA,KAAO,KAAK,OAASG,GACjBrC,EAAO,KAAK,CAACmC,EAAQ,IAAI,EAAGC,EAAU,IAAI,CAAC,CAAC,CAEpD,OACOE,EAAP,CACI,MAAM,IAAI,MAAM,kCAAkCA,EAAI,SAAS,CACnE,CACA,GAAI,KAAK,SAAWD,EAChB,MAAM,IAAI,MAAM,2BAA2B,KAAK,OAASA,EAAYH,6BAAkCA,IAAS,EAEpH,OAAOlC,CACX,CACA,IAAImC,EAASC,EAAW,CACpB,MAAMF,EAAS,KAAK,OAAO,EAC3B,GAAI,KAAK,OAASA,EAAS,KAAK,KAAK,WACjC,MAAM,IAAI,MAAM,cAAcA,4BAAiC,EAEnE,MAAMlC,EAAS,IAAI,IACbqC,EAAY,KAAK,OAASH,EAChC,GAAI,CACA,KAAO,KAAK,OAASG,GAAW,CAC5B,MAAME,EAAMJ,EAAQ,IAAI,EAClBnG,EAAQoG,EAAU,IAAI,EACtBI,EAAgBxC,EAAO,IAAIuC,CAAG,EACpC,GAAIC,GAAiB,KACjB,MAAM,IAAI,MAAM,iBAAiB,OAAOD,CAAG,MAAM,OAAOC,CAAa,QAAQ,OAAOxG,CAAK,IAAI,EAEjGgE,EAAO,IAAIuC,EAAKvG,CAAK,CACzB,CACJ,OACOsG,EAAP,CACI,MAAM,IAAI,MAAM,sBAAsBA,EAAI,SAAS,CACvD,CACA,GAAI,KAAK,SAAWD,EAChB,MAAM,IAAI,MAAM,eAAe,KAAK,OAASA,EAAYH,6BAAkCA,IAAS,EAExG,OAAOlC,CACX,CACJ,CCjFO,MAAM,EAAa,OAAO,OAAO,CAAC,IAAK,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAAE,CAAC,EAClE,IAAI,GACV,SAAUyC,EAAQ,CACfA,EAAOA,EAAO,IAAS,CAAC,EAAI,MAC5BA,EAAOA,EAAO,OAAY,CAAC,EAAI,SAC/BA,EAAOA,EAAO,OAAY,CAAC,EAAI,SAC/BA,EAAOA,EAAO,OAAY,CAAC,EAAI,SAC/BA,EAAOA,EAAO,QAAa,CAAC,EAAI,UAChCA,EAAOA,EAAO,QAAa,CAAC,EAAI,UAChCA,EAAOA,EAAO,MAAW,CAAC,EAAI,QAC9BA,EAAOA,EAAO,cAAmB,CAAC,EAAI,gBACtCA,EAAOA,EAAO,YAAiB,CAAC,EAAI,cACpCA,EAAOA,EAAO,WAAgB,CAAC,EAAI,aACnCA,EAAOA,EAAO,iBAAsB,EAAE,EAAI,mBAC1CA,EAAOA,EAAO,WAAgB,EAAE,EAAI,aACpCA,EAAOA,EAAO,SAAc,EAAE,EAAI,WAClCA,EAAOA,EAAO,eAAoB,EAAE,EAAI,iBACxCA,EAAOA,EAAO,eAAoB,EAAE,EAAI,iBACxCA,EAAOA,EAAO,SAAc,EAAE,EAAI,WAClCA,EAAOA,EAAO,IAAS,EAAE,EAAI,KACjC,GAAG,IAAW,EAAS,CAAC,EAAE,EACnB,SAASC,EAAcC,EAAQ,CAClC,OAAOA,GAAU,EAAO,KAAOA,GAAU,EAAO,GACpD,CClBO,SAASC,EAAWvG,EAAMwG,EAAa,CAC1C,GAAIA,EAAc,SAAoBxG,EAAK,WACvC,MAAO,CAAE,UAAW,CAAE,EAE1B,GAAI,CAAC,QAAiB,CAACyG,EAAKhH,IAAMgH,IAAQzG,EAAK,SAASwG,EAAc/G,CAAC,CAAC,EACpE,MAAM,IAAI,MAAM,wBAAwB,MAAgBgH,GAAQA,EAAI,SAAS,EAAE,EAAE,SAAS,EAAG,GAAG,CAAC,EAAE,KAAK,GAAG,cAAc,MAAM,KAAK,EAAY,CAACjG,EAAGf,IAAMO,EACrJ,SAASwG,EAAc/G,CAAC,EACxB,SAAS,EAAE,EACX,SAAS,EAAG,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,EAEvC,MAAO,CACH,MAAO,CAAE,YAAa,GAAI,EAC1B,UAAW,QACf,CACJ,CAIO,SAASiH,EAAY,CAAE,KAAA1G,EAAM,YAAAwG,EAAa,aAAAG,CAAc,EAAG,CAC9D,GAAIH,EAAyB,EAA8B,GAAKxG,EAAK,WACjE,MAAO,CAAE,UAAW,CAAE,EAE1B,MAAM4G,EAAe,IAAIhB,EAAO5F,EAAMwG,CAAW,EAC3CF,EAASM,EAAa,MAAM,EAC5BC,EAAeD,EAAa,OAAO,EACzC,GAAIC,EAAe,OAAO,iBACtB,MAAM,IAAI,MAAM,yBAAyBA,gBAA2B,EAExE,MAAMC,EAAkBF,EAAa,OAAS,OAAOC,CAAY,EACjE,GAAIC,EAAkB9G,EAAK,WACvB,MAAO,CAAE,UAAW,CAAE,EAE1B,GAAI,CAACqG,EAAcC,CAAM,EAMrB,MAAO,CAAE,OALM,CACX,KAAM,UACN,OAAAA,EACA,KAAM,IAAI,WAAWtG,EAAK,OAAQA,EAAK,WAAa4G,EAAa,OAAQ,OAAOC,CAAY,CAAC,CACjG,EACiB,UAAWC,EAAkBN,CAAY,EAE9D,MAAMO,EAAa,IAAI,SAAS/G,EAAK,OAAQA,EAAK,WAAa4G,EAAa,OAAQ,OAAOC,CAAY,CAAC,EAClGG,EAAS,IAAIpB,EAAOmB,CAAU,EACpC,OAAQT,EAAQ,CACZ,KAAK,SAAe,CAChB,MAAMW,EAAUD,EAAO,OAAO,EACxBE,EAAUF,EAAO,OAAO,EAE9B,MAAO,CAAE,OADM,CAAE,KAAM,SAAU,QAAAC,EAAS,QAAAC,CAAQ,EACjC,UAAWJ,EAAkBN,CAAY,CAC9D,CACA,KAAK,SAAe,CAChB,MAAMW,EAAeH,EAAO,OAAO,EAC7BI,EAAqBJ,EAAO,OAAO,EACnCK,EAAaL,EAAO,OAAO,EAOjC,MAAO,CAAE,OANM,CACX,KAAM,SACN,aAAAG,EACA,mBAAAC,EACA,WAAAC,CACJ,EACiB,UAAWP,EAAkBN,CAAY,CAC9D,CACA,KAAK,SAAe,CAChB,MAAMc,EAAKN,EAAO,OAAO,EACnBO,EAAOP,EAAO,OAAO,EACrBQ,EAAWR,EAAO,OAAO,EACzBS,EAAUT,EAAO,OAAO,EAC9B,GAAIA,EAAO,OAASS,EAAUV,EAAW,WACrC,MAAM,IAAI,MAAM,sBAAsBU,4BAAkC,EAE5E,MAAM3H,EAAO,IAAI,WAAWiH,EAAW,OAAO,MAAMA,EAAW,WAAaC,EAAO,OAAQD,EAAW,WAAaC,EAAO,OAASS,CAAO,CAAC,EAC3I,OAAAT,EAAO,QAAUS,EAQV,CAAE,OAPM,CACX,KAAM,SACN,GAAAH,EACA,SAAAE,EACA,KAAAD,EACA,KAAAzH,CACJ,EACiB,UAAWgH,EAAkBN,CAAY,CAC9D,CACA,KAAK,UAAgB,CACjB,MAAMkB,EAAYV,EAAO,OAAO,EAC1BW,EAAWX,EAAO,OAAO,EACzBY,EAAYZ,EAAO,OAAO,EAC1Ba,EAAkBb,EAAO,OAAO,EAChCc,EAAWd,EAAO,IAAKtH,GAAMA,EAAE,OAAO,EAAIA,GAAMA,EAAE,OAAO,CAAC,EAShE,MAAO,CAAE,OARM,CACX,KAAM,UACN,GAAIgI,EACJ,SAAAC,EACA,MAAOC,EACP,gBAAAC,EACA,SAAAC,CACJ,EACiB,UAAWhB,EAAkBN,CAAY,CAC9D,CACA,KAAK,UAAgB,CACjB,MAAMkB,EAAYV,EAAO,OAAO,EAC1Be,EAAWf,EAAO,OAAO,EACzBgB,EAAUhB,EAAO,OAAO,EACxBiB,EAAcjB,EAAO,OAAO,EAC5BlH,EAAO,IAAI,WAAWiH,EAAW,OAAO,MAAMA,EAAW,WAAaC,EAAO,OAAQD,EAAW,WAAaA,EAAW,UAAU,CAAC,EASzI,MAAO,CAAE,OARM,CACX,KAAM,UACN,UAAAW,EACA,SAAAK,EACA,QAAAC,EACA,YAAAC,EACA,KAAAnI,CACJ,EACiB,UAAWgH,EAAkBN,CAAY,CAC9D,CACA,KAAK,QAAc,CACf,MAAM0B,EAAYlB,EAAO,OAAO,EAC1BmB,EAAUnB,EAAO,OAAO,EACxBoB,EAAmBpB,EAAO,OAAO,EACjCqB,EAAkBrB,EAAO,OAAO,EAChCsB,EAActB,EAAO,OAAO,EAC5BuB,EAAmB,OAAOvB,EAAO,OAAO,CAAC,EAC/C,GAAIuB,EAAmBvB,EAAO,OAASD,EAAW,WAC9C,MAAM,IAAI,MAAM,oDAAoD,EAExE,MAAMyB,EAAU,IAAI,WAAWzB,EAAW,OAAO,MAAMA,EAAW,WAAaC,EAAO,OAAQD,EAAW,WAAaC,EAAO,OAASuB,CAAgB,CAAC,EAUvJ,MAAO,CAAE,OATM,CACX,KAAM,QACN,iBAAkBL,EAClB,eAAgBC,EAChB,YAAAG,EACA,iBAAAF,EACA,gBAAAC,EACA,QAAAG,CACJ,EACiB,UAAW1B,EAAkBN,CAAY,CAC9D,CACA,KAAK,gBAAsB,CACvB,MAAMkB,EAAYV,EAAO,OAAO,EAC1BwB,EAAUxB,EAAO,cAAetH,GAAMA,EAAE,OAAO,EAAIA,GAAMA,EAAE,OAAO,CAAC,EAMzE,MAAO,CAAE,OALM,CACX,KAAM,eACN,UAAAgI,EACA,QAAAc,CACJ,EACiB,UAAW1B,EAAkBN,CAAY,CAC9D,CACA,KAAK,cAAoB,CACrB,MAAMiC,EAAmBzB,EAAO,OAAO,EACjC0B,EAAiB1B,EAAO,OAAO,EAC/B2B,EAAmB3B,EAAO,OAAO,EACjC4B,EAAc5B,EAAO,OAAO,EAC5B6B,EAAsB7B,EAAO,IAAKtH,GAAMA,EAAE,OAAO,EAAIA,GAAMA,EAAE,OAAO,CAAC,EACrEoJ,EAAqB9B,EAAO,OAAO,EACnCsB,EAActB,EAAO,OAAO,EAC5B+B,EAAiB/B,EAAO,OAAO,EAC/BoB,EAAmBpB,EAAO,OAAO,EAavC,MAAO,CAAE,OAZM,CACX,KAAM,aACN,iBAAAyB,EACA,eAAAC,EACA,iBAAAC,EACA,YAAAC,EACA,oBAAAC,EACA,mBAAAC,EACA,YAAAR,EACA,eAAAS,EACA,iBAAAX,CACJ,EACiB,UAAWtB,EAAkBN,CAAY,CAC9D,CACA,KAAK,aAAmB,CACpB,MAAMwB,EAAUhB,EAAO,OAAO,EACxBgC,EAAahC,EAAO,OAAO,EAC3BO,EAAOP,EAAO,OAAO,EACrBiC,EAAYjC,EAAO,OAAO,EAC1BS,EAAUT,EAAO,OAAO,EAC9B,GAAI,OAAOD,EAAW,WAAaC,EAAO,MAAM,EAAIS,EAAU,OAAO,iBACjE,MAAM,IAAI,MAAM,yBAAyBA,GAAS,EAEtD,GAAIT,EAAO,OAAS,OAAOS,CAAO,EAAI,EAAYV,EAAW,WACzD,MAAM,IAAI,MAAM,0BAA0BU,4BAAkC,EAEhF,MAAM3H,EAAO,IAAI,WAAWiH,EAAW,OAAO,MAAMA,EAAW,WAAaC,EAAO,OAAQD,EAAW,WAAaC,EAAO,OAAS,OAAOS,CAAO,CAAC,CAAC,EACnJT,EAAO,QAAU,OAAOS,CAAO,EAC/B,MAAMyB,EAAYlC,EAAO,OACnBmC,EAAcnC,EAAO,OAAO,EAClC,GAAIL,GAAgBwC,IAAgB,EAAG,CACnC,MAAMC,EAAY,EAAM,IAAI,SAASrC,EAAW,OAAQA,EAAW,WAAYmC,CAAS,CAAC,EACzF,GAAIE,IAAcD,EACd,MAAM,IAAI,MAAM,uCAAuCA,aAAuBC,GAAW,CAEjG,CASA,MAAO,CAAE,OARM,CACX,KAAM,aACN,QAAApB,EACA,WAAAgB,EACA,KAAAzB,EACA,UAAA0B,EACA,KAAAnJ,CACJ,EACiB,UAAWgH,EAAkBN,CAAY,CAC9D,CACA,KAAK,mBAAyB,CAC1B,MAAMvG,EAAS+G,EAAO,OAAO,EACvBnB,EAASmB,EAAO,OAAO,EACvBgB,EAAUhB,EAAO,OAAO,EACxBgC,EAAahC,EAAO,OAAO,EAC3BqC,EAAWrC,EAAO,OAAO,EACzBO,EAAOP,EAAO,OAAO,EACrBiC,EAAYjC,EAAO,OAAO,EAWhC,MAAO,CAAE,OAVM,CACX,KAAM,kBACN,OAAA/G,EACA,OAAA4F,EACA,QAAAmC,EACA,WAAAgB,EACA,SAAAK,EACA,KAAA9B,EACA,UAAA0B,CACJ,EACiB,UAAWnC,EAAkBN,CAAY,CAC9D,CACA,KAAK,aAAmB,CACpB,MAAM8C,EAAetC,EAAO,OAAO,EAC7BuC,EAAcvC,EAAO,OAAO,EAC5BwC,EAAexC,EAAO,OAAO,EAC7ByC,EAAkBzC,EAAO,OAAO,EAChC0C,EAAgB1C,EAAO,OAAO,EAC9B2C,EAAa3C,EAAO,OAAO,EAC3ByB,EAAmBzB,EAAO,OAAO,EACjC0B,EAAiB1B,EAAO,OAAO,EAC/B4C,EAAuB5C,EAAO,IAAKtH,GAAMA,EAAE,OAAO,EAAIA,GAAMA,EAAE,OAAO,CAAC,EAa5E,MAAO,CAAE,OAZM,CACX,KAAM,aACN,aAAA4J,EACA,YAAAC,EACA,aAAAC,EACA,gBAAAC,EACA,cAAAC,EACA,WAAAC,EACA,iBAAAlB,EACA,eAAAC,EACA,qBAAAkB,CACJ,EACiB,UAAW9C,EAAkBN,CAAY,CAC9D,CACA,KAAK,WAAiB,CAClB,MAAMe,EAAOP,EAAO,OAAO,EAG3B,MAAO,CAAE,OADM,CAAE,KAAM,WAAY,SADlBA,EAAO,IAAKtH,GAAMA,EAAE,OAAO,EAAIA,GAAMA,EAAE,OAAO,CAAC,EACnB,KAAA6H,CAAK,EACjC,UAAWT,EAAkBN,CAAY,CAC9D,CACA,KAAK,iBAAuB,CACxB,MAAMvG,EAAS+G,EAAO,OAAO,EACvBnB,EAASmB,EAAO,OAAO,EACvBO,EAAOP,EAAO,OAAO,EAO3B,MAAO,CAAE,OANM,CACX,KAAM,gBACN,OAAA/G,EACA,OAAA4F,EACA,KAAA0B,CACJ,EACiB,UAAWT,EAAkBN,CAAY,CAC9D,CACA,KAAK,iBAAuB,CACxB,MAAMqD,EAAc7C,EAAO,MAAM,EAC3B8C,EAAa9C,EAAO,OAAO,EAC3B+C,EAAc/C,EAAO,OAAO,EAOlC,MAAO,CAAE,OANM,CACX,KAAM,gBACN,YAAA6C,EACA,WAAAC,EACA,YAAAC,CACJ,EACiB,UAAWjD,EAAkBN,CAAY,CAC9D,CACA,KAAK,WAMD,MAAO,CAAE,OAJM,CACX,KAAM,UACN,eAHmBQ,EAAO,OAAO,CAIrC,EACiB,UAAWF,EAAkBN,CAAY,CAElE,CACJ,CC7RO,SAASwD,EAAchG,EAAOrE,EAAOsK,EAAU,CAClD,IAAIC,EAAM,EACNC,EAAOnG,EAAM,OACjB,GAAImG,IAAS,EACT,MAAO,GAEX,MAAMC,EAAgBH,EAAStK,CAAK,EACpC,KAAOuK,EAAMC,GAAM,CACf,MAAME,EAAOH,EAAMC,IAAU,EACJF,EAASjG,EAAMqG,CAAG,EAAE,CAAC,CAAC,EACxBD,EACnBF,EAAMG,EAAM,EAGZF,EAAOE,CAEf,CACA,OAAOF,CACX,CCZO,MAAMG,CAAY,CACrB,YAAYC,EAAQ,CAMhB,GALA,KAAK,WAAaA,EAAO,WACzB,KAAK,iBAAmBA,EAAO,iBAC/B,KAAK,UAAYA,EAAO,UACxB,KAAK,QAAUA,EAAO,QACtB,KAAK,QAAUA,EAAO,QAClB,KAAK,WAAW,qBAAuB,GACvC,MAAM,IAAI,MAAM,4DAA4D,CAEpF,CASA,QAAQC,EAAO,CACX,GAAI,KAAK,UAAYA,EAAM,QACvB,MAAM,IAAI,MAAM,qEAAqE,EAEzF,IAAIC,EAAO,OAAO,KAAK,YAAY,EAAID,EAAM,YAAY,CAAC,EAE1D,OAAIC,IAAS,IACTA,EAAO,OAAO,KAAK,WAAW,iBAAmBD,EAAM,WAAW,gBAAgB,GAE/E,KAAK,QAAU,CAACC,EAAOA,CAClC,CAKA,iBAAkB,CACd,GAAI,CAAC,KAAK,oBACN,MAAM,IAAI,MAAM,sDAAsD,EAE1E,OAAO,KAAK,oBAAoB,KAAK,EAAI,CAC7C,CAKA,YAAa,CACT,GAAI,CAAC,KAAK,oBACN,MAAM,IAAI,MAAM,yDAAyD,EAE7E,MAAMC,EAAS,KAAK,oBAAoB,KAAK,EAC7C,GAAI,CAACA,EACD,MAAM,IAAI,MAAM,wFAAwF,KAAK,WAAW,kBAAkB,EAE9I,MAAMC,EAASD,EAAO,QAAQA,EAAO,KAAK,EACpC,CAAC1C,CAAO,EAAI2C,EAClB,GAAI,KAAK,WAAa,MAAa3C,EAAU,KAAK,UAC9C,MAAM,IAAI,MAAM,qCAAqCA,0BAAgC,KAAK,iCAAiC,KAAK,WAAW,kBAAkB,EAEjK,GAAI,KAAK,SAAW,MAAaA,EAAU,KAAK,QAC5C,MAAM,IAAI,MAAM,qCAAqCA,qBAA2B,KAAK,+BAA+B,KAAK,WAAW,kBAAkB,EAE1J,MAAM4C,EAAaF,EAAO,QAAQA,EAAO,MAAQ,CAAC,EAClD,GAAIE,GAAc,KAAK,SACnB,GAAI,KAAK,WAAa,MAAaA,EAAW,CAAC,GAAK,KAAK,UACrD,OAAAF,EAAO,QACP,KAAK,oBAAoB,QAAQA,CAAM,EAChCC,UAGNC,IACD,KAAK,SAAW,MAAaA,EAAW,CAAC,GAAK,KAAK,SACnD,OAAAF,EAAO,QACP,KAAK,oBAAoB,QAAQA,CAAM,EAChCC,EAGf,YAAK,oBAAoB,IAAI,EACtBA,CACX,CAKA,mBAAoB,CAChB,OAAO,KAAK,qBAAuB,IACvC,CACA,MAAM,mBAAmBE,EAAU,CAC/B,MAAMC,EAAU,KAAK,QACrB,KAAK,oBAAsB,IAAIhJ,EAAK,CAACG,EAAGC,IAAM,CAC1C,MAAM6I,EAAW9I,EAAE,QAAQA,EAAE,KAAK,IAAI,CAAC,EACjC+I,EAAW9I,EAAE,QAAQA,EAAE,KAAK,IAAI,CAAC,EACvC,OAAI4I,EACIC,GAAY,KACL,GAEFC,GAAY,KACV,EAEJ,OAAOA,EAAWD,CAAQ,EAG7BA,GAAY,KACL,EAEFC,GAAY,KACV,GAEJ,OAAOD,EAAWC,CAAQ,CAEzC,CAAC,EACD,IAAIC,EACAC,EACJ,SAAW,CAACxD,EAAWzH,CAAM,IAAK,KAAK,WAAW,qBAC1CgL,GAA2B,MAAahL,EAASgL,KACjDA,EAA0BhL,IAE1B,CAAC,KAAK,kBAAoB,KAAK,iBAAiB,IAAIyH,CAAS,KACzDwD,GAAmC,MACnCjL,EAASiL,KACTA,EAAkCjL,GAI9C,GAAIgL,GAA2B,MAAaC,GAAmC,KAC3E,OAGJ,MAAMC,EAAwBF,EAA0B,KAAK,WAAW,mBAClEG,EAAiB,MAAMP,EAAS,KAAKK,EAAiCC,EAAwBD,CAA+B,EAC7HG,EAAqB,IAAI,SAASD,EAAe,OAAQA,EAAe,WAAYA,EAAe,UAAU,EACnH,IAAInL,EAAS,EACb,QAAS0D,EAASA,EAAS+C,EAAY,CAAE,KAAM2E,EAAoB,YAAapL,EAAQ,aAAc,EAAK,CAAC,EACxG0D,EAAO,OAAQ1D,GAAU0D,EAAO,UAAW,CAI3C,GAHIA,EAAO,OAAO,OAAS,gBAGvBA,EAAO,OAAO,QAAQ,SAAW,GAChC,KAAK,kBAAoB,CAAC,KAAK,iBAAiB,IAAIA,EAAO,OAAO,SAAS,EAC5E,SAEJA,EAAO,OAAO,QAAQ,KAAK,CAAC,CAACoH,CAAQ,EAAG,CAACC,CAAQ,IAAM,OAAOD,EAAWC,CAAQ,CAAC,EAC9EF,GAIAnH,EAAO,OAAO,QAAQ,QAAQ,EAElC,QAASlE,EAAI,EAAGA,EAAIkE,EAAO,OAAO,QAAQ,OAAQlE,IAAK,CACnD,KAAM,CAACuI,CAAO,EAAIrE,EAAO,OAAO,QAAQlE,CAAC,EACzC,GAAIuI,EAAU,KAAK,WAAW,iBAC1B,MAAM,IAAI,MAAM,8CAA8CrE,EAAO,OAAO,2BAA2BqE,2CAAiD,KAAK,WAAW,wCAAwC,KAAK,WAAW,kBAAkB,EAEtP,GAAIA,EAAU,KAAK,WAAW,eAC1B,MAAM,IAAI,MAAM,8CAA8CrE,EAAO,OAAO,2BAA2BqE,uCAA6C,KAAK,WAAW,sCAAsC,KAAK,WAAW,kBAAkB,CAEpP,CACA,IAAIsD,EAAa,EAWjB,GAVIR,EACI,KAAK,SAAW,OAChBQ,EAAatB,EAAcrG,EAAO,OAAO,QAAS,KAAK,QAAUqE,GAAY,CAACA,CAAO,GAIrF,KAAK,WAAa,OAClBsD,EAAatB,EAAcrG,EAAO,OAAO,QAAS,KAAK,UAAYqE,GAAYA,CAAO,GAG1F,EAAAsD,GAAc3H,EAAO,OAAO,QAAQ,QAGxC,IAAImH,GACA,GAAI,KAAK,WAAa,MAAanH,EAAO,OAAO,QAAQ2H,CAAU,EAAE,CAAC,EAAI,KAAK,UAC3E,iBAIA,KAAK,SAAW,MAAa3H,EAAO,OAAO,QAAQ2H,CAAU,EAAE,CAAC,EAAI,KAAK,QACzE,SAGR,KAAK,oBAAoB,KAAK,CAC1B,MAAOA,EACP,UAAW3H,EAAO,OAAO,UACzB,QAASA,EAAO,OAAO,OAC3B,CAAC,EACL,CACA,GAAI1D,IAAWoL,EAAmB,WAC9B,MAAM,IAAI,MAAM,GAAGA,EAAmB,WAAapL,4CAAiD,CAE5G,CACA,aAAc,CACV,GAAI,CAAC,KAAK,oBACN,OAAO,KAAK,QAAU,KAAK,WAAW,eAAiB,KAAK,WAAW,iBAE3E,MAAMyK,EAAS,KAAK,oBAAoB,KAAK,EAC7C,GAAI,CAACA,EACD,MAAM,IAAI,MAAM,+CAA+C,KAAK,WAAW,kBAAkB,EAErG,OAAOA,EAAO,QAAQA,EAAO,KAAK,EAAE,CAAC,CACzC,CACJ,CC5MO,MAAMa,CAAkB,CAC3B,YAAYC,EAAM,CACd,KAAK,gBAAkB,CAAC,EACxB,KAAK,SAAWA,EAAK,SACrB,KAAK,aAAeA,EAAK,aACzB,KAAK,kBAAoBA,EAAK,kBAC9B,KAAK,gBAAkBA,EAAK,gBAC5B,KAAK,WAAaA,EAAK,WACvB,KAAK,mBAAqBA,EAAK,mBAC/B,KAAK,aAAeA,EAAK,aACzB,KAAK,YAAcA,EAAK,YACxB,KAAK,uBAAyBA,EAAK,uBACnC,KAAK,OAASA,EAAK,OACnB,KAAK,OAASA,EAAK,OACnB,UAAWC,KAASD,EAAK,cACjB,KAAK,kBAAoB,MAAaC,EAAM,iBAAmB,KAAK,oBACpE,KAAK,iBAAmBA,EAAM,mBAE9B,KAAK,gBAAkB,MAAaA,EAAM,eAAiB,KAAK,kBAChE,KAAK,eAAiBA,EAAM,gBAGpC,UAAWC,KAAcF,EAAK,mBACtB,KAAK,qBAAuB,MAAaE,EAAW,QAAU,KAAK,uBACnE,KAAK,oBAAsBA,EAAW,UAEtC,KAAK,mBAAqB,MAAaA,EAAW,QAAU,KAAK,qBACjE,KAAK,kBAAoBA,EAAW,QAGhD,CACA,iBAAiBC,EAAS,CACtB,OAAO,IAAI,MAAM,GAAGA,cAAoB,KAAK,OAAO,UAAU,CAClE,CACA,aAAa,WAAW,CAAE,SAAAd,EAAU,mBAAAe,CAAoB,EAAG,CACvD,MAAMC,EAAO,MAAMhB,EAAS,KAAK,EACjC,IAAIiB,EACJ,CACI,MAAMC,EAAe,MAAMlB,EAAS,KAAK,GAAI,OAAO,SAAwC,EAAgC,CAAC,CAAC,EACxHmB,EAAmB,IAAI,SAASD,EAAa,OAAQA,EAAa,WAAYA,EAAa,UAAU,EACtGxF,EAAWyF,EAAkB,CAAC,EACnC,MAAMC,EAAeD,EAAiB,aAAa,SAAwC,EAAG,EAAI,EAC5FE,EAAe,MAAMrB,EAAS,KAAK,OAAO,QAAiB,EAC7C,GAAiC,GAAKoB,CAAY,EAChEE,EAAezF,EAAY,CAC7B,KAAM,IAAI,SAASwF,EAAa,OAAQA,EAAa,WAAYA,EAAa,UAAU,EACxF,YAAa,EACb,aAAc,EAClB,CAAC,EACD,GAAIC,EAAa,QAAQ,OAAS,SAC9B,MAAM,IAAI,MAAM,qDAAqDA,EAAa,QAAQ,MAAQ,WAAW,EAEjH,GAAIA,EAAa,YAAcD,EAAa,WACxC,MAAM,IAAI,MAAM,GAAGA,EAAa,WAAaC,EAAa,gDAAgD,EAE9GL,EAASK,EAAa,MAC1B,CACA,SAASC,EAAiBT,EAAS,CAC/B,OAAO,IAAI,MAAM,GAAGA,cAAoBG,EAAO,UAAU,CAC7D,CACA,IAAIO,EACAC,EACJ,CACI,MAAMC,EAAyB,OAAO,SACd,EACQ,EACP,EACA,CAAC,EACpBC,EAA2B,OACb,EACY,EACT,EACM,EACf,EACV,QAAiB,EACrB,GAAIX,EAAOU,EAAyBC,EAChC,MAAMJ,EAAiB,cAAcP,kCAAqC,EAE9EQ,EAAeR,EAAOW,EACtB,MAAMC,EAAe,MAAM5B,EAAS,KAAKwB,EAAcG,CAAwB,EAC/EF,EAAqB,IAAI,SAASG,EAAa,OAAQA,EAAa,WAAYA,EAAa,UAAU,CAC3G,CACA,GAAI,CACKlG,EAAW+F,EAAoBA,EAAmB,WAAa,QAAiB,CACzF,OACO/K,EAAP,CACI,MAAM6K,EAAiB7K,EAAM,OAAO,CACxC,CACA,IAAImL,EACJ,CACI,MAAMC,EAAejG,EAAY,CAC7B,KAAM4F,EACN,YAAa,EACb,aAAc,EAClB,CAAC,EACD,GAAIK,EAAa,QAAQ,OAAS,SAC9B,MAAMP,EAAiB,kDAAkDC,aAAwBM,EAAa,QAAQ,MAAQ,WAAW,EAE7I,GAAIA,EAAa,YAAcL,EAAmB,WAAa,SAC3D,MAAMF,EAAiB,GAAGE,EAAmB,WAAa,SAAoBK,EAAa,gDAAgD,EAE/ID,EAASC,EAAa,MAC1B,CACA,GAAID,EAAO,eAAiB,GACxB,MAAMN,EAAiB,qBAAqB,EAGhD,MAAMQ,EAAe,IAAI,WACL,EACY,EACR,EACO,CAAC,EAChCA,EAAa,IAAI,IAAI,WAAWN,EAAmB,OAAQA,EAAmB,WAAYM,EAAa,UAAU,CAAC,EAElH,MAAMC,EAAiB,MAAMhC,EAAS,KAAK6B,EAAO,aAAcL,EAAeK,EAAO,YAAY,EAClG,GAAIA,EAAO,aAAe,EAAG,CACzB,IAAIrF,EAAa,EAAU,EAI3B,GAHAA,EAAa,EAAYA,EAAYwF,CAAc,EACnDxF,EAAa,EAAYA,EAAYuF,CAAY,EACjDvF,EAAa,EAAWA,CAAU,EAC9BA,IAAeqF,EAAO,WACtB,MAAMN,EAAiB,yBAAyB/E,eAAwBqF,EAAO,aAAa,CAEpG,CACA,MAAMI,EAAY,IAAI,SAASD,EAAe,OAAQA,EAAe,WAAYA,EAAe,UAAU,EACpGE,EAAe,IAAI,IACnBC,EAAc,IAAI,IAClBC,EAAe,CAAC,EAChBC,EAAoB,CAAC,EACrBC,EAAkB,CAAC,EACnBC,EAAyB,IAAI,IACnC,IAAIC,EACApN,EAAS,EACb,QAAS0D,EAASA,EAAS+C,EAAY,CAAE,KAAMoG,EAAW,YAAa7M,EAAQ,aAAc,EAAK,CAAC,EAC/F0D,EAAO,OAAQ1D,GAAU0D,EAAO,UAChC,OAAQA,EAAO,OAAO,KAAM,CACxB,IAAK,SACDqJ,EAAY,IAAIrJ,EAAO,OAAO,GAAIA,EAAO,MAAM,EAC/C,MACJ,IAAK,UACDoJ,EAAa,IAAIpJ,EAAO,OAAO,GAAIA,EAAO,MAAM,EAChD,MACJ,IAAK,aACDsJ,EAAa,KAAKtJ,EAAO,MAAM,EAC/B,MACJ,IAAK,kBACDuJ,EAAkB,KAAKvJ,EAAO,MAAM,EACpC,MACJ,IAAK,gBACDwJ,EAAgB,KAAKxJ,EAAO,MAAM,EAClC,MACJ,IAAK,aACD,GAAI0J,EACA,MAAMjB,EAAiB,6BAA6B,EAExDiB,EAAa1J,EAAO,OACpB,MACJ,IAAK,gBACDyJ,EAAuB,IAAIzJ,EAAO,OAAO,YAAaA,EAAO,MAAM,EACnE,MACJ,IAAK,SACL,IAAK,SACL,IAAK,UACL,IAAK,QACL,IAAK,eACL,IAAK,aACL,IAAK,WACL,IAAK,UACD,MAAMyI,EAAiB,GAAGzI,EAAO,OAAO,0CAA0C,EACtF,IAAK,UACD,KACR,CAEJ,GAAI1D,IAAW6M,EAAU,WACrB,MAAMV,EAAiB,GAAGU,EAAU,WAAa7M,oCAAyC,EAE9F,OAAO,IAAIsL,EAAkB,CACzB,SAAAV,EACA,aAAAoC,EACA,kBAAAC,EACA,gBAAAC,EACA,WAAAE,EACA,mBAAAzB,EACA,aAAAmB,EACA,YAAAC,EACA,uBAAAI,EACA,OAAAtB,EACA,OAAAY,CACJ,CAAC,CACL,CACA,MAAO,aAAalB,EAAO,CAAC,EAAG,CAC3B,KAAM,CAAE,OAAA8B,EAAQ,UAAApF,EAAY,KAAK,iBAAkB,QAAAC,EAAU,KAAK,eAAgB,QAAA2C,EAAU,GAAO,aAAAnE,CAAc,EAAI6E,EACrH,GAAItD,GAAa,MAAaC,GAAW,KACrC,OAEJ,IAAIoF,EACJ,GAAID,EAAQ,CACRC,EAAmB,IAAI,IACvB,UAAWC,KAAW,KAAK,aAAa,OAAO,EACvCF,EAAO,SAASE,EAAQ,KAAK,GAC7BD,EAAiB,IAAIC,EAAQ,EAAE,CAG3C,CACA,MAAMC,EAAe,IAAI3L,EAAK,CAACG,EAAGC,IAAMD,EAAE,QAAQC,CAAC,CAAC,EACpD,UAAWwL,KAAc,KAAK,aACtBA,EAAW,kBAAoBvF,GAAWuF,EAAW,gBAAkBxF,GACvEuF,EAAa,KAAK,IAAInD,EAAY,CAAE,WAAAoD,EAAY,iBAAAH,EAAkB,UAAArF,EAAW,QAAAC,EAAS,QAAA2C,CAAQ,CAAC,CAAC,EAMxG,MAAM6C,EAAiB,IAAI,IAC3B,QAASjD,EAASA,EAAS+C,EAAa,KAAK,GAAK,CAC9C,GAAI,CAAC/C,EAAO,kBAAkB,EAAG,CAE7B,MAAMA,EAAO,mBAAmB,KAAK,QAAQ,EACzCA,EAAO,gBAAgB,EACvB+C,EAAa,QAAQ/C,CAAM,EAG3B+C,EAAa,IAAI,EAErB,QACJ,CACA,IAAIG,EAAYD,EAAe,IAAIjD,EAAO,WAAW,gBAAgB,EAChEkD,IACDA,EAAY,MAAM,KAAK,cAAclD,EAAO,UAAU,EACtDiD,EAAe,IAAIjD,EAAO,WAAW,iBAAkBkD,CAAS,GAEpE,KAAM,CAAC5F,EAAS/H,CAAM,EAAIyK,EAAO,WAAW,EAC5C,GAAIzK,GAAU,OAAO2N,EAAU,UAAU,EACrC,MAAM,KAAK,iBAAiB,gDAAgD5F,aAAmB/H,wBAA6B2N,EAAU,kCAAkClD,EAAO,WAAW,kBAAkB,EAEhN,MAAM/G,EAAS+C,EAAY,CACvB,KAAMkH,EACN,YAAa,OAAO3N,CAAM,EAC1B,aAAc0G,GAAgB,EAClC,CAAC,EACD,GAAI,CAAChD,EAAO,OACR,MAAM,KAAK,iBAAiB,oCAAoC1D,wBAA6ByK,EAAO,WAAW,kBAAkB,EAErI,GAAI/G,EAAO,OAAO,OAAS,UACvB,MAAM,KAAK,iBAAiB,0BAA0BA,EAAO,OAAO,+BAA+BqE,aAAmB/H,wBAA6ByK,EAAO,WAAW,mBAAmB,EAE5L,GAAI/G,EAAO,OAAO,UAAYqE,EAC1B,MAAM,KAAK,iBAAiB,oBAAoBrE,EAAO,OAAO,8CAA8CqE,eAAqB/H,wBAA6ByK,EAAO,WAAW,mBAAmB,EAEvM,MAAM/G,EAAO,OACT+G,EAAO,gBAAgB,EACvB+C,EAAa,QAAQ/C,CAAM,GAG3B+C,EAAa,IAAI,EACjBE,EAAe,OAAOjD,EAAO,WAAW,gBAAgB,EAEhE,CACJ,CACA,MAAO,aAAac,EAAO,CAAC,EAAG,CAC3B,KAAM,CAAE,KAAAjE,CAAK,EAAIiE,EACjB,UAAWqC,KAAiB,KAAK,gBAAiB,CAC9C,GAAItG,GAAQ,MAAasG,EAAc,OAAStG,EAC5C,SAEJ,MAAMuG,EAAe,MAAM,KAAK,SAAS,KAAKD,EAAc,OAAQA,EAAc,MAAM,EAClFE,EAAiBrH,EAAY,CAC/B,KAAM,IAAI,SAASoH,EAAa,OAAQA,EAAa,WAAYA,EAAa,UAAU,EACxF,YAAa,EACb,aAAc,EAClB,CAAC,EACD,GAAIC,EAAe,QAAQ,OAAS,WAChC,MAAM,KAAK,iBAAiB,2BAA2BF,EAAc,mDAAmD,OAAOE,EAAe,QAAQ,IAAI,IAAI,EAElK,MAAMA,EAAe,MACzB,CACJ,CACA,MAAO,gBAAgBvC,EAAO,CAAC,EAAG,CAC9B,KAAM,CAAE,KAAAjE,EAAM,UAAA0B,EAAW,UAAAf,EAAY,KAAK,oBAAqB,QAAAC,EAAU,KAAK,kBAAmB,aAAAxB,CAAc,EAAI6E,EACnH,GAAI,EAAAtD,GAAa,MAAaC,GAAW,MAGzC,UAAW6F,KAAmB,KAAK,kBAAmB,CAOlD,GANIzG,GAAQ,MAAayG,EAAgB,OAASzG,GAG9C0B,GAAa,MAAa+E,EAAgB,YAAc/E,GAGxD+E,EAAgB,QAAU7F,GAAW6F,EAAgB,QAAU9F,EAC/D,SAEJ,MAAM+F,EAAiB,MAAM,KAAK,SAAS,KAAKD,EAAgB,OAAQA,EAAgB,MAAM,EACxFE,EAAmBxH,EAAY,CACjC,KAAM,IAAI,SAASuH,EAAe,OAAQA,EAAe,WAAYA,EAAe,UAAU,EAC9F,YAAa,EACb,aAActH,GAAgB,EAClC,CAAC,EACD,GAAIuH,EAAiB,QAAQ,OAAS,aAClC,MAAM,KAAK,iBAAiB,6BAA6BF,EAAgB,qDAAqD,OAAOE,EAAiB,QAAQ,IAAI,IAAI,EAE1K,MAAMA,EAAiB,MAC3B,CACJ,CACA,MAAM,cAAcR,EAAY,CAC5B,MAAMS,EAAY,MAAM,KAAK,SAAS,KAAKT,EAAW,iBAAkBA,EAAW,WAAW,EACxFU,EAAc1H,EAAY,CAC5B,KAAM,IAAI,SAASyH,EAAU,OAAQA,EAAU,WAAYA,EAAU,UAAU,EAC/E,YAAa,EACb,aAAc,EAClB,CAAC,EACD,GAAIC,EAAY,QAAQ,OAAS,QAC7B,MAAM,KAAK,iBAAiB,sBAAsBV,EAAW,0DAA0D,OAAOU,EAAY,QAAQ,IAAI,IAAI,EAE9J,MAAM3C,EAAQ2C,EAAY,OAC1B,IAAIC,EAAS5C,EAAM,QACnB,GAAIA,EAAM,cAAgB,IAAM4C,EAAO,WAAa,EAAG,CACnD,MAAMC,EAAa,KAAK,qBAAqB7C,EAAM,WAAW,EAC9D,GAAI,CAAC6C,EACD,MAAM,KAAK,iBAAiB,2BAA2B7C,EAAM,aAAa,EAE9E4C,EAASC,EAAWD,EAAQ5C,EAAM,gBAAgB,CACtD,CACA,GAAIA,EAAM,kBAAoB,EAAG,CAC7B,MAAM8C,EAAW,EAAMF,CAAM,EAC7B,GAAIE,IAAa9C,EAAM,gBACnB,MAAM,KAAK,iBAAiB,uBAAuB8C,eAAsB9C,EAAM,kBAAkB,CAEzG,CACA,OAAO,IAAI,SAAS4C,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,CAC3E,CACJ,CC7Ue,MAAMG,CAAa,CAC9B,YAAYC,EAAkB,EAAG,CAC7B,KAAK,OAAS,IAAI,YAAYA,CAAe,EAC7C,KAAK,KAAO,IAAI,SAAS,KAAK,OAAQ,EAAG,CAAC,CAC9C,CACA,gBAAiB,CACb,OAAO,KAAK,KAAK,UACrB,CAEA,QAAQC,EAAO,CACX,KAAK,KAAO,IAAI,SAAS,KAAK,OAAQ,KAAK,KAAK,WAAaA,EAAO,KAAK,KAAK,WAAaA,CAAK,CACpG,CAEA,OAAO5O,EAAM,CACT,GAAI,KAAK,KAAK,WAAa,KAAK,KAAK,WAAaA,EAAK,YAAc,KAAK,OAAO,WAE/D,IAAI,WAAW,KAAK,KAAK,OAAQ,KAAK,KAAK,UAAU,EAC7D,IAAIA,EAAM,KAAK,KAAK,UAAU,EACpC,KAAK,KAAO,IAAI,SAAS,KAAK,OAAQ,KAAK,KAAK,WAAY,KAAK,KAAK,WAAaA,EAAK,UAAU,UAE7F,KAAK,KAAK,WAAaA,EAAK,YAAc,KAAK,OAAO,WAAY,CAEvE,MAAM6O,EAAU,IAAI,WAAW,KAAK,OAAQ,KAAK,KAAK,WAAY,KAAK,KAAK,UAAU,EAChF3K,EAAQ,IAAI,WAAW,KAAK,MAAM,EACxCA,EAAM,IAAI2K,EAAS,CAAC,EACpB3K,EAAM,IAAIlE,EAAM6O,EAAQ,UAAU,EAClC,KAAK,KAAO,IAAI,SAAS,KAAK,OAAQ,EAAG,KAAK,KAAK,WAAa7O,EAAK,UAAU,CACnF,KACK,CAID,MAAM6O,EAAU,IAAI,WAAW,KAAK,OAAQ,KAAK,KAAK,WAAY,KAAK,KAAK,UAAU,EACtF,KAAK,OAAS,IAAI,aAAa,KAAK,KAAK,WAAa7O,EAAK,YAAc,CAAC,EAC1E,MAAMkE,EAAQ,IAAI,WAAW,KAAK,MAAM,EACxCA,EAAM,IAAI2K,EAAS,CAAC,EACpB3K,EAAM,IAAIlE,EAAM6O,EAAQ,UAAU,EAClC,KAAK,KAAO,IAAI,SAAS,KAAK,OAAQ,EAAG,KAAK,KAAK,WAAa7O,EAAK,UAAU,CACnF,CACJ,CACJ,CCrBe,MAAM8O,CAAiB,CAClC,YAAY,CAAE,cAAAC,EAAgB,GAAO,mBAAAjD,EAAqB,CAAC,EAAG,aAAAjF,EAAe,GAAM,cAAAmI,EAAgB,EAAO,EAAI,CAAC,EAAG,CAC9G,KAAK,OAAS,IAAIN,EAAa,SAAoB,CAAC,EACpD,KAAK,YAAc,GACnB,KAAK,UAAY,KAAK,KAAK,EAC3B,KAAK,aAAe,IAAI,IACxB,KAAK,cAAgBK,EACrB,KAAK,mBAAqBjD,EAC1B,KAAK,aAAejF,EACpB,KAAK,cAAgBmI,CACzB,CAEA,MAAO,CACH,OAAO,KAAK,WAChB,CAEA,gBAAiB,CACb,OAAO,KAAK,OAAO,eAAe,CACtC,CAKA,OAAOhP,EAAM,CACT,GAAI,KAAK,YACL,MAAM,IAAI,MAAM,sBAAsB,EAE1C,KAAK,OAAO,OAAOA,CAAI,CAC3B,CAQA,YAAa,CACT,GAAI,KAAK,YACL,OAEJ,MAAM6D,EAAS,KAAK,UAAU,KAAK,EACnC,GAAIA,EAAO,OAAO,OAAS,UAAW,CAClC,MAAMoL,EAAW,KAAK,aAAa,IAAIpL,EAAO,MAAM,EAAE,EAEtD,GADA,KAAK,aAAa,IAAIA,EAAO,MAAM,GAAIA,EAAO,KAAK,EAC/CoL,GAAY,CAACC,EAAeD,EAAUpL,EAAO,KAAK,EAClD,MAAM,IAAI,MAAM,yBAAyBA,EAAO,MAAM,cAAcA,EAAO,MAAM,6DAA6D,CAEtJ,SACSA,EAAO,OAAO,OAAS,UAAW,CACvC,MAAM+D,EAAY/D,EAAO,MAAM,UAE/B,GAAI,CADa,KAAK,aAAa,IAAI+D,CAAS,EAE5C,MAAM,IAAI,MAAM,kCAAkCA,gCAAwC,CAElG,CACA,OAAI/D,EAAO,OAAS,KAChB,KAAK,YAAc,IAEhBA,EAAO,KAClB,CACA,CAAC,MAAO,CACJ,GAAI,CAAC,KAAK,cAAe,CACrB,IAAIsL,EAAOC,EACX,KAAS,CAAE,MAAAD,EAAO,UAAAC,CAAU,EAAI3I,EAAW,KAAK,OAAO,KAAM,CAAC,EAAI,CAAC0I,GAC/D,MAEJ,KAAK,OAAO,QAAQC,CAAS,CACjC,CACA,IAAIpD,EACJ,SAASM,EAAiBT,EAAS,CAC/B,OAAO,IAAI,MAAM,GAAGA,KAAWG,EAAS,YAAYA,EAAO,WAAa,eAAe,CAC3F,CACA,OAAS,CACL,IAAInB,EACJ,CACI,IAAIuE,EACJ,KAAS,CAAE,OAAAvE,EAAQ,UAAAuE,CAAU,EAAIxI,EAAY,CACzC,KAAM,KAAK,OAAO,KAClB,YAAa,EACb,aAAc,KAAK,YACvB,CAAC,EACG,CAACiE,GACD,MAEJ,KAAK,OAAO,QAAQuE,CAAS,CACjC,CACA,OAAQvE,EAAO,KAAM,CACjB,IAAK,UACD,MACJ,IAAK,SACD,GAAImB,EACA,MAAM,IAAI,MAAM,oCAAoCA,EAAO,mBAAmBA,EAAO,uBAAuBnB,EAAO,mBAAmBA,EAAO,SAAS,EAE1JmB,EAASnB,EACT,MAAMA,EACN,MACJ,IAAK,SACL,IAAK,UACL,IAAK,UACL,IAAK,eACL,IAAK,aACL,IAAK,aACL,IAAK,kBACL,IAAK,aACL,IAAK,WACL,IAAK,gBACL,IAAK,gBACL,IAAK,UACD,MAAMA,EACN,MACJ,IAAK,QAAS,CACN,KAAK,gBACL,MAAMA,GAEV,IAAI0D,EAAS1D,EAAO,QACpB,GAAIA,EAAO,cAAgB,IAAM0D,EAAO,WAAa,EAAG,CACpD,MAAMC,EAAa,KAAK,mBAAmB3D,EAAO,WAAW,EAC7D,GAAI,CAAC2D,EACD,MAAMlC,EAAiB,2BAA2BzB,EAAO,aAAa,EAE1E0D,EAASC,EAAWD,EAAQ1D,EAAO,gBAAgB,CACvD,CACA,GAAI,KAAK,cAAgBA,EAAO,kBAAoB,EAAG,CACnD,MAAM4D,EAAW,EAAMF,CAAM,EAC7B,GAAIE,IAAa5D,EAAO,gBACpB,MAAMyB,EAAiB,uBAAuBmC,eAAsB5D,EAAO,kBAAkB,CAErG,CACA,MAAM3K,EAAO,IAAI,SAASqO,EAAO,OAAQA,EAAO,WAAYA,EAAO,UAAU,EAC7E,IAAIc,EAAc,EAClB,QAASf,EAAcA,EAAc1H,EAAY,CAC7C,KAAA1G,EACA,YAAamP,EACb,aAAc,KAAK,YACvB,CAAC,EACGf,EAAY,OAAQe,GAAef,EAAY,UAC/C,OAAQA,EAAY,OAAO,KAAM,CAC7B,IAAK,UACD,MACJ,IAAK,SACL,IAAK,SACL,IAAK,QACL,IAAK,eACL,IAAK,aACL,IAAK,aACL,IAAK,kBACL,IAAK,aACL,IAAK,WACL,IAAK,gBACL,IAAK,gBACL,IAAK,UACD,MAAMhC,EAAiB,GAAGgC,EAAY,OAAO,wCAAwC,EACzF,IAAK,SACL,IAAK,UACL,IAAK,UACD,MAAMA,EAAY,OAClB,KACR,CAEJ,GAAIe,IAAgBd,EAAO,WACvB,MAAMjC,EAAiB,GAAGiC,EAAO,WAAac,4BAAsC,EAExF,KACJ,CACA,IAAK,SACD,GAAI,CACA,IAAIF,EAAOC,EACX,KAAS,CAAE,MAAAD,EAAO,UAAAC,CAAU,EAAI3I,EAAW,KAAK,OAAO,KAAM,CAAC,EAAI,CAAC0I,GAC/D,MAEJ,KAAK,OAAO,QAAQC,CAAS,CACjC,OACO3N,EAAP,CACI,MAAM6K,EAAiB7K,EAAM,OAAO,CACxC,CACA,GAAI,KAAK,OAAO,eAAe,IAAM,EACjC,MAAM6K,EAAiB,GAAG,KAAK,OAAO,eAAe,wDAAwD,EAEjH,OAAOzB,CACf,CACJ,CACJ,CACJ,CACA,SAASqE,EAAe/M,EAAGC,EAAG,CAC1B,GAAI,EAAED,EAAE,KAAOC,EAAE,IACbD,EAAE,kBAAoBC,EAAE,iBACxBD,EAAE,WAAaC,EAAE,UACjBD,EAAE,QAAUC,EAAE,OACdD,EAAE,SAAS,OAASC,EAAE,SAAS,MAC/B,MAAO,GAEX,SAAW,CAACkN,EAAMC,CAAM,IAAKpN,EAAE,SAAS,QAAQ,EAAG,CAC/C,MAAMqN,EAASpN,EAAE,SAAS,IAAIkN,CAAI,EAClC,GAAIC,IAAWC,EACX,MAAO,EAEf,CACA,MAAO,EACX,CChNO,MAAM,CAAkB,CAC3B,YAAYC,EAAS,CACjB,KAAK,QAAUA,EACf,KAAK,cAAgB,IAAI,aAC7B,CACA,IAAI,QAAS,CACT,OAAO,KAAK,cAAc,MAC9B,CACA,IAAI,QAAS,CACT,OAAO,KAAK,cAAc,MAC9B,CACA,OAAQ,CACJ,KAAK,cAAc,MAAM,CAC7B,CACA,YAAa,CACT,KAAK,cAAc,MAAM,IAAI,WAAW,UAAU,CAAC,CACvD,CACA,YAAYzD,EAAQ,CAChB,KAAK,cAAc,MAAM,OAAO,MAAM,EACtC,MAAM0D,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAO1D,EAAO,OAAO,EACrB,OAAOA,EAAO,OAAO,EACtB,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAM2D,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,YAAY9C,EAAQ,CAChB,YAAK,cACA,MAAM,OAAO,MAAM,EACnB,OAAO,GAAG,EACV,OAAOA,EAAO,YAAY,EAC1B,OAAOA,EAAO,kBAAkB,EAChC,OAAOA,EAAO,UAAU,EAEtB,GACX,CACA,YAAYgD,EAAQ,CAChB,KAAK,cAAc,MAAM,OAAO,MAAM,EACtC,MAAMF,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAOE,EAAO,EAAE,EAChB,OAAOA,EAAO,IAAI,EAClB,OAAOA,EAAO,QAAQ,EACtB,OAAOA,EAAO,KAAK,UAAU,EAC7B,MAAMA,EAAO,IAAI,EAClB,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAMD,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,aAAaG,EAAM,CACf,KAAK,cAAc,MAAM,OAAO,OAAO,EACvC,MAAMH,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAOG,EAAK,EAAE,EACd,OAAOA,EAAK,QAAQ,EACpB,OAAOA,EAAK,KAAK,EACjB,OAAOA,EAAK,eAAe,EAC3B,WAAYzJ,GAAQ,KAAK,cAAc,OAAOA,CAAG,EAAIvG,GAAU,KAAK,cAAc,OAAOA,CAAK,EAAGgQ,EAAK,QAAQ,EAC/G,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAMF,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,aAAa7D,EAAS,CAClB,KAAK,cAAc,MAAM,OAAO,OAAO,EACvC,MAAM6D,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAO7D,EAAQ,SAAS,EACxB,OAAOA,EAAQ,QAAQ,EACvB,OAAOA,EAAQ,OAAO,EACtB,OAAOA,EAAQ,WAAW,EAC1B,MAAMA,EAAQ,IAAI,EAEvB,MAAM8D,EAAc,KAAK,cAAc,OACvC,KAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,CACzB,CACA,gBAAgB/D,EAAY,CACxB,KAAK,cAAc,MAAM,OAAO,UAAU,EAC1C,MAAM8D,EAAgB,KAAK,cAAc,OACzC,KAAK,cAAc,OAAO,EAAE,EAC5B,MAAMI,EAAmB,KAAK,cAAc,OAC5C,KAAK,cACA,OAAOlE,EAAW,OAAO,EACzB,OAAOA,EAAW,UAAU,EAC5B,OAAOA,EAAW,IAAI,EACtB,OAAOA,EAAW,SAAS,EAC3B,OAAO,OAAOA,EAAW,KAAK,UAAU,CAAC,EACzC,MAAMA,EAAW,IAAI,EAC1B,KAAK,cAAc,OAAO,MAAM,KAAK,cAAc,WAAWkE,EAAkB,KAAK,cAAc,OAASA,CAAgB,CAAC,CAAC,EAC1H,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAMH,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,qBAAqBxB,EAAiB,CAClC,KAAK,cAAc,MAAM,OAAO,gBAAgB,EAChD,MAAMwB,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAOxB,EAAgB,MAAM,EAC7B,OAAOA,EAAgB,MAAM,EAC7B,OAAOA,EAAgB,OAAO,EAC9B,OAAOA,EAAgB,UAAU,EACjC,OAAOA,EAAgB,QAAQ,EAC/B,OAAOA,EAAgB,IAAI,EAC3B,OAAOA,EAAgB,SAAS,EACjC,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAMyB,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,WAAW/D,EAAO,CACd,KAAK,cAAc,MAAM,OAAO,KAAK,EACrC,MAAM+D,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAO/D,EAAM,gBAAgB,EAC7B,OAAOA,EAAM,cAAc,EAC3B,OAAOA,EAAM,gBAAgB,EAC7B,OAAOA,EAAM,eAAe,EAC5B,OAAOA,EAAM,WAAW,EACxB,OAAO,OAAOA,EAAM,QAAQ,UAAU,CAAC,EACvC,MAAMA,EAAM,OAAO,EAExB,MAAMgE,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,gBAAgB9B,EAAY,CACxB,KAAK,cAAc,MAAM,OAAO,WAAW,EAC3C,MAAM8B,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAO9B,EAAW,gBAAgB,EAClC,OAAOA,EAAW,cAAc,EAChC,OAAOA,EAAW,gBAAgB,EAClC,OAAOA,EAAW,WAAW,EAC7B,OAAOA,EAAW,oBAAoB,KAAO,EAAE,EACpD,SAAW,CAAChG,EAAWzH,CAAM,IAAKyN,EAAW,oBACzC,KAAK,cAAc,OAAOhG,CAAS,EAAE,OAAOzH,CAAM,EAEtD,KAAK,cACA,OAAOyN,EAAW,kBAAkB,EACpC,OAAOA,EAAW,WAAW,EAC7B,OAAOA,EAAW,cAAc,EAChC,OAAOA,EAAW,gBAAgB,EACnC,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAM+B,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,kBAAkBK,EAAc,CAC5B,KAAK,cAAc,MAAM,OAAO,aAAa,EAC7C,MAAML,EAAgB,KAAK,cAAc,OAEnCM,EAAgCD,EAAa,QAAQ,OAAS,GACpE,KAAK,cACA,OAAO,EAAE,EACT,OAAOA,EAAa,SAAS,EAC7B,OAAOC,CAA6B,EACzC,UAAWnF,KAAUkF,EAAa,QAC9B,KAAK,cAAc,OAAOlF,EAAO,CAAC,CAAC,EAAE,OAAOA,EAAO,CAAC,CAAC,EAErD,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAM8E,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,cAAc1H,EAAU,CACpB,KAAK,cAAc,MAAM,OAAO,QAAQ,EACxC,MAAM0H,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAO1H,EAAS,IAAI,EACpB,WAAY5B,GAAQ,KAAK,cAAc,OAAOA,CAAG,EAAIvG,GAAU,KAAK,cAAc,OAAOA,CAAK,EAAGmI,EAAS,QAAQ,EACnH,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAM2H,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,mBAAmB3B,EAAe,CAC9B,KAAK,cAAc,MAAM,OAAO,cAAc,EAC9C,MAAM2B,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAO3B,EAAc,MAAM,EAC3B,OAAOA,EAAc,MAAM,EAC3B,OAAOA,EAAc,IAAI,EAC1B,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAM4B,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,mBAAmBO,EAAe,CAC9B,KAAK,cAAc,MAAM,OAAO,cAAc,EAC9C,MAAMP,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,MAAMO,EAAc,WAAW,EAC/B,OAAOA,EAAc,UAAU,EAC/B,OAAOA,EAAc,WAAW,EACjC,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAMN,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,gBAAgBnC,EAAY,CACxB,KAAK,cAAc,MAAM,OAAO,UAAU,EAC1C,MAAMmC,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAOnC,EAAW,YAAY,EAC9B,OAAOA,EAAW,WAAW,EAC7B,OAAOA,EAAW,YAAY,EAC9B,OAAOA,EAAW,eAAe,EACjC,OAAOA,EAAW,aAAa,EAC/B,OAAOA,EAAW,UAAU,EAC5B,OAAOA,EAAW,gBAAgB,EAClC,OAAOA,EAAW,cAAc,EAChC,WAAYnH,GAAQ,KAAK,cAAc,OAAOA,CAAG,EAAIvG,GAAU,KAAK,cAAc,OAAOA,CAAK,EAAG0N,EAAW,oBAAoB,EACjI,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAMoC,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACA,aAAaQ,EAAS,CAClB,KAAK,cAAc,MAAM,OAAO,QAAQ,EACxC,MAAMR,EAAgB,KAAK,cAAc,OACzC,KAAK,cACA,OAAO,EAAE,EACT,OAAOQ,EAAQ,cAAc,EAC9B,KAAK,SAAS,aAAe,IAC7B,KAAK,cAAc,MAAM,CAAI,EAAE,MAAM,GAAI,EAAE,MAAM,GAAI,EAEzD,MAAMP,EAAc,KAAK,cAAc,OACvC,YAAK,cACA,KAAKD,CAAa,EAClB,OAAO,OAAOC,EAAcD,EAAgB,CAAC,CAAC,EAC9C,KAAKC,CAAW,EACd,OAAOA,EAAcD,EAAgB,CAAC,CACjD,CACJ,CChUA,MAAM,CAAa,CACf,YAAY,CAAE,gBAAAS,EAAkB,EAAK,EAAG,CACpC,KAAK,aAAe,IAAI,kBACxB,KAAK,kBAAoB,EACzB,KAAK,iBAAmB,GACxB,KAAK,eAAiB,GAClBA,IACA,KAAK,eAAiB,IAAI,IAElC,CACA,IAAI,aAAc,CACd,OAAO,KAAK,iBAChB,CACA,IAAI,QAAS,CACT,OAAO,KAAK,aAAa,MAC7B,CACA,IAAI,YAAa,CACb,OAAO,KAAK,aAAa,MAC7B,CACA,IAAI,SAAU,CACV,OAAI,KAAK,eACE,KAAK,eAAe,OAAO,EAE/B,CAAC,CACZ,CACA,UAAUP,EAAQ,CACd,KAAK,aAAa,YAAYA,CAAM,CACxC,CACA,WAAWC,EAAM,CACT,KAAK,gBAAkB,CAAC,KAAK,eAAe,IAAIA,EAAK,EAAE,GACvD,KAAK,eAAe,IAAIA,EAAK,GAAI,CAC7B,UAAWA,EAAK,GAChB,QAAS,CAAC,CACd,CAAC,EAEL,KAAK,aAAa,aAAaA,CAAI,CACvC,CACA,WAAWhE,EAAS,CAOhB,IANI,KAAK,oBAAsB,GAAKA,EAAQ,QAAU,KAAK,oBACvD,KAAK,iBAAmBA,EAAQ,UAEhC,KAAK,oBAAsB,GAAKA,EAAQ,QAAU,KAAK,kBACvD,KAAK,eAAiBA,EAAQ,SAE9B,KAAK,eAAgB,CACrB,IAAIkE,EAAe,KAAK,eAAe,IAAIlE,EAAQ,SAAS,EACvDkE,IACDA,EAAe,CACX,UAAWlE,EAAQ,UACnB,QAAS,CAAC,CACd,EACA,KAAK,eAAe,IAAIA,EAAQ,UAAWkE,CAAY,GAE3DA,EAAa,QAAQ,KAAK,CAAClE,EAAQ,QAAS,OAAO,KAAK,aAAa,MAAM,CAAC,CAAC,CACjF,CACA,KAAK,mBAAqB,EAC1B,KAAK,aAAa,aAAaA,CAAO,CAC1C,CACA,OAAQ,CACJ,KAAK,iBAAmB,GACxB,KAAK,eAAiB,GACtB,KAAK,kBAAoB,EACzB,KAAK,gBAAgB,MAAM,EAC3B,KAAK,aAAa,MAAM,CAC5B,CACJ,CCvDO,MAAMuE,EAAW,CACpB,YAAYX,EAAS,CACjB,KAAK,cAAgB,EACrB,KAAK,aAAe,EACpB,KAAK,aAAe,IAAI,kBACxB,KAAK,QAAU,IAAI,IACnB,KAAK,SAAW,IAAI,IACpB,KAAK,iBAAmB,IAAI,IAC5B,KAAK,kBAAoB,IAAI,IAC7B,KAAK,eAAiB,UAAU,EAChC,KAAM,CAAE,SAAAY,EAAU,cAAAC,EAAgB,GAAM,kBAAAC,EAAoB,GAAM,UAAAC,EAAY,GAAM,cAAAC,EAAgB,GAAM,eAAAC,EAAiB,GAAM,mBAAAC,EAAqB,GAAM,iBAAAC,EAAmB,GAAM,gBAAAT,EAAkB,GAAM,cAAAU,EAAgB,GAAM,eAAAC,EAAiB,EAAG,UAAAC,EAAY,KAAO,KAAM,cAAAC,CAAe,EAAIvB,EACnS,KAAK,SAAWY,EAChB,KAAK,kBAAoBE,EACrBD,IACA,KAAK,WAAa,CACd,aAAc,GACd,YAAa,EACb,aAAc,EACd,gBAAiB,EACjB,cAAe,EACf,WAAY,EACZ,iBAAkB,GAClB,eAAgB,GAChB,qBAAsB,IAAI,GAC9B,GAEAE,IACA,KAAK,aAAe,IAAI,aAAa,CAAE,gBAAAL,CAAgB,CAAC,GAE5D,KAAK,cAAgBM,EACrB,KAAK,eAAiBC,EAClBC,IACA,KAAK,kBAAoB,CAAC,GAE1BC,IACA,KAAK,gBAAkB,CAAC,GAExBC,IACA,KAAK,aAAe,CAAC,GAEzB,KAAK,cAAgBC,EACrB,KAAK,UAAYC,EACjB,KAAK,cAAgBC,CACzB,CACA,MAAM,MAAMhF,EAAQ,CAChB,KAAK,aAAa,WAAW,EAC7B,KAAK,aAAa,YAAYA,CAAM,EACpC,KAAK,eAAiB,YAAY,KAAK,eAAgB,KAAK,aAAa,MAAM,EAC/E,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,CAC5B,CACA,MAAM,KAAM,CACR,MAAM,KAAK,cAAc,EACzB,KAAK,eAAiB,YAAY,KAAK,eAAgB,KAAK,aAAa,MAAM,EAC/E,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACxB,KAAK,aAAa,aAAa,CAAE,eAAgB,WAAW,KAAK,cAAc,CAAE,CAAC,EAClF,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACxB,MAAMiF,EAAiB,CAAC,EAClB5J,EAAe,KAAK,SAAS,SAAS,EAC5C,IAAIE,EAAa,UAAU,EAC3B,GAAI,KAAK,cAAe,CACpB,MAAM2J,EAAc,KAAK,SAAS,SAAS,EAC3C,IAAIC,EAAe,GACnB,UAAWvB,KAAU,KAAK,QAAQ,OAAO,EACrCuB,GAAgB,KAAK,aAAa,YAAYvB,CAAM,EAExDqB,EAAe,KAAK,CAChB,YAAa,OAAO,OACpB,WAAYC,EACZ,YAAaC,CACjB,CAAC,CACL,CACA,GAAI,KAAK,eAAgB,CACrB5J,EAAa,YAAYA,EAAY,KAAK,aAAa,MAAM,EAC7D,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACxB,MAAM6J,EAAe,KAAK,SAAS,SAAS,EAC5C,IAAIC,EAAgB,GACpB,UAAW3D,KAAW,KAAK,SAAS,OAAO,EACvC2D,GAAiB,KAAK,aAAa,aAAa3D,CAAO,EAE3DuD,EAAe,KAAK,CAChB,YAAa,OAAO,QACpB,WAAYG,EACZ,YAAaC,CACjB,CAAC,CACL,CACA,GAAI,KAAK,WAAY,CACjB9J,EAAa,YAAYA,EAAY,KAAK,aAAa,MAAM,EAC7D,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACxB,MAAM+J,EAAkB,KAAK,SAAS,SAAS,EACzCC,EAAmB,KAAK,aAAa,gBAAgB,KAAK,UAAU,EAC1EN,EAAe,KAAK,CAChB,YAAa,OAAO,WACpB,WAAYK,EACZ,YAAaC,CACjB,CAAC,CACL,CAIA,GAHAhK,EAAa,YAAYA,EAAY,KAAK,aAAa,MAAM,EAC7D,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACpB,KAAK,gBAAiB,CACtBA,EAAa,YAAYA,EAAY,KAAK,aAAa,MAAM,EAC7D,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACxB,MAAMiK,EAAqB,KAAK,SAAS,SAAS,EAClD,IAAIC,EAAsB,GAC1B,UAAW1D,KAAiB,KAAK,gBAC7B0D,GAAuB,KAAK,aAAa,mBAAmB1D,CAAa,EAE7EkD,EAAe,KAAK,CAChB,YAAa,OAAO,eACpB,WAAYO,EACZ,YAAaC,CACjB,CAAC,CACL,CACA,GAAI,KAAK,kBAAmB,CACxBlK,EAAa,YAAYA,EAAY,KAAK,aAAa,MAAM,EAC7D,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACxB,MAAMmK,EAAuB,KAAK,SAAS,SAAS,EACpD,IAAIC,EAAwB,GAC5B,UAAWzD,KAAmB,KAAK,kBAC/ByD,GAAyB,KAAK,aAAa,qBAAqBzD,CAAe,EAEnF+C,EAAe,KAAK,CAChB,YAAa,OAAO,iBACpB,WAAYS,EACZ,YAAaC,CACjB,CAAC,CACL,CACA,GAAI,KAAK,aAAc,CACnBpK,EAAa,YAAYA,EAAY,KAAK,aAAa,MAAM,EAC7D,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACxB,MAAMqK,EAAkB,KAAK,SAAS,SAAS,EAC/C,IAAIC,EAAmB,GACvB,UAAWjE,KAAc,KAAK,aAC1BiE,GAAoB,KAAK,aAAa,gBAAgBjE,CAAU,EAEpEqD,EAAe,KAAK,CAChB,YAAa,OAAO,YACpB,WAAYW,EACZ,YAAaC,CACjB,CAAC,CACL,CACAtK,EAAa,YAAYA,EAAY,KAAK,aAAa,MAAM,EAC7D,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACxB,MAAMD,EAAqB,KAAK,SAAS,SAAS,EAC5CwK,EAAgBxK,EAAqBD,EAC3C,GAAI,KAAK,kBACL,UAAW4I,KAAiBgB,EACpBhB,EAAc,cAAgB,IAC9B,KAAK,aAAa,mBAAmBA,CAAa,EAI9D1I,EAAa,YAAYA,EAAY,KAAK,aAAa,MAAM,EAC7D,MAAMqF,EAAS,CACX,aAAckF,IAAkB,GAAK,GAAKzK,EAC1C,mBAAoB,KAAK,kBAAoBC,EAAqB,GAClE,WAAY,CAChB,EACMyK,EAAa,IAAI,SAAS,IAAI,YAAY,EAAI,EAAI,EAAI,CAAC,CAAC,EAC9DA,EAAW,SAAS,EAAG,OAAO,MAAM,EACpCA,EAAW,aAAa,EAAG,GAAK,GAAK,GAAI,EAAI,EAC7CA,EAAW,aAAa,EAAI,EAAGnF,EAAO,aAAc,EAAI,EACxDmF,EAAW,aAAa,EAAI,EAAI,EAAGnF,EAAO,mBAAoB,EAAI,EAClErF,EAAa,YAAYA,EAAYwK,CAAU,EAC/CnF,EAAO,WAAa,WAAWrF,CAAU,EACzC,KAAK,aAAa,YAAYqF,CAAM,EACpC,KAAK,aAAa,WAAW,EAC7B,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,CAC5B,CAIA,MAAM,eAAeiD,EAAM,CACvB,MAAMrI,EAAK,KAAK,eAChB,YAAK,QAAQ,IAAIA,EAAI,CAAE,GAAGqI,EAAM,GAAArI,CAAG,CAAC,EAChC,KAAK,YACL,EAAE,KAAK,WAAW,YAEfA,CACX,CAIA,MAAM,gBAAgBqI,EAAM,CACxB,MAAMrI,EAAK,KAAK,gBAChB,YAAK,SAAS,IAAIA,EAAI,CAAE,GAAGqI,EAAM,GAAArI,CAAG,CAAC,EACjC,KAAK,YACL,EAAE,KAAK,WAAW,aAEfA,CACX,CACA,MAAM,WAAWqE,EAAS,CAkBtB,GAjBI,KAAK,aACD,KAAK,WAAW,eAAiB,IACjC,KAAK,WAAW,iBAAmBA,EAAQ,QAC3C,KAAK,WAAW,eAAiBA,EAAQ,UAGrCA,EAAQ,QAAU,KAAK,WAAW,mBAClC,KAAK,WAAW,iBAAmBA,EAAQ,SAE3CA,EAAQ,QAAU,KAAK,WAAW,iBAClC,KAAK,WAAW,eAAiBA,EAAQ,UAGjD,KAAK,WAAW,qBAAqB,IAAIA,EAAQ,WAAY,KAAK,WAAW,qBAAqB,IAAIA,EAAQ,SAAS,GAAK,IAAM,EAAE,EACpI,EAAE,KAAK,WAAW,cAGlB,CAAC,KAAK,kBAAkB,IAAIA,EAAQ,SAAS,EAAG,CAChD,MAAM6B,EAAU,KAAK,SAAS,IAAI7B,EAAQ,SAAS,EACnD,GAAI,CAAC6B,EACD,MAAM,IAAI,MAAM,wDAAwD7B,EAAQ,WAAW,EAE/F,GAAI6B,EAAQ,WAAa,GAAK,CAAC,KAAK,iBAAiB,IAAIA,EAAQ,QAAQ,EAAG,CACxE,MAAMkC,EAAS,KAAK,QAAQ,IAAIlC,EAAQ,QAAQ,EAChD,GAAI,CAACkC,EACD,MAAM,IAAI,MAAM,uDAAuDlC,EAAQ,UAAU,EAEzF,KAAK,aACL,KAAK,aAAa,UAAUkC,CAAM,EAGlC,KAAK,aAAa,YAAYA,CAAM,EAExC,KAAK,iBAAiB,IAAIlC,EAAQ,QAAQ,CAC9C,CACI,KAAK,aACL,KAAK,aAAa,WAAWA,CAAO,EAGpC,KAAK,aAAa,aAAaA,CAAO,EAE1C,KAAK,kBAAkB,IAAI7B,EAAQ,SAAS,CAChD,CACI,KAAK,aACL,KAAK,aAAa,WAAWA,CAAO,EAGpC,KAAK,aAAa,aAAaA,CAAO,EAEtC,KAAK,cAAgB,KAAK,aAAa,WAAa,KAAK,WACzD,MAAM,KAAK,cAAc,CAEjC,CACA,MAAM,cAAcD,EAAY,CAC5B,MAAM7F,EAAS,KAAK,aAAa,gBAAgB6F,CAAU,EAI3D,GAHI,KAAK,YACL,EAAE,KAAK,WAAW,gBAElB,KAAK,kBAAmB,CACxB,MAAMzL,EAAS,KAAK,SAAS,SAAS,EACtC,KAAK,kBAAkB,KAAK,CACxB,QAASyL,EAAW,QACpB,WAAYA,EAAW,WACvB,KAAMA,EAAW,KACjB,UAAWA,EAAW,UACtB,OAAAzL,EACA,SAAU,OAAOyL,EAAW,KAAK,UAAU,EAC3C,OAAA7F,CACJ,CAAC,CACL,CACA,KAAK,eAAiB,YAAY,KAAK,eAAgB,KAAK,aAAa,MAAM,EAC/E,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,CAC5B,CACA,MAAM,YAAYiC,EAAU,CACxB,MAAMgK,EAAa,KAAK,aAAa,cAAchK,CAAQ,EAI3D,GAHI,KAAK,YACL,EAAE,KAAK,WAAW,cAElB,KAAK,gBAAiB,CACtB,MAAM7H,EAAS,KAAK,SAAS,SAAS,EACtC,KAAK,gBAAgB,KAAK,CACtB,KAAM6H,EAAS,KACf,OAAA7H,EACA,OAAQ6R,CACZ,CAAC,CACL,CACA,KAAK,eAAiB,YAAY,KAAK,eAAgB,KAAK,aAAa,MAAM,EAC/E,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,CAC5B,CACA,MAAM,eAAgB,CAClB,GAAI,CAAC,KAAK,cAAgB,KAAK,aAAa,cAAgB,EACxD,OAEA,KAAK,YACL,EAAE,KAAK,WAAW,WAEtB,MAAM3D,EAAY,KAAK,aAAa,OAC9B/F,EAAmB,OAAO+F,EAAU,MAAM,EAC1C9F,EAAkB,MAAM8F,CAAS,EACvC,IAAI7F,EAAc,GACdyJ,EAAiB5D,EACjB,KAAK,gBACJ,CAAE,YAAA7F,EAAa,eAAAyJ,CAAe,EAAI,KAAK,cAAc5D,CAAS,GAEnE,MAAM6D,EAAc,CAChB,iBAAkB,KAAK,aAAa,iBACpC,eAAgB,KAAK,aAAa,eAClC,iBAAA5J,EACA,gBAAAC,EACA,YAAAC,EACA,QAASyJ,CACb,EACMpJ,EAAmB,KAAK,SAAS,SAAS,EAC1CC,EAAc,KAAK,aAAa,WAAWoJ,CAAW,EACtDnJ,EAAsB,KAAK,aAAe,IAAI,IAAQ,OAC5D,KAAK,eAAiB,YAAY,KAAK,eAAgB,KAAK,aAAa,MAAM,EAC/E,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,EACxB,MAAMoJ,EAAoB,KAAK,SAAS,SAAS,EACjD,IAAInJ,EAAqB,GACzB,UAAW+G,KAAgB,KAAK,aAAa,QACzChH,GAAqB,IAAIgH,EAAa,UAAWoC,EAAoBnJ,CAAkB,EACvFA,GAAsB,KAAK,aAAa,kBAAkB+G,CAAY,EAEtE,KAAK,cACL,KAAK,aAAa,KAAK,CACnB,iBAAkBmC,EAAY,iBAC9B,eAAgBA,EAAY,eAC5B,iBAAArJ,EACA,YAAAC,EACA,oBAAqBC,EACrB,mBAAAC,EACA,YAAakJ,EAAY,YACzB,eAAgB,OAAOA,EAAY,QAAQ,UAAU,EACrD,iBAAkBA,EAAY,gBAClC,CAAC,EAEL,KAAK,aAAa,MAAM,EACxB,KAAK,eAAiB,YAAY,KAAK,eAAgB,KAAK,aAAa,MAAM,EAC/E,MAAM,KAAK,SAAS,MAAM,KAAK,aAAa,MAAM,EAClD,KAAK,aAAa,MAAM,CAC5B,CACJ,CCnWO,SAASE,GAAcC,EAAQ,CAClC,OAAQA,EAAO,YAAc,WAAW,QACpC,WAAW,MAAM,CAAC1L,EAAKhH,IAAMgH,IAAQ0L,EAAO,SAAS1S,CAAC,CAAC,CAC/D,C","sources":["webpack:///../../node_modules/@foxglove/crc/dist/esm/src/index.js","webpack:///../../node_modules/heap-js/dist/heap-js.es5.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/getBigUint64.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/Reader.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/constants.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/parse.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/sortedIndexBy.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/ChunkCursor.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/McapIndexedReader.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/StreamBuffer.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/McapStreamReader.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/McapRecordBuilder.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/ChunkBuilder.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/McapWriter.js","webpack:///../../node_modules/@mcap/core/dist/esm/src/hasMcapPrefix.js"],"sourcesContent":["/**\n * Compute CRC32 lookup tables as described at:\n * https://github.com/komrad36/CRC#option-6-1-byte-tabular\n *\n * An iteration of CRC computation can be performed on 8 bits of input at once. By pre-computing a\n * table of the values of CRC(?) for all 2^8 = 256 possible byte values, during the final\n * computation we can replace a loop over 8 bits with a single lookup in the table.\n *\n * For further speedup, we can also pre-compute the values of CRC(?0) for all possible bytes when a\n * zero byte is appended. Then we can process two bytes of input at once by computing CRC(AB) =\n * CRC(A0) ^ CRC(B), using one lookup in the CRC(?0) table and one lookup in the CRC(?) table.\n *\n * The same technique applies for any number of bytes to be processed at once, although the speed\n * improvements diminish.\n *\n * @param polynomial The binary representation of the polynomial to use (reversed, i.e. most\n * significant bit represents x^0).\n * @param numTables The number of bytes of input that will be processed at once.\n */\nexport function crc32GenerateTables({ polynomial, numTables, }) {\n    const table = new Uint32Array(256 * numTables);\n    for (let i = 0; i < 256; i++) {\n        let r = i;\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        r = ((r & 1) * polynomial) ^ (r >>> 1);\n        table[i] = r;\n    }\n    for (let i = 256; i < table.length; i++) {\n        const value = table[i - 256];\n        table[i] = table[value & 0xff] ^ (value >>> 8);\n    }\n    return table;\n}\nconst CRC32_TABLE = crc32GenerateTables({ polynomial: 0xedb88320, numTables: 8 });\n/**\n * Initialize a CRC32 to all 1 bits.\n */\nexport function crc32Init() {\n    return ~0;\n}\n/**\n * Update a streaming CRC32 calculation.\n *\n * For performance, this implementation processes the data 8 bytes at a time, using the algorithm\n * presented at: https://github.com/komrad36/CRC#option-9-8-byte-tabular\n */\nexport function crc32Update(prev, data) {\n    const byteLength = data.byteLength;\n    const view = new DataView(data.buffer, data.byteOffset, byteLength);\n    let r = prev;\n    let offset = 0;\n    // Process bytes one by one until we reach 4-byte alignment, which will speed up uint32 access.\n    const toAlign = -view.byteOffset & 3;\n    for (; offset < toAlign && offset < byteLength; offset++) {\n        r = CRC32_TABLE[(r ^ view.getUint8(offset)) & 0xff] ^ (r >>> 8);\n    }\n    if (offset === byteLength) {\n        return r;\n    }\n    offset = toAlign;\n    // Process 8 bytes (2 uint32s) at a time.\n    let remainingBytes = byteLength - offset;\n    for (; remainingBytes >= 8; offset += 8, remainingBytes -= 8) {\n        r ^= view.getUint32(offset, true);\n        const r2 = view.getUint32(offset + 4, true);\n        r =\n            CRC32_TABLE[0 * 256 + ((r2 >>> 24) & 0xff)] ^\n                CRC32_TABLE[1 * 256 + ((r2 >>> 16) & 0xff)] ^\n                CRC32_TABLE[2 * 256 + ((r2 >>> 8) & 0xff)] ^\n                CRC32_TABLE[3 * 256 + ((r2 >>> 0) & 0xff)] ^\n                CRC32_TABLE[4 * 256 + ((r >>> 24) & 0xff)] ^\n                CRC32_TABLE[5 * 256 + ((r >>> 16) & 0xff)] ^\n                CRC32_TABLE[6 * 256 + ((r >>> 8) & 0xff)] ^\n                CRC32_TABLE[7 * 256 + ((r >>> 0) & 0xff)];\n    }\n    // Process any remaining bytes one by one. (Perf note: inexplicably, using a temporary variable\n    // `i` rather than reusing `offset` here is faster in V8.)\n    for (let i = offset; i < byteLength; i++) {\n        r = CRC32_TABLE[(r ^ view.getUint8(i)) & 0xff] ^ (r >>> 8);\n    }\n    return r;\n}\n/**\n * Finalize a CRC32 by inverting the output value. An unsigned right-shift of 0 is used to ensure the result is a positive number.\n */\nexport function crc32Final(prev) {\n    return (prev ^ ~0) >>> 0;\n}\n/**\n * Calculate a one-shot CRC32. If the data is being accumulated incrementally, use the functions\n * `crc32Init`, `crc32Update`, and `crc32Final` instead.\n */\nexport function crc32(data) {\n    return crc32Final(crc32Update(crc32Init(), data));\n}\n//# sourceMappingURL=index.js.map","var __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar toInt = function (n) { return ~~n; };\n/**\n * Heap\n * @type {Class}\n */\nvar Heap = /** @class */ (function () {\n    /**\n     * Heap instance constructor.\n     * @param  {Function} compare Optional comparison function, defaults to Heap.minComparator<number>\n     */\n    function Heap(compare) {\n        if (compare === void 0) { compare = Heap.minComparator; }\n        var _this = this;\n        this.compare = compare;\n        this.heapArray = [];\n        this._limit = 0;\n        /**\n         * Alias of add\n         */\n        this.offer = this.add;\n        /**\n         * Alias of peek\n         */\n        this.element = this.peek;\n        /**\n         * Alias of pop\n         */\n        this.poll = this.pop;\n        /**\n         * Returns the inverse to the comparison function.\n         * @return {Function}\n         */\n        this._invertedCompare = function (a, b) {\n            return -1 * _this.compare(a, b);\n        };\n    }\n    /*\n              Static methods\n     */\n    /**\n     * Gets children indices for given index.\n     * @param  {Number} idx     Parent index\n     * @return {Array(Number)}  Array of children indices\n     */\n    Heap.getChildrenIndexOf = function (idx) {\n        return [idx * 2 + 1, idx * 2 + 2];\n    };\n    /**\n     * Gets parent index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Parent index, -1 if idx is 0\n     */\n    Heap.getParentIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : 2;\n        return Math.floor((idx - whichChildren) / 2);\n    };\n    /**\n     * Gets sibling index for given index.\n     * @param  {Number} idx  Children index\n     * @return {Number | undefined}      Sibling index, -1 if idx is 0\n     */\n    Heap.getSiblingIndexOf = function (idx) {\n        if (idx <= 0) {\n            return -1;\n        }\n        var whichChildren = idx % 2 ? 1 : -1;\n        return idx + whichChildren;\n    };\n    /**\n     * Min heap comparison function, default.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparator = function (a, b) {\n        if (a > b) {\n            return 1;\n        }\n        else if (a < b) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Max heap comparison function.\n     * @param  {any} a     First element\n     * @param  {any} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparator = function (a, b) {\n        if (b > a) {\n            return 1;\n        }\n        else if (b < a) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * Min number heap comparison function, default.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.minComparatorNumber = function (a, b) {\n        return a - b;\n    };\n    /**\n     * Max number heap comparison function.\n     * @param  {Number} a     First element\n     * @param  {Number} b     Second element\n     * @return {Number}    0 if they're equal, positive if `a` goes up, negative if `b` goes up\n     */\n    Heap.maxComparatorNumber = function (a, b) {\n        return b - a;\n    };\n    /**\n     * Default equality function.\n     * @param  {any} a    First element\n     * @param  {any} b    Second element\n     * @return {Boolean}  True if equal, false otherwise\n     */\n    Heap.defaultIsEqual = function (a, b) {\n        return a === b;\n    };\n    /**\n     * Prints a heap.\n     * @param  {Heap} heap Heap to be printed\n     * @returns {String}\n     */\n    Heap.print = function (heap) {\n        function deep(i) {\n            var pi = Heap.getParentIndexOf(i);\n            return Math.floor(Math.log2(pi + 1));\n        }\n        function repeat(str, times) {\n            var out = '';\n            for (; times > 0; --times) {\n                out += str;\n            }\n            return out;\n        }\n        var node = 0;\n        var lines = [];\n        var maxLines = deep(heap.length - 1) + 2;\n        var maxLength = 0;\n        while (node < heap.length) {\n            var i = deep(node) + 1;\n            if (node === 0) {\n                i = 0;\n            }\n            // Text representation\n            var nodeText = String(heap.get(node));\n            if (nodeText.length > maxLength) {\n                maxLength = nodeText.length;\n            }\n            // Add to line\n            lines[i] = lines[i] || [];\n            lines[i].push(nodeText);\n            node += 1;\n        }\n        return lines\n            .map(function (line, i) {\n            var times = Math.pow(2, maxLines - i) - 1;\n            return (repeat(' ', Math.floor(times / 2) * maxLength) +\n                line\n                    .map(function (el) {\n                    // centered\n                    var half = (maxLength - el.length) / 2;\n                    return repeat(' ', Math.ceil(half)) + el + repeat(' ', Math.floor(half));\n                })\n                    .join(repeat(' ', times * maxLength)));\n        })\n            .join('\\n');\n    };\n    /*\n              Python style\n     */\n    /**\n     * Converts an array into an array-heap, in place\n     * @param  {Array}    arr      Array to be modified\n     * @param  {Function} compare  Optional compare function\n     * @return {Heap}              For convenience, it returns a Heap instance\n     */\n    Heap.heapify = function (arr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = arr;\n        heap.init();\n        return heap;\n    };\n    /**\n     * Extract the peek of an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappop = function (heapArr, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pop();\n    };\n    /**\n     * Pushes a item into an array-heap\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     */\n    Heap.heappush = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        heap.push(item);\n    };\n    /**\n     * Push followed by pop, faster\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item to push\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heappushpop = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.pushpop(item);\n    };\n    /**\n     * Replace peek with item\n     * @param  {Array}    heapArr  Array to be modified, should be a heap\n     * @param  {any}      item     Item as replacement\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Returns the extracted peek\n     */\n    Heap.heapreplace = function (heapArr, item, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.replace(item);\n    };\n    /**\n     * Return the `n` most valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heaptop = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements of a heap-like Array\n     * @param  {Array}    heapArr  Array, should be an array-heap\n     * @param  {number}   n        Max number of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.heapbottom = function (heapArr, n, compare) {\n        if (n === void 0) { n = 1; }\n        var heap = new Heap(compare);\n        heap.heapArray = heapArr;\n        return heap.bottom(n);\n    };\n    /**\n     * Return the `n` most valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.nlargest = function (n, iterable, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = __spreadArray([], __read(iterable), false);\n        heap.init();\n        return heap.top(n);\n    };\n    /**\n     * Return the `n` least valuable elements of an iterable\n     * @param  {number}   n        Max number of elements\n     * @param  {Iterable} Iterable Iterable list of elements\n     * @param  {Function} compare  Optional compare function\n     * @return {any}               Elements\n     */\n    Heap.nsmallest = function (n, iterable, compare) {\n        var heap = new Heap(compare);\n        heap.heapArray = __spreadArray([], __read(iterable), false);\n        heap.init();\n        return heap.bottom(n);\n    };\n    /*\n              Instance methods\n     */\n    /**\n     * Adds an element to the heap. Aliases: `offer`.\n     * Same as: push(element)\n     * @param {any} element Element to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.add = function (element) {\n        this._sortNodeUp(this.heapArray.push(element) - 1);\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Adds an array of elements to the heap.\n     * Similar as: push(element, element, ...).\n     * @param {Array} elements Elements to be added\n     * @return {Boolean} true\n     */\n    Heap.prototype.addAll = function (elements) {\n        var _a;\n        var i = this.length;\n        (_a = this.heapArray).push.apply(_a, __spreadArray([], __read(elements), false));\n        for (var l = this.length; i < l; ++i) {\n            this._sortNodeUp(i);\n        }\n        this._applyLimit();\n        return true;\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype.bottom = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole heap\n            return __spreadArray([], __read(this.heapArray), false);\n        }\n        else {\n            // Some elements\n            var result = this._bottomN_push(~~n);\n            return result;\n        }\n    };\n    /**\n     * Check if the heap is sorted, useful for testing purposes.\n     * @return {Undefined | Element}  Returns an element if something wrong is found, otherwise it's undefined\n     */\n    Heap.prototype.check = function () {\n        var _this = this;\n        return this.heapArray.find(function (el, j) { return !!_this.getChildrenOf(j).find(function (ch) { return _this.compare(el, ch) > 0; }); });\n    };\n    /**\n     * Remove all of the elements from this heap.\n     */\n    Heap.prototype.clear = function () {\n        this.heapArray = [];\n    };\n    /**\n     * Clone this heap\n     * @return {Heap}\n     */\n    Heap.prototype.clone = function () {\n        var cloned = new Heap(this.comparator());\n        cloned.heapArray = this.toArray();\n        cloned._limit = this._limit;\n        return cloned;\n    };\n    /**\n     * Returns the comparison function.\n     * @return {Function}\n     */\n    Heap.prototype.comparator = function () {\n        return this.compare;\n    };\n    /**\n     * Returns true if this queue contains the specified element.\n     * @param  {any}      o   Element to be found\n     * @param  {Function} fn  Optional comparison function, receives (element, needle)\n     * @return {Boolean}\n     */\n    Heap.prototype.contains = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        return this.heapArray.findIndex(function (el) { return fn(el, o); }) >= 0;\n    };\n    /**\n     * Initialise a heap, sorting nodes\n     * @param  {Array} array Optional initial state array\n     */\n    Heap.prototype.init = function (array) {\n        if (array) {\n            this.heapArray = __spreadArray([], __read(array), false);\n        }\n        for (var i = Math.floor(this.heapArray.length); i >= 0; --i) {\n            this._sortNodeDown(i);\n        }\n        this._applyLimit();\n    };\n    /**\n     * Test if the heap has no elements.\n     * @return {Boolean} True if no elements on the heap\n     */\n    Heap.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    /**\n     * Get the leafs of the tree (no children nodes)\n     */\n    Heap.prototype.leafs = function () {\n        if (this.heapArray.length === 0) {\n            return [];\n        }\n        var pi = Heap.getParentIndexOf(this.heapArray.length - 1);\n        return this.heapArray.slice(pi + 1);\n    };\n    Object.defineProperty(Heap.prototype, \"length\", {\n        /**\n         * Length of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this.heapArray.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Heap.prototype, \"limit\", {\n        /**\n         * Get length limit of the heap.\n         * @return {Number}\n         */\n        get: function () {\n            return this._limit;\n        },\n        /**\n         * Set length limit of the heap.\n         * @return {Number}\n         */\n        set: function (_l) {\n            this._limit = ~~_l;\n            this._applyLimit();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Top node. Aliases: `element`.\n     * Same as: `top(1)[0]`\n     * @return {any} Top node\n     */\n    Heap.prototype.peek = function () {\n        return this.heapArray[0];\n    };\n    /**\n     * Extract the top node (root). Aliases: `poll`.\n     * @return {any} Extracted top node, undefined if empty\n     */\n    Heap.prototype.pop = function () {\n        var last = this.heapArray.pop();\n        if (this.length > 0 && last !== undefined) {\n            return this.replace(last);\n        }\n        return last;\n    };\n    /**\n     * Pushes element(s) to the heap.\n     * @param  {...any} elements Elements to insert\n     * @return {Boolean} True if elements are present\n     */\n    Heap.prototype.push = function () {\n        var elements = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            elements[_i] = arguments[_i];\n        }\n        if (elements.length < 1) {\n            return false;\n        }\n        else if (elements.length === 1) {\n            return this.add(elements[0]);\n        }\n        else {\n            return this.addAll(elements);\n        }\n    };\n    /**\n     * Same as push & pop in sequence, but faster\n     * @param  {any} element Element to insert\n     * @return {any}  Extracted top node\n     */\n    Heap.prototype.pushpop = function (element) {\n        var _a;\n        if (this.compare(this.heapArray[0], element) < 0) {\n            _a = __read([this.heapArray[0], element], 2), element = _a[0], this.heapArray[0] = _a[1];\n            this._sortNodeDown(0);\n        }\n        return element;\n    };\n    /**\n     * Remove an element from the heap.\n     * @param  {any}   o      Element to be found\n     * @param  {Function} fn  Optional function to compare\n     * @return {Boolean}      True if the heap was modified\n     */\n    Heap.prototype.remove = function (o, fn) {\n        if (fn === void 0) { fn = Heap.defaultIsEqual; }\n        if (this.length > 0) {\n            if (o === undefined) {\n                this.pop();\n                return true;\n            }\n            else {\n                var idx = this.heapArray.findIndex(function (el) { return fn(el, o); });\n                if (idx >= 0) {\n                    if (idx === 0) {\n                        this.pop();\n                    }\n                    else if (idx === this.length - 1) {\n                        this.heapArray.pop();\n                    }\n                    else {\n                        this.heapArray.splice(idx, 1, this.heapArray.pop());\n                        this._sortNodeUp(idx);\n                        this._sortNodeDown(idx);\n                    }\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * Pop the current peek value, and add the new item.\n     * @param  {any} element  Element to replace peek\n     * @return {any}         Old peek\n     */\n    Heap.prototype.replace = function (element) {\n        var peek = this.heapArray[0];\n        this.heapArray[0] = element;\n        this._sortNodeDown(0);\n        return peek;\n    };\n    /**\n     * Size of the heap\n     * @return {Number}\n     */\n    Heap.prototype.size = function () {\n        return this.length;\n    };\n    /**\n     * Return the top (highest value) N elements of the heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}    Array of length <= N.\n     */\n    Heap.prototype.top = function (n) {\n        if (n === void 0) { n = 1; }\n        if (this.heapArray.length === 0 || n <= 0) {\n            // Nothing to do\n            return [];\n        }\n        else if (this.heapArray.length === 1 || n === 1) {\n            // Just the peek\n            return [this.heapArray[0]];\n        }\n        else if (n >= this.heapArray.length) {\n            // The whole peek\n            return __spreadArray([], __read(this.heapArray), false);\n        }\n        else {\n            // Some elements\n            var result = this._topN_push(~~n);\n            return result;\n        }\n    };\n    /**\n     * Clone the heap's internal array\n     * @return {Array}\n     */\n    Heap.prototype.toArray = function () {\n        return __spreadArray([], __read(this.heapArray), false);\n    };\n    /**\n     * String output, call to Array.prototype.toString()\n     * @return {String}\n     */\n    Heap.prototype.toString = function () {\n        return this.heapArray.toString();\n    };\n    /**\n     * Get the element at the given index.\n     * @param  {Number} i Index to get\n     * @return {any}       Element at that index\n     */\n    Heap.prototype.get = function (i) {\n        return this.heapArray[i];\n    };\n    /**\n     * Get the elements of these node's children\n     * @param  {Number} idx Node index\n     * @return {Array(any)}  Children elements\n     */\n    Heap.prototype.getChildrenOf = function (idx) {\n        var _this = this;\n        return Heap.getChildrenIndexOf(idx)\n            .map(function (i) { return _this.heapArray[i]; })\n            .filter(function (e) { return e !== undefined; });\n    };\n    /**\n     * Get the element of this node's parent\n     * @param  {Number} idx Node index\n     * @return {any}     Parent element\n     */\n    Heap.prototype.getParentOf = function (idx) {\n        var pi = Heap.getParentIndexOf(idx);\n        return this.heapArray[pi];\n    };\n    /**\n     * Iterator interface\n     */\n    Heap.prototype[Symbol.iterator] = function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!this.length) return [3 /*break*/, 2];\n                    return [4 /*yield*/, this.pop()];\n                case 1:\n                    _a.sent();\n                    return [3 /*break*/, 0];\n                case 2: return [2 /*return*/];\n            }\n        });\n    };\n    /**\n     * Returns an iterator. To comply with Java interface.\n     */\n    Heap.prototype.iterator = function () {\n        return this.toArray();\n    };\n    /**\n     * Limit heap size if needed\n     */\n    Heap.prototype._applyLimit = function () {\n        if (this._limit && this._limit < this.heapArray.length) {\n            var rm = this.heapArray.length - this._limit;\n            // It's much faster than splice\n            while (rm) {\n                this.heapArray.pop();\n                --rm;\n            }\n        }\n    };\n    /**\n     * Return the bottom (lowest value) N elements of the heap, without corner cases, unsorted\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._bottomN_push = function (n) {\n        // Use an inverted heap\n        var bottomHeap = new Heap(this.compare);\n        bottomHeap.limit = n;\n        bottomHeap.heapArray = this.heapArray.slice(-n);\n        bottomHeap.init();\n        var startAt = this.heapArray.length - 1 - n;\n        var parentStartAt = Heap.getParentIndexOf(startAt);\n        var indices = [];\n        for (var i = startAt; i > parentStartAt; --i) {\n            indices.push(i);\n        }\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (this.compare(arr[i], bottomHeap.peek()) > 0) {\n                bottomHeap.replace(arr[i]);\n                if (i % 2) {\n                    indices.push(Heap.getParentIndexOf(i));\n                }\n            }\n        }\n        return bottomHeap.toArray();\n    };\n    /**\n     * Move a node to a new index, switching places\n     * @param  {Number} j First node index\n     * @param  {Number} k Another node index\n     */\n    Heap.prototype._moveNode = function (j, k) {\n        var _a;\n        _a = __read([this.heapArray[k], this.heapArray[j]], 2), this.heapArray[j] = _a[0], this.heapArray[k] = _a[1];\n    };\n    /**\n     * Move a node down the tree (to the leaves) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeDown = function (i) {\n        var _this = this;\n        var moveIt = i < this.heapArray.length - 1;\n        var self = this.heapArray[i];\n        var getPotentialParent = function (best, j) {\n            if (_this.heapArray.length > j && _this.compare(_this.heapArray[j], _this.heapArray[best]) < 0) {\n                best = j;\n            }\n            return best;\n        };\n        while (moveIt) {\n            var childrenIdx = Heap.getChildrenIndexOf(i);\n            var bestChildIndex = childrenIdx.reduce(getPotentialParent, childrenIdx[0]);\n            var bestChild = this.heapArray[bestChildIndex];\n            if (typeof bestChild !== 'undefined' && this.compare(self, bestChild) > 0) {\n                this._moveNode(i, bestChildIndex);\n                i = bestChildIndex;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Move a node up the tree (to the root) to find a place where the heap is sorted.\n     * @param  {Number} i Index of the node\n     */\n    Heap.prototype._sortNodeUp = function (i) {\n        var moveIt = i > 0;\n        while (moveIt) {\n            var pi = Heap.getParentIndexOf(i);\n            if (pi >= 0 && this.compare(this.heapArray[pi], this.heapArray[i]) > 0) {\n                this._moveNode(i, pi);\n                i = pi;\n            }\n            else {\n                moveIt = false;\n            }\n        }\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_push = function (n) {\n        // Use an inverted heap\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        var indices = [0];\n        var arr = this.heapArray;\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < arr.length) {\n                if (topHeap.length < n) {\n                    topHeap.push(arr[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n                else if (this.compare(arr[i], topHeap.peek()) < 0) {\n                    topHeap.replace(arr[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: init + push.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_fill = function (n) {\n        // Use an inverted heap\n        var heapArray = this.heapArray;\n        var topHeap = new Heap(this._invertedCompare);\n        topHeap.limit = n;\n        topHeap.heapArray = heapArray.slice(0, n);\n        topHeap.init();\n        var branch = Heap.getParentIndexOf(n - 1) + 1;\n        var indices = [];\n        for (var i = branch; i < n; ++i) {\n            indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i).filter(function (l) { return l < heapArray.length; })), false));\n        }\n        if ((n - 1) % 2) {\n            indices.push(n);\n        }\n        while (indices.length) {\n            var i = indices.shift();\n            if (i < heapArray.length) {\n                if (this.compare(heapArray[i], topHeap.peek()) < 0) {\n                    topHeap.replace(heapArray[i]);\n                    indices.push.apply(indices, __spreadArray([], __read(Heap.getChildrenIndexOf(i)), false));\n                }\n            }\n        }\n        return topHeap.toArray();\n    };\n    /**\n     * Return the top (highest value) N elements of the heap, without corner cases, unsorted\n     * Implementation: heap.\n     *\n     * @param  {Number} n  Number of elements.\n     * @return {Array}     Array of length <= N.\n     */\n    Heap.prototype._topN_heap = function (n) {\n        var topHeap = this.clone();\n        var result = [];\n        for (var i = 0; i < n; ++i) {\n            result.push(topHeap.pop());\n        }\n        return result;\n    };\n    /**\n     * Return index of the top element\n     * @param list\n     */\n    Heap.prototype._topIdxOf = function (list) {\n        if (!list.length) {\n            return -1;\n        }\n        var idx = 0;\n        var top = list[idx];\n        for (var i = 1; i < list.length; ++i) {\n            var comp = this.compare(list[i], top);\n            if (comp < 0) {\n                idx = i;\n                top = list[i];\n            }\n        }\n        return idx;\n    };\n    /**\n     * Return the top element\n     * @param list\n     */\n    Heap.prototype._topOf = function () {\n        var list = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            list[_i] = arguments[_i];\n        }\n        var heap = new Heap(this.compare);\n        heap.init(list);\n        return heap.peek();\n    };\n    return Heap;\n}());\n\nexport { Heap, Heap as default, toInt };\n","// DataView.getBigUint64 was added to relatively recent versions of Safari. It's pretty easy to\n// maintain this fallback code.\n//\n// eslint-disable-next-line @foxglove/no-boolean-parameters\nexport const getBigUint64 = typeof DataView.prototype.getBigUint64 === \"function\"\n    ? DataView.prototype.getBigUint64 // eslint-disable-line @typescript-eslint/unbound-method\n    : function (offset, littleEndian) {\n        const lo = littleEndian === true\n            ? this.getUint32(offset, littleEndian)\n            : this.getUint32(offset + 4, littleEndian);\n        const hi = littleEndian === true\n            ? this.getUint32(offset + 4, littleEndian)\n            : this.getUint32(offset, littleEndian);\n        return (BigInt(hi) << 32n) | BigInt(lo);\n    };\n//# sourceMappingURL=getBigUint64.js.map","import { getBigUint64 } from \"./getBigUint64\";\nexport default class Reader {\n    constructor(view, offset = 0) {\n        this.textDecoder = new TextDecoder();\n        this.view = view;\n        this.offset = offset;\n    }\n    uint8() {\n        const value = this.view.getUint8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    uint16() {\n        const value = this.view.getUint16(this.offset, true);\n        this.offset += 2;\n        return value;\n    }\n    uint32() {\n        const value = this.view.getUint32(this.offset, true);\n        this.offset += 4;\n        return value;\n    }\n    uint64() {\n        const value = getBigUint64.call(this.view, this.offset, true);\n        this.offset += 8;\n        return value;\n    }\n    string() {\n        const length = this.uint32();\n        if (this.offset + length > this.view.byteLength) {\n            throw new Error(`String length ${length} exceeds bounds of buffer`);\n        }\n        const value = this.textDecoder.decode(new Uint8Array(this.view.buffer, this.view.byteOffset + this.offset, length));\n        this.offset += length;\n        return value;\n    }\n    keyValuePairs(readKey, readValue) {\n        const length = this.uint32();\n        if (this.offset + length > this.view.byteLength) {\n            throw new Error(`Key-value pairs length ${length} exceeds bounds of buffer`);\n        }\n        const result = [];\n        const endOffset = this.offset + length;\n        try {\n            while (this.offset < endOffset) {\n                result.push([readKey(this), readValue(this)]);\n            }\n        }\n        catch (err) {\n            throw new Error(`Error reading key-value pairs: ${err.message}`);\n        }\n        if (this.offset !== endOffset) {\n            throw new Error(`Key-value pairs length (${this.offset - endOffset + length}) greater than expected (${length})`);\n        }\n        return result;\n    }\n    map(readKey, readValue) {\n        const length = this.uint32();\n        if (this.offset + length > this.view.byteLength) {\n            throw new Error(`Map length ${length} exceeds bounds of buffer`);\n        }\n        const result = new Map();\n        const endOffset = this.offset + length;\n        try {\n            while (this.offset < endOffset) {\n                const key = readKey(this);\n                const value = readValue(this);\n                const existingValue = result.get(key);\n                if (existingValue != undefined) {\n                    throw new Error(`Duplicate key ${String(key)} (${String(existingValue)} vs ${String(value)})`);\n                }\n                result.set(key, value);\n            }\n        }\n        catch (err) {\n            throw new Error(`Error reading map: ${err.message}`);\n        }\n        if (this.offset !== endOffset) {\n            throw new Error(`Map length (${this.offset - endOffset + length}) greater than expected (${length})`);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=Reader.js.map","/** Array.from(\"\\x89MCAP0\\r\\n\", (c) => c.charCodeAt(0)) */\nexport const MCAP_MAGIC = Object.freeze([137, 77, 67, 65, 80, 48, 13, 10]);\nexport var Opcode;\n(function (Opcode) {\n    Opcode[Opcode[\"MIN\"] = 1] = \"MIN\";\n    Opcode[Opcode[\"HEADER\"] = 1] = \"HEADER\";\n    Opcode[Opcode[\"FOOTER\"] = 2] = \"FOOTER\";\n    Opcode[Opcode[\"SCHEMA\"] = 3] = \"SCHEMA\";\n    Opcode[Opcode[\"CHANNEL\"] = 4] = \"CHANNEL\";\n    Opcode[Opcode[\"MESSAGE\"] = 5] = \"MESSAGE\";\n    Opcode[Opcode[\"CHUNK\"] = 6] = \"CHUNK\";\n    Opcode[Opcode[\"MESSAGE_INDEX\"] = 7] = \"MESSAGE_INDEX\";\n    Opcode[Opcode[\"CHUNK_INDEX\"] = 8] = \"CHUNK_INDEX\";\n    Opcode[Opcode[\"ATTACHMENT\"] = 9] = \"ATTACHMENT\";\n    Opcode[Opcode[\"ATTACHMENT_INDEX\"] = 10] = \"ATTACHMENT_INDEX\";\n    Opcode[Opcode[\"STATISTICS\"] = 11] = \"STATISTICS\";\n    Opcode[Opcode[\"METADATA\"] = 12] = \"METADATA\";\n    Opcode[Opcode[\"METADATA_INDEX\"] = 13] = \"METADATA_INDEX\";\n    Opcode[Opcode[\"SUMMARY_OFFSET\"] = 14] = \"SUMMARY_OFFSET\";\n    Opcode[Opcode[\"DATA_END\"] = 15] = \"DATA_END\";\n    Opcode[Opcode[\"MAX\"] = 15] = \"MAX\";\n})(Opcode || (Opcode = {}));\nexport function isKnownOpcode(opcode) {\n    return opcode >= Opcode.MIN && opcode <= Opcode.MAX;\n}\n//# sourceMappingURL=constants.js.map","import { crc32 } from \"@foxglove/crc\";\nimport Reader from \"./Reader\";\nimport { isKnownOpcode, MCAP_MAGIC, Opcode } from \"./constants\";\n/**\n * Parse a MCAP magic string at `startOffset` in `view`.\n */\nexport function parseMagic(view, startOffset) {\n    if (startOffset + MCAP_MAGIC.length > view.byteLength) {\n        return { usedBytes: 0 };\n    }\n    if (!MCAP_MAGIC.every((val, i) => val === view.getUint8(startOffset + i))) {\n        throw new Error(`Expected MCAP magic '${MCAP_MAGIC.map((val) => val.toString(16).padStart(2, \"0\")).join(\" \")}', found '${Array.from(MCAP_MAGIC, (_, i) => view\n            .getUint8(startOffset + i)\n            .toString(16)\n            .padStart(2, \"0\")).join(\" \")}'`);\n    }\n    return {\n        magic: { specVersion: \"0\" },\n        usedBytes: MCAP_MAGIC.length,\n    };\n}\n/**\n * Parse a MCAP record beginning at `startOffset` in `view`.\n */\nexport function parseRecord({ view, startOffset, validateCrcs, }) {\n    if (startOffset + /*opcode*/ 1 + /*record content length*/ 8 >= view.byteLength) {\n        return { usedBytes: 0 };\n    }\n    const headerReader = new Reader(view, startOffset);\n    const opcode = headerReader.uint8();\n    const recordLength = headerReader.uint64();\n    if (recordLength > Number.MAX_SAFE_INTEGER) {\n        throw new Error(`Record content length ${recordLength} is too large`);\n    }\n    const recordEndOffset = headerReader.offset + Number(recordLength);\n    if (recordEndOffset > view.byteLength) {\n        return { usedBytes: 0 };\n    }\n    if (!isKnownOpcode(opcode)) {\n        const record = {\n            type: \"Unknown\",\n            opcode,\n            data: new Uint8Array(view.buffer, view.byteOffset + headerReader.offset, Number(recordLength)),\n        };\n        return { record, usedBytes: recordEndOffset - startOffset };\n    }\n    const recordView = new DataView(view.buffer, view.byteOffset + headerReader.offset, Number(recordLength));\n    const reader = new Reader(recordView);\n    switch (opcode) {\n        case Opcode.HEADER: {\n            const profile = reader.string();\n            const library = reader.string();\n            const record = { type: \"Header\", profile, library };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.FOOTER: {\n            const summaryStart = reader.uint64();\n            const summaryOffsetStart = reader.uint64();\n            const summaryCrc = reader.uint32();\n            const record = {\n                type: \"Footer\",\n                summaryStart,\n                summaryOffsetStart,\n                summaryCrc,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.SCHEMA: {\n            const id = reader.uint16();\n            const name = reader.string();\n            const encoding = reader.string();\n            const dataLen = reader.uint32();\n            if (reader.offset + dataLen > recordView.byteLength) {\n                throw new Error(`Schema data length ${dataLen} exceeds bounds of record`);\n            }\n            const data = new Uint8Array(recordView.buffer.slice(recordView.byteOffset + reader.offset, recordView.byteOffset + reader.offset + dataLen));\n            reader.offset += dataLen;\n            const record = {\n                type: \"Schema\",\n                id,\n                encoding,\n                name,\n                data,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.CHANNEL: {\n            const channelId = reader.uint16();\n            const schemaId = reader.uint16();\n            const topicName = reader.string();\n            const messageEncoding = reader.string();\n            const metadata = reader.map((r) => r.string(), (r) => r.string());\n            const record = {\n                type: \"Channel\",\n                id: channelId,\n                schemaId,\n                topic: topicName,\n                messageEncoding,\n                metadata,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.MESSAGE: {\n            const channelId = reader.uint16();\n            const sequence = reader.uint32();\n            const logTime = reader.uint64();\n            const publishTime = reader.uint64();\n            const data = new Uint8Array(recordView.buffer.slice(recordView.byteOffset + reader.offset, recordView.byteOffset + recordView.byteLength));\n            const record = {\n                type: \"Message\",\n                channelId,\n                sequence,\n                logTime,\n                publishTime,\n                data,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.CHUNK: {\n            const startTime = reader.uint64();\n            const endTime = reader.uint64();\n            const uncompressedSize = reader.uint64();\n            const uncompressedCrc = reader.uint32();\n            const compression = reader.string();\n            const recordByteLength = Number(reader.uint64());\n            if (recordByteLength + reader.offset > recordView.byteLength) {\n                throw new Error(\"Chunk records length exceeds remaining record size\");\n            }\n            const records = new Uint8Array(recordView.buffer.slice(recordView.byteOffset + reader.offset, recordView.byteOffset + reader.offset + recordByteLength));\n            const record = {\n                type: \"Chunk\",\n                messageStartTime: startTime,\n                messageEndTime: endTime,\n                compression,\n                uncompressedSize,\n                uncompressedCrc,\n                records,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.MESSAGE_INDEX: {\n            const channelId = reader.uint16();\n            const records = reader.keyValuePairs((r) => r.uint64(), (r) => r.uint64());\n            const record = {\n                type: \"MessageIndex\",\n                channelId,\n                records,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.CHUNK_INDEX: {\n            const messageStartTime = reader.uint64();\n            const messageEndTime = reader.uint64();\n            const chunkStartOffset = reader.uint64();\n            const chunkLength = reader.uint64();\n            const messageIndexOffsets = reader.map((r) => r.uint16(), (r) => r.uint64());\n            const messageIndexLength = reader.uint64();\n            const compression = reader.string();\n            const compressedSize = reader.uint64();\n            const uncompressedSize = reader.uint64();\n            const record = {\n                type: \"ChunkIndex\",\n                messageStartTime,\n                messageEndTime,\n                chunkStartOffset,\n                chunkLength,\n                messageIndexOffsets,\n                messageIndexLength,\n                compression,\n                compressedSize,\n                uncompressedSize,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.ATTACHMENT: {\n            const logTime = reader.uint64();\n            const createTime = reader.uint64();\n            const name = reader.string();\n            const mediaType = reader.string();\n            const dataLen = reader.uint64();\n            if (BigInt(recordView.byteOffset + reader.offset) + dataLen > Number.MAX_SAFE_INTEGER) {\n                throw new Error(`Attachment too large: ${dataLen}`);\n            }\n            if (reader.offset + Number(dataLen) + 4 /*crc*/ > recordView.byteLength) {\n                throw new Error(`Attachment data length ${dataLen} exceeds bounds of record`);\n            }\n            const data = new Uint8Array(recordView.buffer.slice(recordView.byteOffset + reader.offset, recordView.byteOffset + reader.offset + Number(dataLen)));\n            reader.offset += Number(dataLen);\n            const crcLength = reader.offset;\n            const expectedCrc = reader.uint32();\n            if (validateCrcs && expectedCrc !== 0) {\n                const actualCrc = crc32(new DataView(recordView.buffer, recordView.byteOffset, crcLength));\n                if (actualCrc !== expectedCrc) {\n                    throw new Error(`Attachment CRC32 mismatch: expected ${expectedCrc}, actual ${actualCrc}`);\n                }\n            }\n            const record = {\n                type: \"Attachment\",\n                logTime,\n                createTime,\n                name,\n                mediaType,\n                data,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.ATTACHMENT_INDEX: {\n            const offset = reader.uint64();\n            const length = reader.uint64();\n            const logTime = reader.uint64();\n            const createTime = reader.uint64();\n            const dataSize = reader.uint64();\n            const name = reader.string();\n            const mediaType = reader.string();\n            const record = {\n                type: \"AttachmentIndex\",\n                offset,\n                length,\n                logTime,\n                createTime,\n                dataSize,\n                name,\n                mediaType,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.STATISTICS: {\n            const messageCount = reader.uint64();\n            const schemaCount = reader.uint16();\n            const channelCount = reader.uint32();\n            const attachmentCount = reader.uint32();\n            const metadataCount = reader.uint32();\n            const chunkCount = reader.uint32();\n            const messageStartTime = reader.uint64();\n            const messageEndTime = reader.uint64();\n            const channelMessageCounts = reader.map((r) => r.uint16(), (r) => r.uint64());\n            const record = {\n                type: \"Statistics\",\n                messageCount,\n                schemaCount,\n                channelCount,\n                attachmentCount,\n                metadataCount,\n                chunkCount,\n                messageStartTime,\n                messageEndTime,\n                channelMessageCounts,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.METADATA: {\n            const name = reader.string();\n            const metadata = reader.map((r) => r.string(), (r) => r.string());\n            const record = { type: \"Metadata\", metadata, name };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.METADATA_INDEX: {\n            const offset = reader.uint64();\n            const length = reader.uint64();\n            const name = reader.string();\n            const record = {\n                type: \"MetadataIndex\",\n                offset,\n                length,\n                name,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.SUMMARY_OFFSET: {\n            const groupOpcode = reader.uint8();\n            const groupStart = reader.uint64();\n            const groupLength = reader.uint64();\n            const record = {\n                type: \"SummaryOffset\",\n                groupOpcode,\n                groupStart,\n                groupLength,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n        case Opcode.DATA_END: {\n            const dataSectionCrc = reader.uint32();\n            const record = {\n                type: \"DataEnd\",\n                dataSectionCrc,\n            };\n            return { record, usedBytes: recordEndOffset - startOffset };\n        }\n    }\n}\n//# sourceMappingURL=parse.js.map","/**\n * Return the lowest index of `array` where an element can be inserted and maintain its sorted\n * order. This is a specialization of lodash's sortedIndexBy().\n */\nexport function sortedIndexBy(array, value, iteratee) {\n    let low = 0;\n    let high = array.length;\n    if (high === 0) {\n        return 0;\n    }\n    const computedValue = iteratee(value);\n    while (low < high) {\n        const mid = (low + high) >>> 1;\n        const curComputedValue = iteratee(array[mid][0]);\n        if (curComputedValue < computedValue) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return high;\n}\n//# sourceMappingURL=sortedIndexBy.js.map","import Heap from \"heap-js\";\nimport { parseRecord } from \"./parse\";\nimport { sortedIndexBy } from \"./sortedIndexBy\";\n/**\n * ChunkCursor represents the reader's position in a particular chunk. The indexed reader holds\n * ChunkCursors in a heap in order to merge multiple chunks together.\n *\n * Each chunk can contain multiple channels, and so a ChunkCursor itself contains a heap of cursors\n * pointing into the message index for each channel of interest.\n */\nexport class ChunkCursor {\n    constructor(params) {\n        this.chunkIndex = params.chunkIndex;\n        this.relevantChannels = params.relevantChannels;\n        this.startTime = params.startTime;\n        this.endTime = params.endTime;\n        this.reverse = params.reverse;\n        if (this.chunkIndex.messageIndexLength === 0n) {\n            throw new Error(`Chunks without message indexes are not currently supported`);\n        }\n    }\n    /**\n     * Returns `< 0` if the callee's next available message logTime is earlier than `other`'s, `> 0`\n     * for the opposite case. Never returns `0` because ties are broken by the chunks' offsets in the\n     * file.\n     *\n     * Cursors that still need `loadMessageIndexes()` are sorted earlier so the caller can load them\n     * and re-sort the cursors.\n     */\n    compare(other) {\n        if (this.reverse !== other.reverse) {\n            throw new Error(\"Cannot compare a reversed ChunkCursor to a non-reversed ChunkCursor\");\n        }\n        let diff = Number(this.getSortTime() - other.getSortTime());\n        // Break ties by chunk offset in the file\n        if (diff === 0) {\n            diff = Number(this.chunkIndex.chunkStartOffset - other.chunkIndex.chunkStartOffset);\n        }\n        return this.reverse ? -diff : diff;\n    }\n    /**\n     * Returns true if there are more messages available in the chunk. Message indexes must have been\n     * loaded before using this method.\n     */\n    hasMoreMessages() {\n        if (!this.messageIndexCursors) {\n            throw new Error(\"loadMessageIndexes() must be called before hasMore()\");\n        }\n        return this.messageIndexCursors.size() > 0;\n    }\n    /**\n     * Pop a message offset off of the chunk cursor. Message indexes must have been loaded before\n     * using this method.\n     */\n    popMessage() {\n        if (!this.messageIndexCursors) {\n            throw new Error(\"loadMessageIndexes() must be called before popMessage()\");\n        }\n        const cursor = this.messageIndexCursors.peek();\n        if (!cursor) {\n            throw new Error(`Unexpected popMessage() call when no more messages are available, in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n        }\n        const record = cursor.records[cursor.index];\n        const [logTime] = record;\n        if (this.startTime != undefined && logTime < this.startTime) {\n            throw new Error(`Encountered message with logTime (${logTime}) prior to startTime (${this.startTime}) in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n        }\n        if (this.endTime != undefined && logTime > this.endTime) {\n            throw new Error(`Encountered message with logTime (${logTime}) after endTime (${this.endTime}) in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n        }\n        const nextRecord = cursor.records[cursor.index + 1];\n        if (nextRecord && this.reverse) {\n            if (this.startTime == undefined || nextRecord[0] >= this.startTime) {\n                cursor.index++;\n                this.messageIndexCursors.replace(cursor);\n                return record;\n            }\n        }\n        else if (nextRecord) {\n            if (this.endTime == undefined || nextRecord[0] <= this.endTime) {\n                cursor.index++;\n                this.messageIndexCursors.replace(cursor);\n                return record;\n            }\n        }\n        this.messageIndexCursors.pop();\n        return record;\n    }\n    /**\n     * Returns true if message indexes have been loaded, false if `loadMessageIndexes()` needs to be\n     * called.\n     */\n    hasMessageIndexes() {\n        return this.messageIndexCursors != undefined;\n    }\n    async loadMessageIndexes(readable) {\n        const reverse = this.reverse;\n        this.messageIndexCursors = new Heap((a, b) => {\n            const logTimeA = a.records[a.index]?.[0];\n            const logTimeB = b.records[b.index]?.[0];\n            if (reverse) {\n                if (logTimeA == undefined) {\n                    return -1;\n                }\n                else if (logTimeB == undefined) {\n                    return 1;\n                }\n                return Number(logTimeB - logTimeA);\n            }\n            else {\n                if (logTimeA == undefined) {\n                    return 1;\n                }\n                else if (logTimeB == undefined) {\n                    return -1;\n                }\n                return Number(logTimeA - logTimeB);\n            }\n        });\n        let messageIndexStartOffset;\n        let relevantMessageIndexStartOffset;\n        for (const [channelId, offset] of this.chunkIndex.messageIndexOffsets) {\n            if (messageIndexStartOffset == undefined || offset < messageIndexStartOffset) {\n                messageIndexStartOffset = offset;\n            }\n            if (!this.relevantChannels || this.relevantChannels.has(channelId)) {\n                if (relevantMessageIndexStartOffset == undefined ||\n                    offset < relevantMessageIndexStartOffset) {\n                    relevantMessageIndexStartOffset = offset;\n                }\n            }\n        }\n        if (messageIndexStartOffset == undefined || relevantMessageIndexStartOffset == undefined) {\n            return;\n        }\n        // Future optimization: read only message indexes for given channelIds, not all message indexes for the chunk\n        const messageIndexEndOffset = messageIndexStartOffset + this.chunkIndex.messageIndexLength;\n        const messageIndexes = await readable.read(relevantMessageIndexStartOffset, messageIndexEndOffset - relevantMessageIndexStartOffset);\n        const messageIndexesView = new DataView(messageIndexes.buffer, messageIndexes.byteOffset, messageIndexes.byteLength);\n        let offset = 0;\n        for (let result; (result = parseRecord({ view: messageIndexesView, startOffset: offset, validateCrcs: true })),\n            result.record; offset += result.usedBytes) {\n            if (result.record.type !== \"MessageIndex\") {\n                continue;\n            }\n            if (result.record.records.length === 0 ||\n                (this.relevantChannels && !this.relevantChannels.has(result.record.channelId))) {\n                continue;\n            }\n            result.record.records.sort(([logTimeA], [logTimeB]) => Number(logTimeA - logTimeB));\n            if (reverse) {\n                // If we used `logTimeB - logTimeA` as the comparator for reverse iteration, messages with\n                // the same timestamp would not be in reverse order. To avoid this problem we use reverse()\n                // instead.\n                result.record.records.reverse();\n            }\n            for (let i = 0; i < result.record.records.length; i++) {\n                const [logTime] = result.record.records[i];\n                if (logTime < this.chunkIndex.messageStartTime) {\n                    throw new Error(`Encountered message index entry in channel ${result.record.channelId} with logTime (${logTime}) earlier than chunk messageStartTime (${this.chunkIndex.messageStartTime}) in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n                }\n                if (logTime > this.chunkIndex.messageEndTime) {\n                    throw new Error(`Encountered message index entry in channel ${result.record.channelId} with logTime (${logTime}) later than chunk messageEndTime (${this.chunkIndex.messageEndTime}) in chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n                }\n            }\n            let startIndex = 0;\n            if (reverse) {\n                if (this.endTime != undefined) {\n                    startIndex = sortedIndexBy(result.record.records, this.endTime, (logTime) => -logTime);\n                }\n            }\n            else {\n                if (this.startTime != undefined) {\n                    startIndex = sortedIndexBy(result.record.records, this.startTime, (logTime) => logTime);\n                }\n            }\n            if (startIndex >= result.record.records.length) {\n                continue;\n            }\n            if (reverse) {\n                if (this.startTime != undefined && result.record.records[startIndex][0] < this.startTime) {\n                    continue;\n                }\n            }\n            else {\n                if (this.endTime != undefined && result.record.records[startIndex][0] > this.endTime) {\n                    continue;\n                }\n            }\n            this.messageIndexCursors.push({\n                index: startIndex,\n                channelId: result.record.channelId,\n                records: result.record.records,\n            });\n        }\n        if (offset !== messageIndexesView.byteLength) {\n            throw new Error(`${messageIndexesView.byteLength - offset} bytes remaining in message index section`);\n        }\n    }\n    getSortTime() {\n        if (!this.messageIndexCursors) {\n            return this.reverse ? this.chunkIndex.messageEndTime : this.chunkIndex.messageStartTime;\n        }\n        const cursor = this.messageIndexCursors.peek();\n        if (!cursor) {\n            throw new Error(`Unexpected empty cursor for chunk at offset ${this.chunkIndex.chunkStartOffset}`);\n        }\n        return cursor.records[cursor.index][0];\n    }\n}\n//# sourceMappingURL=ChunkCursor.js.map","import { crc32, crc32Final, crc32Init, crc32Update } from \"@foxglove/crc\";\nimport Heap from \"heap-js\";\nimport { ChunkCursor } from \"./ChunkCursor\";\nimport { MCAP_MAGIC } from \"./constants\";\nimport { parseMagic, parseRecord } from \"./parse\";\nexport class McapIndexedReader {\n    constructor(args) {\n        this.metadataIndexes = [];\n        this.readable = args.readable;\n        this.chunkIndexes = args.chunkIndexes;\n        this.attachmentIndexes = args.attachmentIndexes;\n        this.metadataIndexes = args.metadataIndexes;\n        this.statistics = args.statistics;\n        this.decompressHandlers = args.decompressHandlers;\n        this.channelsById = args.channelsById;\n        this.schemasById = args.schemasById;\n        this.summaryOffsetsByOpcode = args.summaryOffsetsByOpcode;\n        this.header = args.header;\n        this.footer = args.footer;\n        for (const chunk of args.chunkIndexes) {\n            if (this.messageStartTime == undefined || chunk.messageStartTime < this.messageStartTime) {\n                this.messageStartTime = chunk.messageStartTime;\n            }\n            if (this.messageEndTime == undefined || chunk.messageEndTime > this.messageEndTime) {\n                this.messageEndTime = chunk.messageEndTime;\n            }\n        }\n        for (const attachment of args.attachmentIndexes) {\n            if (this.attachmentStartTime == undefined || attachment.logTime < this.attachmentStartTime) {\n                this.attachmentStartTime = attachment.logTime;\n            }\n            if (this.attachmentEndTime == undefined || attachment.logTime > this.attachmentEndTime) {\n                this.attachmentEndTime = attachment.logTime;\n            }\n        }\n    }\n    errorWithLibrary(message) {\n        return new Error(`${message} [library=${this.header.library}]`);\n    }\n    static async Initialize({ readable, decompressHandlers, }) {\n        const size = await readable.size();\n        let header;\n        {\n            const headerPrefix = await readable.read(0n, BigInt(MCAP_MAGIC.length + /* Opcode.HEADER */ 1 + /* record content length */ 8));\n            const headerPrefixView = new DataView(headerPrefix.buffer, headerPrefix.byteOffset, headerPrefix.byteLength);\n            void parseMagic(headerPrefixView, 0);\n            const headerLength = headerPrefixView.getBigUint64(MCAP_MAGIC.length + /* Opcode.HEADER */ 1, true);\n            const headerRecord = await readable.read(BigInt(MCAP_MAGIC.length), \n            /* Opcode.HEADER */ 1n + /* record content length */ 8n + headerLength);\n            const headerResult = parseRecord({\n                view: new DataView(headerRecord.buffer, headerRecord.byteOffset, headerRecord.byteLength),\n                startOffset: 0,\n                validateCrcs: true,\n            });\n            if (headerResult.record?.type !== \"Header\") {\n                throw new Error(`Unable to read header at beginning of file; found ${headerResult.record?.type ?? \"nothing\"}`);\n            }\n            if (headerResult.usedBytes !== headerRecord.byteLength) {\n                throw new Error(`${headerRecord.byteLength - headerResult.usedBytes} bytes remaining after parsing header`);\n            }\n            header = headerResult.record;\n        }\n        function errorWithLibrary(message) {\n            return new Error(`${message} [library=${header.library}]`);\n        }\n        let footerOffset;\n        let footerAndMagicView;\n        {\n            const headerLengthLowerBound = BigInt(MCAP_MAGIC.length +\n                /* Opcode.HEADER */ 1 +\n                /* record content length */ 8 +\n                /* profile length */ 4 +\n                /* library length */ 4);\n            const footerAndMagicReadLength = BigInt(\n            /* Opcode.FOOTER */ 1 +\n                /* record content length */ 8 +\n                /* summaryStart */ 8 +\n                /* summaryOffsetStart */ 8 +\n                /* crc */ 4 +\n                MCAP_MAGIC.length);\n            if (size < headerLengthLowerBound + footerAndMagicReadLength) {\n                throw errorWithLibrary(`File size (${size}) is too small to be valid MCAP`);\n            }\n            footerOffset = size - footerAndMagicReadLength;\n            const footerBuffer = await readable.read(footerOffset, footerAndMagicReadLength);\n            footerAndMagicView = new DataView(footerBuffer.buffer, footerBuffer.byteOffset, footerBuffer.byteLength);\n        }\n        try {\n            void parseMagic(footerAndMagicView, footerAndMagicView.byteLength - MCAP_MAGIC.length);\n        }\n        catch (error) {\n            throw errorWithLibrary(error.message);\n        }\n        let footer;\n        {\n            const footerResult = parseRecord({\n                view: footerAndMagicView,\n                startOffset: 0,\n                validateCrcs: true,\n            });\n            if (footerResult.record?.type !== \"Footer\") {\n                throw errorWithLibrary(`Unable to read footer from end of file (offset ${footerOffset}); found ${footerResult.record?.type ?? \"nothing\"}`);\n            }\n            if (footerResult.usedBytes !== footerAndMagicView.byteLength - MCAP_MAGIC.length) {\n                throw errorWithLibrary(`${footerAndMagicView.byteLength - MCAP_MAGIC.length - footerResult.usedBytes} bytes remaining after parsing footer`);\n            }\n            footer = footerResult.record;\n        }\n        if (footer.summaryStart === 0n) {\n            throw errorWithLibrary(\"File is not indexed\");\n        }\n        // Copy the footer prefix before reading the summary because calling readable.read() may reuse the buffer.\n        const footerPrefix = new Uint8Array(\n        /* Opcode.FOOTER */ 1 +\n            /* record content length */ 8 +\n            /* summary start */ 8 +\n            /* summary offset start */ 8);\n        footerPrefix.set(new Uint8Array(footerAndMagicView.buffer, footerAndMagicView.byteOffset, footerPrefix.byteLength));\n        // Future optimization: avoid holding whole summary blob in memory at once\n        const allSummaryData = await readable.read(footer.summaryStart, footerOffset - footer.summaryStart);\n        if (footer.summaryCrc !== 0) {\n            let summaryCrc = crc32Init();\n            summaryCrc = crc32Update(summaryCrc, allSummaryData);\n            summaryCrc = crc32Update(summaryCrc, footerPrefix);\n            summaryCrc = crc32Final(summaryCrc);\n            if (summaryCrc !== footer.summaryCrc) {\n                throw errorWithLibrary(`Incorrect summary CRC ${summaryCrc} (expected ${footer.summaryCrc})`);\n            }\n        }\n        const indexView = new DataView(allSummaryData.buffer, allSummaryData.byteOffset, allSummaryData.byteLength);\n        const channelsById = new Map();\n        const schemasById = new Map();\n        const chunkIndexes = [];\n        const attachmentIndexes = [];\n        const metadataIndexes = [];\n        const summaryOffsetsByOpcode = new Map();\n        let statistics;\n        let offset = 0;\n        for (let result; (result = parseRecord({ view: indexView, startOffset: offset, validateCrcs: true })),\n            result.record; offset += result.usedBytes) {\n            switch (result.record.type) {\n                case \"Schema\":\n                    schemasById.set(result.record.id, result.record);\n                    break;\n                case \"Channel\":\n                    channelsById.set(result.record.id, result.record);\n                    break;\n                case \"ChunkIndex\":\n                    chunkIndexes.push(result.record);\n                    break;\n                case \"AttachmentIndex\":\n                    attachmentIndexes.push(result.record);\n                    break;\n                case \"MetadataIndex\":\n                    metadataIndexes.push(result.record);\n                    break;\n                case \"Statistics\":\n                    if (statistics) {\n                        throw errorWithLibrary(\"Duplicate Statistics record\");\n                    }\n                    statistics = result.record;\n                    break;\n                case \"SummaryOffset\":\n                    summaryOffsetsByOpcode.set(result.record.groupOpcode, result.record);\n                    break;\n                case \"Header\":\n                case \"Footer\":\n                case \"Message\":\n                case \"Chunk\":\n                case \"MessageIndex\":\n                case \"Attachment\":\n                case \"Metadata\":\n                case \"DataEnd\":\n                    throw errorWithLibrary(`${result.record.type} record not allowed in index section`);\n                case \"Unknown\":\n                    break;\n            }\n        }\n        if (offset !== indexView.byteLength) {\n            throw errorWithLibrary(`${indexView.byteLength - offset} bytes remaining in index section`);\n        }\n        return new McapIndexedReader({\n            readable,\n            chunkIndexes,\n            attachmentIndexes,\n            metadataIndexes,\n            statistics,\n            decompressHandlers,\n            channelsById,\n            schemasById,\n            summaryOffsetsByOpcode,\n            header,\n            footer,\n        });\n    }\n    async *readMessages(args = {}) {\n        const { topics, startTime = this.messageStartTime, endTime = this.messageEndTime, reverse = false, validateCrcs, } = args;\n        if (startTime == undefined || endTime == undefined) {\n            return;\n        }\n        let relevantChannels;\n        if (topics) {\n            relevantChannels = new Set();\n            for (const channel of this.channelsById.values()) {\n                if (topics.includes(channel.topic)) {\n                    relevantChannels.add(channel.id);\n                }\n            }\n        }\n        const chunkCursors = new Heap((a, b) => a.compare(b));\n        for (const chunkIndex of this.chunkIndexes) {\n            if (chunkIndex.messageStartTime <= endTime && chunkIndex.messageEndTime >= startTime) {\n                chunkCursors.push(new ChunkCursor({ chunkIndex, relevantChannels, startTime, endTime, reverse }));\n            }\n        }\n        // Holds the decompressed chunk data for \"active\" chunks. Items are added below when a chunk\n        // cursor becomes active (i.e. when we first need to access messages from the chunk) and removed\n        // when the cursor is removed from the heap.\n        const chunkViewCache = new Map();\n        for (let cursor; (cursor = chunkCursors.peek());) {\n            if (!cursor.hasMessageIndexes()) {\n                // If we encounter a chunk whose message indexes have not been loaded yet, load them and re-organize the heap.\n                await cursor.loadMessageIndexes(this.readable);\n                if (cursor.hasMoreMessages()) {\n                    chunkCursors.replace(cursor);\n                }\n                else {\n                    chunkCursors.pop();\n                }\n                continue;\n            }\n            let chunkView = chunkViewCache.get(cursor.chunkIndex.chunkStartOffset);\n            if (!chunkView) {\n                chunkView = await this.loadChunkData(cursor.chunkIndex);\n                chunkViewCache.set(cursor.chunkIndex.chunkStartOffset, chunkView);\n            }\n            const [logTime, offset] = cursor.popMessage();\n            if (offset >= BigInt(chunkView.byteLength)) {\n                throw this.errorWithLibrary(`Message offset beyond chunk bounds (log time ${logTime}, offset ${offset}, chunk data length ${chunkView.byteLength}) in chunk at offset ${cursor.chunkIndex.chunkStartOffset}`);\n            }\n            const result = parseRecord({\n                view: chunkView,\n                startOffset: Number(offset),\n                validateCrcs: validateCrcs ?? true,\n            });\n            if (!result.record) {\n                throw this.errorWithLibrary(`Unable to parse record at offset ${offset} in chunk at offset ${cursor.chunkIndex.chunkStartOffset}`);\n            }\n            if (result.record.type !== \"Message\") {\n                throw this.errorWithLibrary(`Unexpected record type ${result.record.type} in message index (time ${logTime}, offset ${offset} in chunk at offset ${cursor.chunkIndex.chunkStartOffset})`);\n            }\n            if (result.record.logTime !== logTime) {\n                throw this.errorWithLibrary(`Message log time ${result.record.logTime} did not match message index entry (${logTime} at offset ${offset} in chunk at offset ${cursor.chunkIndex.chunkStartOffset})`);\n            }\n            yield result.record;\n            if (cursor.hasMoreMessages()) {\n                chunkCursors.replace(cursor);\n            }\n            else {\n                chunkCursors.pop();\n                chunkViewCache.delete(cursor.chunkIndex.chunkStartOffset);\n            }\n        }\n    }\n    async *readMetadata(args = {}) {\n        const { name } = args;\n        for (const metadataIndex of this.metadataIndexes) {\n            if (name != undefined && metadataIndex.name !== name) {\n                continue;\n            }\n            const metadataData = await this.readable.read(metadataIndex.offset, metadataIndex.length);\n            const metadataResult = parseRecord({\n                view: new DataView(metadataData.buffer, metadataData.byteOffset, metadataData.byteLength),\n                startOffset: 0,\n                validateCrcs: false,\n            });\n            if (metadataResult.record?.type !== \"Metadata\") {\n                throw this.errorWithLibrary(`Metadata data at offset ${metadataIndex.offset} does not point to metadata record (found ${String(metadataResult.record?.type)})`);\n            }\n            yield metadataResult.record;\n        }\n    }\n    async *readAttachments(args = {}) {\n        const { name, mediaType, startTime = this.attachmentStartTime, endTime = this.attachmentEndTime, validateCrcs, } = args;\n        if (startTime == undefined || endTime == undefined) {\n            return;\n        }\n        for (const attachmentIndex of this.attachmentIndexes) {\n            if (name != undefined && attachmentIndex.name !== name) {\n                continue;\n            }\n            if (mediaType != undefined && attachmentIndex.mediaType !== mediaType) {\n                continue;\n            }\n            if (attachmentIndex.logTime > endTime || attachmentIndex.logTime < startTime) {\n                continue;\n            }\n            const attachmentData = await this.readable.read(attachmentIndex.offset, attachmentIndex.length);\n            const attachmentResult = parseRecord({\n                view: new DataView(attachmentData.buffer, attachmentData.byteOffset, attachmentData.byteLength),\n                startOffset: 0,\n                validateCrcs: validateCrcs ?? true,\n            });\n            if (attachmentResult.record?.type !== \"Attachment\") {\n                throw this.errorWithLibrary(`Attachment data at offset ${attachmentIndex.offset} does not point to attachment record (found ${String(attachmentResult.record?.type)})`);\n            }\n            yield attachmentResult.record;\n        }\n    }\n    async loadChunkData(chunkIndex) {\n        const chunkData = await this.readable.read(chunkIndex.chunkStartOffset, chunkIndex.chunkLength);\n        const chunkResult = parseRecord({\n            view: new DataView(chunkData.buffer, chunkData.byteOffset, chunkData.byteLength),\n            startOffset: 0,\n            validateCrcs: true,\n        });\n        if (chunkResult.record?.type !== \"Chunk\") {\n            throw this.errorWithLibrary(`Chunk start offset ${chunkIndex.chunkStartOffset} does not point to chunk record (found ${String(chunkResult.record?.type)})`);\n        }\n        const chunk = chunkResult.record;\n        let buffer = chunk.records;\n        if (chunk.compression !== \"\" && buffer.byteLength > 0) {\n            const decompress = this.decompressHandlers?.[chunk.compression];\n            if (!decompress) {\n                throw this.errorWithLibrary(`Unsupported compression ${chunk.compression}`);\n            }\n            buffer = decompress(buffer, chunk.uncompressedSize);\n        }\n        if (chunk.uncompressedCrc !== 0) {\n            const chunkCrc = crc32(buffer);\n            if (chunkCrc !== chunk.uncompressedCrc) {\n                throw this.errorWithLibrary(`Incorrect chunk CRC ${chunkCrc} (expected ${chunk.uncompressedCrc})`);\n            }\n        }\n        return new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    }\n}\n//# sourceMappingURL=McapIndexedReader.js.map","/**\n * A growable buffer for use when processing a stream of data.\n */\nexport default class StreamBuffer {\n    constructor(initialCapacity = 0) {\n        this.buffer = new ArrayBuffer(initialCapacity);\n        this.view = new DataView(this.buffer, 0, 0);\n    }\n    bytesRemaining() {\n        return this.view.byteLength;\n    }\n    /** Mark some data as consumed, so the memory can be reused when new data is appended. */\n    consume(count) {\n        this.view = new DataView(this.buffer, this.view.byteOffset + count, this.view.byteLength - count);\n    }\n    /** Add data to the buffer, shifting existing data or reallocating if necessary. */\n    append(data) {\n        if (this.view.byteOffset + this.view.byteLength + data.byteLength <= this.buffer.byteLength) {\n            // Data fits by appending only\n            const array = new Uint8Array(this.view.buffer, this.view.byteOffset);\n            array.set(data, this.view.byteLength);\n            this.view = new DataView(this.buffer, this.view.byteOffset, this.view.byteLength + data.byteLength);\n        }\n        else if (this.view.byteLength + data.byteLength <= this.buffer.byteLength) {\n            // Data fits in allocated buffer but requires moving existing data to start of buffer\n            const oldData = new Uint8Array(this.buffer, this.view.byteOffset, this.view.byteLength);\n            const array = new Uint8Array(this.buffer);\n            array.set(oldData, 0);\n            array.set(data, oldData.byteLength);\n            this.view = new DataView(this.buffer, 0, this.view.byteLength + data.byteLength);\n        }\n        else {\n            // New data doesn't fit, copy to a new buffer\n            // Currently, the new buffer size may be smaller than the old size. For future optimizations,\n            // we could consider making the buffer size increase monotonically.\n            const oldData = new Uint8Array(this.buffer, this.view.byteOffset, this.view.byteLength);\n            this.buffer = new ArrayBuffer((this.view.byteLength + data.byteLength) * 2);\n            const array = new Uint8Array(this.buffer);\n            array.set(oldData, 0);\n            array.set(data, oldData.byteLength);\n            this.view = new DataView(this.buffer, 0, this.view.byteLength + data.byteLength);\n        }\n    }\n}\n//# sourceMappingURL=StreamBuffer.js.map","import { crc32 } from \"@foxglove/crc\";\nimport StreamBuffer from \"./StreamBuffer\";\nimport { MCAP_MAGIC } from \"./constants\";\nimport { parseMagic, parseRecord } from \"./parse\";\n/**\n * A streaming reader for MCAP files.\n *\n * Usage example:\n * ```\n * const reader = new McapStreamReader();\n * stream.on(\"data\", (data) => {\n *   try {\n *     reader.append(data);\n *     for (let record; (record = reader.nextRecord()); ) {\n *       // process available records\n *     }\n *   } catch (e) {\n *     // handle errors\n *   }\n * });\n * ```\n */\nexport default class McapStreamReader {\n    constructor({ includeChunks = false, decompressHandlers = {}, validateCrcs = true, noMagicPrefix = false, } = {}) {\n        this.buffer = new StreamBuffer(MCAP_MAGIC.length * 2);\n        this.doneReading = false;\n        this.generator = this.read();\n        this.channelsById = new Map();\n        this.includeChunks = includeChunks;\n        this.decompressHandlers = decompressHandlers;\n        this.validateCrcs = validateCrcs;\n        this.noMagicPrefix = noMagicPrefix;\n    }\n    /** @returns True if a valid, complete mcap file has been parsed. */\n    done() {\n        return this.doneReading;\n    }\n    /** @returns The number of bytes that have been received by `append()` but not yet parsed. */\n    bytesRemaining() {\n        return this.buffer.bytesRemaining();\n    }\n    /**\n     * Provide the reader with newly received bytes for it to process. After calling this function,\n     * call `nextRecord()` again to parse any records that are now available.\n     */\n    append(data) {\n        if (this.doneReading) {\n            throw new Error(\"Already done reading\");\n        }\n        this.buffer.append(data);\n    }\n    /**\n     * Read the next record from the stream if possible. If not enough data is available to parse a\n     * complete record, or if the reading has terminated with a valid footer, returns undefined.\n     *\n     * This function may throw any errors encountered during parsing. If an error is thrown, the\n     * reader is in an unspecified state and should no longer be used.\n     */\n    nextRecord() {\n        if (this.doneReading) {\n            return undefined;\n        }\n        const result = this.generator.next();\n        if (result.value?.type === \"Channel\") {\n            const existing = this.channelsById.get(result.value.id);\n            this.channelsById.set(result.value.id, result.value);\n            if (existing && !isChannelEqual(existing, result.value)) {\n                throw new Error(`Channel record for id ${result.value.id} (topic: ${result.value.topic}) differs from previous channel record of the same id.`);\n            }\n        }\n        else if (result.value?.type === \"Message\") {\n            const channelId = result.value.channelId;\n            const existing = this.channelsById.get(channelId);\n            if (!existing) {\n                throw new Error(`Encountered message on channel ${channelId} without prior channel record`);\n            }\n        }\n        if (result.done === true) {\n            this.doneReading = true;\n        }\n        return result.value;\n    }\n    *read() {\n        if (!this.noMagicPrefix) {\n            let magic, usedBytes;\n            while ((({ magic, usedBytes } = parseMagic(this.buffer.view, 0)), !magic)) {\n                yield;\n            }\n            this.buffer.consume(usedBytes);\n        }\n        let header;\n        function errorWithLibrary(message) {\n            return new Error(`${message} ${header ? `[library=${header.library}]` : \"[no header]\"}`);\n        }\n        for (;;) {\n            let record;\n            {\n                let usedBytes;\n                while ((({ record, usedBytes } = parseRecord({\n                    view: this.buffer.view,\n                    startOffset: 0,\n                    validateCrcs: this.validateCrcs,\n                })),\n                    !record)) {\n                    yield;\n                }\n                this.buffer.consume(usedBytes);\n            }\n            switch (record.type) {\n                case \"Unknown\":\n                    break;\n                case \"Header\":\n                    if (header) {\n                        throw new Error(`Duplicate Header record: library=${header.library} profile=${header.profile} vs. library=${record.library} profile=${record.profile}`);\n                    }\n                    header = record;\n                    yield record;\n                    break;\n                case \"Schema\":\n                case \"Channel\":\n                case \"Message\":\n                case \"MessageIndex\":\n                case \"ChunkIndex\":\n                case \"Attachment\":\n                case \"AttachmentIndex\":\n                case \"Statistics\":\n                case \"Metadata\":\n                case \"MetadataIndex\":\n                case \"SummaryOffset\":\n                case \"DataEnd\":\n                    yield record;\n                    break;\n                case \"Chunk\": {\n                    if (this.includeChunks) {\n                        yield record;\n                    }\n                    let buffer = record.records;\n                    if (record.compression !== \"\" && buffer.byteLength > 0) {\n                        const decompress = this.decompressHandlers[record.compression];\n                        if (!decompress) {\n                            throw errorWithLibrary(`Unsupported compression ${record.compression}`);\n                        }\n                        buffer = decompress(buffer, record.uncompressedSize);\n                    }\n                    if (this.validateCrcs && record.uncompressedCrc !== 0) {\n                        const chunkCrc = crc32(buffer);\n                        if (chunkCrc !== record.uncompressedCrc) {\n                            throw errorWithLibrary(`Incorrect chunk CRC ${chunkCrc} (expected ${record.uncompressedCrc})`);\n                        }\n                    }\n                    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n                    let chunkOffset = 0;\n                    for (let chunkResult; (chunkResult = parseRecord({\n                        view,\n                        startOffset: chunkOffset,\n                        validateCrcs: this.validateCrcs,\n                    })),\n                        chunkResult.record; chunkOffset += chunkResult.usedBytes) {\n                        switch (chunkResult.record.type) {\n                            case \"Unknown\":\n                                break;\n                            case \"Header\":\n                            case \"Footer\":\n                            case \"Chunk\":\n                            case \"MessageIndex\":\n                            case \"ChunkIndex\":\n                            case \"Attachment\":\n                            case \"AttachmentIndex\":\n                            case \"Statistics\":\n                            case \"Metadata\":\n                            case \"MetadataIndex\":\n                            case \"SummaryOffset\":\n                            case \"DataEnd\":\n                                throw errorWithLibrary(`${chunkResult.record.type} record not allowed inside a chunk`);\n                            case \"Schema\":\n                            case \"Channel\":\n                            case \"Message\":\n                                yield chunkResult.record;\n                                break;\n                        }\n                    }\n                    if (chunkOffset !== buffer.byteLength) {\n                        throw errorWithLibrary(`${buffer.byteLength - chunkOffset} bytes remaining in chunk`);\n                    }\n                    break;\n                }\n                case \"Footer\":\n                    try {\n                        let magic, usedBytes;\n                        while ((({ magic, usedBytes } = parseMagic(this.buffer.view, 0)), !magic)) {\n                            yield;\n                        }\n                        this.buffer.consume(usedBytes);\n                    }\n                    catch (error) {\n                        throw errorWithLibrary(error.message);\n                    }\n                    if (this.buffer.bytesRemaining() !== 0) {\n                        throw errorWithLibrary(`${this.buffer.bytesRemaining()} bytes remaining after MCAP footer and trailing magic`);\n                    }\n                    return record;\n            }\n        }\n    }\n}\nfunction isChannelEqual(a, b) {\n    if (!(a.id === b.id &&\n        a.messageEncoding === b.messageEncoding &&\n        a.schemaId === b.schemaId &&\n        a.topic === b.topic &&\n        a.metadata.size === b.metadata.size)) {\n        return false;\n    }\n    for (const [keyA, valueA] of a.metadata.entries()) {\n        const valueB = b.metadata.get(keyA);\n        if (valueA !== valueB) {\n            return false;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=McapStreamReader.js.map","import { crc32 } from \"@foxglove/crc\";\nimport { BufferBuilder } from \"./BufferBuilder\";\nimport { MCAP_MAGIC, Opcode } from \"./constants\";\n/**\n * McapRecordBuilder provides methods to serialize mcap records to a buffer in memory.\n *\n * It makes no effort to ensure spec compatibility on the order of records, this is the responsibility\n * of the caller.\n *\n * You'll likely want to use one of the higher level writer interfaces unless you are building your\n * own higher level writing interface.\n */\nexport class McapRecordBuilder {\n    constructor(options) {\n        this.options = options;\n        this.bufferBuilder = new BufferBuilder();\n    }\n    get length() {\n        return this.bufferBuilder.length;\n    }\n    get buffer() {\n        return this.bufferBuilder.buffer;\n    }\n    reset() {\n        this.bufferBuilder.reset();\n    }\n    writeMagic() {\n        this.bufferBuilder.bytes(new Uint8Array(MCAP_MAGIC));\n    }\n    writeHeader(header) {\n        this.bufferBuilder.uint8(Opcode.HEADER);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .string(header.profile)\n            .string(header.library);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeFooter(footer) {\n        this.bufferBuilder\n            .uint8(Opcode.FOOTER)\n            .uint64(20n) // footer is fixed length\n            .uint64(footer.summaryStart)\n            .uint64(footer.summaryOffsetStart)\n            .uint32(footer.summaryCrc);\n        // footer record cannot be padded\n        return 20n;\n    }\n    writeSchema(schema) {\n        this.bufferBuilder.uint8(Opcode.SCHEMA);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint16(schema.id)\n            .string(schema.name)\n            .string(schema.encoding)\n            .uint32(schema.data.byteLength)\n            .bytes(schema.data);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeChannel(info) {\n        this.bufferBuilder.uint8(Opcode.CHANNEL);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint16(info.id)\n            .uint16(info.schemaId)\n            .string(info.topic)\n            .string(info.messageEncoding)\n            .tupleArray((key) => this.bufferBuilder.string(key), (value) => this.bufferBuilder.string(value), info.metadata);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeMessage(message) {\n        this.bufferBuilder.uint8(Opcode.MESSAGE);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint16(message.channelId)\n            .uint32(message.sequence)\n            .uint64(message.logTime)\n            .uint64(message.publishTime)\n            .bytes(message.data);\n        // message record cannot be padded\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n    }\n    writeAttachment(attachment) {\n        this.bufferBuilder.uint8(Opcode.ATTACHMENT);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder.uint64(0n); // placeholder\n        const crcStartPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(attachment.logTime)\n            .uint64(attachment.createTime)\n            .string(attachment.name)\n            .string(attachment.mediaType)\n            .uint64(BigInt(attachment.data.byteLength))\n            .bytes(attachment.data);\n        this.bufferBuilder.uint32(crc32(this.bufferBuilder.bufferView(crcStartPosition, this.bufferBuilder.length - crcStartPosition)));\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeAttachmentIndex(attachmentIndex) {\n        this.bufferBuilder.uint8(Opcode.ATTACHMENT_INDEX);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint64(attachmentIndex.offset)\n            .uint64(attachmentIndex.length)\n            .uint64(attachmentIndex.logTime)\n            .uint64(attachmentIndex.createTime)\n            .uint64(attachmentIndex.dataSize)\n            .string(attachmentIndex.name)\n            .string(attachmentIndex.mediaType);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeChunk(chunk) {\n        this.bufferBuilder.uint8(Opcode.CHUNK);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint64(chunk.messageStartTime)\n            .uint64(chunk.messageEndTime)\n            .uint64(chunk.uncompressedSize)\n            .uint32(chunk.uncompressedCrc)\n            .string(chunk.compression)\n            .uint64(BigInt(chunk.records.byteLength))\n            .bytes(chunk.records);\n        // chunk record cannot be padded\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeChunkIndex(chunkIndex) {\n        this.bufferBuilder.uint8(Opcode.CHUNK_INDEX);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint64(chunkIndex.messageStartTime)\n            .uint64(chunkIndex.messageEndTime)\n            .uint64(chunkIndex.chunkStartOffset)\n            .uint64(chunkIndex.chunkLength)\n            .uint32(chunkIndex.messageIndexOffsets.size * 10);\n        for (const [channelId, offset] of chunkIndex.messageIndexOffsets) {\n            this.bufferBuilder.uint16(channelId).uint64(offset);\n        }\n        this.bufferBuilder\n            .uint64(chunkIndex.messageIndexLength)\n            .string(chunkIndex.compression)\n            .uint64(chunkIndex.compressedSize)\n            .uint64(chunkIndex.uncompressedSize);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeMessageIndex(messageIndex) {\n        this.bufferBuilder.uint8(Opcode.MESSAGE_INDEX);\n        const startPosition = this.bufferBuilder.length;\n        // each records tuple is a fixed byte length\n        const messageIndexRecordsByteLength = messageIndex.records.length * 16;\n        this.bufferBuilder\n            .uint64(0n) // placeholder\n            .uint16(messageIndex.channelId)\n            .uint32(messageIndexRecordsByteLength);\n        for (const record of messageIndex.records) {\n            this.bufferBuilder.uint64(record[0]).uint64(record[1]);\n        }\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeMetadata(metadata) {\n        this.bufferBuilder.uint8(Opcode.METADATA);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .string(metadata.name)\n            .tupleArray((key) => this.bufferBuilder.string(key), (value) => this.bufferBuilder.string(value), metadata.metadata);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeMetadataIndex(metadataIndex) {\n        this.bufferBuilder.uint8(Opcode.METADATA_INDEX);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .uint64(metadataIndex.offset)\n            .uint64(metadataIndex.length)\n            .string(metadataIndex.name);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeSummaryOffset(summaryOffset) {\n        this.bufferBuilder.uint8(Opcode.SUMMARY_OFFSET);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .uint8(summaryOffset.groupOpcode)\n            .uint64(summaryOffset.groupStart)\n            .uint64(summaryOffset.groupLength);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeStatistics(statistics) {\n        this.bufferBuilder.uint8(Opcode.STATISTICS);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .uint64(statistics.messageCount)\n            .uint16(statistics.schemaCount)\n            .uint32(statistics.channelCount)\n            .uint32(statistics.attachmentCount)\n            .uint32(statistics.metadataCount)\n            .uint32(statistics.chunkCount)\n            .uint64(statistics.messageStartTime)\n            .uint64(statistics.messageEndTime)\n            .tupleArray((key) => this.bufferBuilder.uint16(key), (value) => this.bufferBuilder.uint64(value), statistics.channelMessageCounts);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n    writeDataEnd(dataEnd) {\n        this.bufferBuilder.uint8(Opcode.DATA_END);\n        const startPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .uint64(0n) // placeholder size\n            .uint32(dataEnd.dataSectionCrc);\n        if (this.options?.padRecords === true) {\n            this.bufferBuilder.uint8(0x01).uint8(0xff).uint8(0xff);\n        }\n        const endPosition = this.bufferBuilder.length;\n        this.bufferBuilder\n            .seek(startPosition)\n            .uint64(BigInt(endPosition - startPosition - 8))\n            .seek(endPosition);\n        return BigInt(endPosition - startPosition + 1);\n    }\n}\n//# sourceMappingURL=McapRecordBuilder.js.map","import { McapRecordBuilder } from \"./McapRecordBuilder\";\nclass ChunkBuilder {\n    constructor({ useMessageIndex = true }) {\n        this.recordWriter = new McapRecordBuilder();\n        this.totalMessageCount = 0;\n        this.messageStartTime = 0n;\n        this.messageEndTime = 0n;\n        if (useMessageIndex) {\n            this.messageIndices = new Map();\n        }\n    }\n    get numMessages() {\n        return this.totalMessageCount;\n    }\n    get buffer() {\n        return this.recordWriter.buffer;\n    }\n    get byteLength() {\n        return this.recordWriter.length;\n    }\n    get indices() {\n        if (this.messageIndices) {\n            return this.messageIndices.values();\n        }\n        return [];\n    }\n    addSchema(schema) {\n        this.recordWriter.writeSchema(schema);\n    }\n    addChannel(info) {\n        if (this.messageIndices && !this.messageIndices.has(info.id)) {\n            this.messageIndices.set(info.id, {\n                channelId: info.id,\n                records: [],\n            });\n        }\n        this.recordWriter.writeChannel(info);\n    }\n    addMessage(message) {\n        if (this.totalMessageCount === 0 || message.logTime < this.messageStartTime) {\n            this.messageStartTime = message.logTime;\n        }\n        if (this.totalMessageCount === 0 || message.logTime > this.messageEndTime) {\n            this.messageEndTime = message.logTime;\n        }\n        if (this.messageIndices) {\n            let messageIndex = this.messageIndices.get(message.channelId);\n            if (!messageIndex) {\n                messageIndex = {\n                    channelId: message.channelId,\n                    records: [],\n                };\n                this.messageIndices.set(message.channelId, messageIndex);\n            }\n            messageIndex.records.push([message.logTime, BigInt(this.recordWriter.length)]);\n        }\n        this.totalMessageCount += 1;\n        this.recordWriter.writeMessage(message);\n    }\n    reset() {\n        this.messageStartTime = 0n;\n        this.messageEndTime = 0n;\n        this.totalMessageCount = 0;\n        this.messageIndices?.clear();\n        this.recordWriter.reset();\n    }\n}\nexport { ChunkBuilder };\n//# sourceMappingURL=ChunkBuilder.js.map","import { crc32Init, crc32Update, crc32Final, crc32 } from \"@foxglove/crc\";\nimport { ChunkBuilder } from \"./ChunkBuilder\";\nimport { McapRecordBuilder } from \"./McapRecordBuilder\";\nimport { Opcode } from \"./constants\";\n/**\n * McapWriter provides an interface for writing messages to MCAP files.\n *\n * NOTE: callers must wait on any method call to complete before calling another\n * method. Calling a method before another has completed will result in a corrupt\n * MCAP file.\n */\nexport class McapWriter {\n    constructor(options) {\n        this.nextChannelId = 0;\n        this.nextSchemaId = 1;\n        this.recordWriter = new McapRecordBuilder();\n        this.schemas = new Map();\n        this.channels = new Map();\n        this.writtenSchemaIds = new Set();\n        this.writtenChannelIds = new Set();\n        this.dataSectionCrc = crc32Init();\n        const { writable, useStatistics = true, useSummaryOffsets = true, useChunks = true, repeatSchemas = true, repeatChannels = true, useAttachmentIndex = true, useMetadataIndex = true, useMessageIndex = true, useChunkIndex = true, startChannelId = 0, chunkSize = 1024 * 1024, compressChunk, } = options;\n        this.writable = writable;\n        this.useSummaryOffsets = useSummaryOffsets;\n        if (useStatistics) {\n            this.statistics = {\n                messageCount: 0n,\n                schemaCount: 0,\n                channelCount: 0,\n                attachmentCount: 0,\n                metadataCount: 0,\n                chunkCount: 0,\n                messageStartTime: 0n,\n                messageEndTime: 0n,\n                channelMessageCounts: new Map(),\n            };\n        }\n        if (useChunks) {\n            this.chunkBuilder = new ChunkBuilder({ useMessageIndex });\n        }\n        this.repeatSchemas = repeatSchemas;\n        this.repeatChannels = repeatChannels;\n        if (useAttachmentIndex) {\n            this.attachmentIndices = [];\n        }\n        if (useMetadataIndex) {\n            this.metadataIndices = [];\n        }\n        if (useChunkIndex) {\n            this.chunkIndices = [];\n        }\n        this.nextChannelId = startChannelId;\n        this.chunkSize = chunkSize;\n        this.compressChunk = compressChunk;\n    }\n    async start(header) {\n        this.recordWriter.writeMagic();\n        this.recordWriter.writeHeader(header);\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n    async end() {\n        await this.finalizeChunk();\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        this.recordWriter.writeDataEnd({ dataSectionCrc: crc32Final(this.dataSectionCrc) });\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        const summaryOffsets = [];\n        const summaryStart = this.writable.position();\n        let summaryCrc = crc32Init();\n        if (this.repeatSchemas) {\n            const schemaStart = this.writable.position();\n            let schemaLength = 0n;\n            for (const schema of this.schemas.values()) {\n                schemaLength += this.recordWriter.writeSchema(schema);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.SCHEMA,\n                groupStart: schemaStart,\n                groupLength: schemaLength,\n            });\n        }\n        if (this.repeatChannels) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const channelStart = this.writable.position();\n            let channelLength = 0n;\n            for (const channel of this.channels.values()) {\n                channelLength += this.recordWriter.writeChannel(channel);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.CHANNEL,\n                groupStart: channelStart,\n                groupLength: channelLength,\n            });\n        }\n        if (this.statistics) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const statisticsStart = this.writable.position();\n            const statisticsLength = this.recordWriter.writeStatistics(this.statistics);\n            summaryOffsets.push({\n                groupOpcode: Opcode.STATISTICS,\n                groupStart: statisticsStart,\n                groupLength: statisticsLength,\n            });\n        }\n        summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        if (this.metadataIndices) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const metadataIndexStart = this.writable.position();\n            let metadataIndexLength = 0n;\n            for (const metadataIndex of this.metadataIndices) {\n                metadataIndexLength += this.recordWriter.writeMetadataIndex(metadataIndex);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.METADATA_INDEX,\n                groupStart: metadataIndexStart,\n                groupLength: metadataIndexLength,\n            });\n        }\n        if (this.attachmentIndices) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const attachmentIndexStart = this.writable.position();\n            let attachmentIndexLength = 0n;\n            for (const attachmentIndex of this.attachmentIndices) {\n                attachmentIndexLength += this.recordWriter.writeAttachmentIndex(attachmentIndex);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.ATTACHMENT_INDEX,\n                groupStart: attachmentIndexStart,\n                groupLength: attachmentIndexLength,\n            });\n        }\n        if (this.chunkIndices) {\n            summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n            await this.writable.write(this.recordWriter.buffer);\n            this.recordWriter.reset();\n            const chunkIndexStart = this.writable.position();\n            let chunkIndexLength = 0n;\n            for (const chunkIndex of this.chunkIndices) {\n                chunkIndexLength += this.recordWriter.writeChunkIndex(chunkIndex);\n            }\n            summaryOffsets.push({\n                groupOpcode: Opcode.CHUNK_INDEX,\n                groupStart: chunkIndexStart,\n                groupLength: chunkIndexLength,\n            });\n        }\n        summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        const summaryOffsetStart = this.writable.position();\n        const summaryLength = summaryOffsetStart - summaryStart;\n        if (this.useSummaryOffsets) {\n            for (const summaryOffset of summaryOffsets) {\n                if (summaryOffset.groupLength !== 0n) {\n                    this.recordWriter.writeSummaryOffset(summaryOffset);\n                }\n            }\n        }\n        summaryCrc = crc32Update(summaryCrc, this.recordWriter.buffer);\n        const footer = {\n            summaryStart: summaryLength === 0n ? 0n : summaryStart,\n            summaryOffsetStart: this.useSummaryOffsets ? summaryOffsetStart : 0n,\n            summaryCrc: 0,\n        };\n        const tempBuffer = new DataView(new ArrayBuffer(1 + 8 + 8 + 8));\n        tempBuffer.setUint8(0, Opcode.FOOTER);\n        tempBuffer.setBigUint64(1, 8n + 8n + 4n, true);\n        tempBuffer.setBigUint64(1 + 8, footer.summaryStart, true);\n        tempBuffer.setBigUint64(1 + 8 + 8, footer.summaryOffsetStart, true);\n        summaryCrc = crc32Update(summaryCrc, tempBuffer);\n        footer.summaryCrc = crc32Final(summaryCrc);\n        this.recordWriter.writeFooter(footer);\n        this.recordWriter.writeMagic();\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n    /**\n     * Add a schema and return a generated schema id. The schema id is used when adding channels.\n     */\n    async registerSchema(info) {\n        const id = this.nextSchemaId++;\n        this.schemas.set(id, { ...info, id });\n        if (this.statistics) {\n            ++this.statistics.schemaCount;\n        }\n        return id;\n    }\n    /**\n     * Add a channel and return a generated channel id. The channel id is used when adding messages.\n     */\n    async registerChannel(info) {\n        const id = this.nextChannelId++;\n        this.channels.set(id, { ...info, id });\n        if (this.statistics) {\n            ++this.statistics.channelCount;\n        }\n        return id;\n    }\n    async addMessage(message) {\n        if (this.statistics) {\n            if (this.statistics.messageCount === 0n) {\n                this.statistics.messageStartTime = message.logTime;\n                this.statistics.messageEndTime = message.logTime;\n            }\n            else {\n                if (message.logTime < this.statistics.messageStartTime) {\n                    this.statistics.messageStartTime = message.logTime;\n                }\n                if (message.logTime > this.statistics.messageEndTime) {\n                    this.statistics.messageEndTime = message.logTime;\n                }\n            }\n            this.statistics.channelMessageCounts.set(message.channelId, (this.statistics.channelMessageCounts.get(message.channelId) ?? 0n) + 1n);\n            ++this.statistics.messageCount;\n        }\n        // write out channel and schema if we have not yet done so\n        if (!this.writtenChannelIds.has(message.channelId)) {\n            const channel = this.channels.get(message.channelId);\n            if (!channel) {\n                throw new Error(`McapWriter#addMessage failed: missing channel for id ${message.channelId}`);\n            }\n            if (channel.schemaId !== 0 && !this.writtenSchemaIds.has(channel.schemaId)) {\n                const schema = this.schemas.get(channel.schemaId);\n                if (!schema) {\n                    throw new Error(`McapWriter#addMessage failed: missing schema for id ${channel.schemaId}`);\n                }\n                if (this.chunkBuilder) {\n                    this.chunkBuilder.addSchema(schema);\n                }\n                else {\n                    this.recordWriter.writeSchema(schema);\n                }\n                this.writtenSchemaIds.add(channel.schemaId);\n            }\n            if (this.chunkBuilder) {\n                this.chunkBuilder.addChannel(channel);\n            }\n            else {\n                this.recordWriter.writeChannel(channel);\n            }\n            this.writtenChannelIds.add(message.channelId);\n        }\n        if (this.chunkBuilder) {\n            this.chunkBuilder.addMessage(message);\n        }\n        else {\n            this.recordWriter.writeMessage(message);\n        }\n        if (this.chunkBuilder && this.chunkBuilder.byteLength > this.chunkSize) {\n            await this.finalizeChunk();\n        }\n    }\n    async addAttachment(attachment) {\n        const length = this.recordWriter.writeAttachment(attachment);\n        if (this.statistics) {\n            ++this.statistics.attachmentCount;\n        }\n        if (this.attachmentIndices) {\n            const offset = this.writable.position();\n            this.attachmentIndices.push({\n                logTime: attachment.logTime,\n                createTime: attachment.createTime,\n                name: attachment.name,\n                mediaType: attachment.mediaType,\n                offset,\n                dataSize: BigInt(attachment.data.byteLength),\n                length,\n            });\n        }\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n    async addMetadata(metadata) {\n        const recordSize = this.recordWriter.writeMetadata(metadata);\n        if (this.statistics) {\n            ++this.statistics.metadataCount;\n        }\n        if (this.metadataIndices) {\n            const offset = this.writable.position();\n            this.metadataIndices.push({\n                name: metadata.name,\n                offset,\n                length: recordSize,\n            });\n        }\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n    async finalizeChunk() {\n        if (!this.chunkBuilder || this.chunkBuilder.numMessages === 0) {\n            return;\n        }\n        if (this.statistics) {\n            ++this.statistics.chunkCount;\n        }\n        const chunkData = this.chunkBuilder.buffer;\n        const uncompressedSize = BigInt(chunkData.length);\n        const uncompressedCrc = crc32(chunkData);\n        let compression = \"\";\n        let compressedData = chunkData;\n        if (this.compressChunk) {\n            ({ compression, compressedData } = this.compressChunk(chunkData));\n        }\n        const chunkRecord = {\n            messageStartTime: this.chunkBuilder.messageStartTime,\n            messageEndTime: this.chunkBuilder.messageEndTime,\n            uncompressedSize,\n            uncompressedCrc,\n            compression,\n            records: compressedData,\n        };\n        const chunkStartOffset = this.writable.position();\n        const chunkLength = this.recordWriter.writeChunk(chunkRecord);\n        const messageIndexOffsets = this.chunkIndices ? new Map() : undefined;\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n        const messageIndexStart = this.writable.position();\n        let messageIndexLength = 0n;\n        for (const messageIndex of this.chunkBuilder.indices) {\n            messageIndexOffsets?.set(messageIndex.channelId, messageIndexStart + messageIndexLength);\n            messageIndexLength += this.recordWriter.writeMessageIndex(messageIndex);\n        }\n        if (this.chunkIndices) {\n            this.chunkIndices.push({\n                messageStartTime: chunkRecord.messageStartTime,\n                messageEndTime: chunkRecord.messageEndTime,\n                chunkStartOffset,\n                chunkLength,\n                messageIndexOffsets: messageIndexOffsets,\n                messageIndexLength,\n                compression: chunkRecord.compression,\n                compressedSize: BigInt(chunkRecord.records.byteLength),\n                uncompressedSize: chunkRecord.uncompressedSize,\n            });\n        }\n        this.chunkBuilder.reset();\n        this.dataSectionCrc = crc32Update(this.dataSectionCrc, this.recordWriter.buffer);\n        await this.writable.write(this.recordWriter.buffer);\n        this.recordWriter.reset();\n    }\n}\n//# sourceMappingURL=McapWriter.js.map","import { MCAP_MAGIC } from \"./constants\";\n/** Check if the given buffer starts with the MCAP magic prefix. */\nexport function hasMcapPrefix(prefix) {\n    return (prefix.byteLength >= MCAP_MAGIC.length &&\n        MCAP_MAGIC.every((val, i) => val === prefix.getUint8(i)));\n}\n//# sourceMappingURL=hasMcapPrefix.js.map"],"names":["crc32GenerateTables","polynomial","numTables","table","i","r","value","CRC32_TABLE","prev","data","byteLength","view","offset","toAlign","remainingBytes","r2","__generator","thisArg","body","_","t","f","y","g","verb","n","v","step","op","e","__read","o","m","ar","error","__spreadArray","to","from","pack","l","toInt","Heap","compare","_this","a","b","idx","whichChildren","heap","deep","pi","repeat","str","times","out","node","lines","maxLines","maxLength","nodeText","line","el","half","arr","heapArr","item","iterable","element","elements","_a","result","j","ch","cloned","fn","array","_l","last","_i","peek","rm","bottomHeap","startAt","parentStartAt","indices","k","moveIt","self","getPotentialParent","best","childrenIdx","bestChildIndex","bestChild","topHeap","heapArray","branch","list","top","comp","getBigUint64","littleEndian","lo","hi","Reader","length","readKey","readValue","endOffset","err","key","existingValue","Opcode","isKnownOpcode","opcode","parseMagic","startOffset","val","parseRecord","validateCrcs","headerReader","recordLength","recordEndOffset","recordView","reader","profile","library","summaryStart","summaryOffsetStart","summaryCrc","id","name","encoding","dataLen","channelId","schemaId","topicName","messageEncoding","metadata","sequence","logTime","publishTime","startTime","endTime","uncompressedSize","uncompressedCrc","compression","recordByteLength","records","messageStartTime","messageEndTime","chunkStartOffset","chunkLength","messageIndexOffsets","messageIndexLength","compressedSize","createTime","mediaType","crcLength","expectedCrc","actualCrc","dataSize","messageCount","schemaCount","channelCount","attachmentCount","metadataCount","chunkCount","channelMessageCounts","groupOpcode","groupStart","groupLength","sortedIndexBy","iteratee","low","high","computedValue","mid","ChunkCursor","params","other","diff","cursor","record","nextRecord","readable","reverse","logTimeA","logTimeB","messageIndexStartOffset","relevantMessageIndexStartOffset","messageIndexEndOffset","messageIndexes","messageIndexesView","startIndex","McapIndexedReader","args","chunk","attachment","message","decompressHandlers","size","header","headerPrefix","headerPrefixView","headerLength","headerRecord","headerResult","errorWithLibrary","footerOffset","footerAndMagicView","headerLengthLowerBound","footerAndMagicReadLength","footerBuffer","footer","footerResult","footerPrefix","allSummaryData","indexView","channelsById","schemasById","chunkIndexes","attachmentIndexes","metadataIndexes","summaryOffsetsByOpcode","statistics","topics","relevantChannels","channel","chunkCursors","chunkIndex","chunkViewCache","chunkView","metadataIndex","metadataData","metadataResult","attachmentIndex","attachmentData","attachmentResult","chunkData","chunkResult","buffer","decompress","chunkCrc","StreamBuffer","initialCapacity","count","oldData","McapStreamReader","includeChunks","noMagicPrefix","existing","isChannelEqual","magic","usedBytes","chunkOffset","keyA","valueA","valueB","options","startPosition","endPosition","schema","info","crcStartPosition","messageIndex","messageIndexRecordsByteLength","summaryOffset","dataEnd","useMessageIndex","McapWriter","writable","useStatistics","useSummaryOffsets","useChunks","repeatSchemas","repeatChannels","useAttachmentIndex","useMetadataIndex","useChunkIndex","startChannelId","chunkSize","compressChunk","summaryOffsets","schemaStart","schemaLength","channelStart","channelLength","statisticsStart","statisticsLength","metadataIndexStart","metadataIndexLength","attachmentIndexStart","attachmentIndexLength","chunkIndexStart","chunkIndexLength","summaryLength","tempBuffer","recordSize","compressedData","chunkRecord","messageIndexStart","hasMcapPrefix","prefix"],"sourceRoot":""}